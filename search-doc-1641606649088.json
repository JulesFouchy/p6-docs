[{"title":"Introduction","type":0,"sectionRef":"#","url":"reference","content":"Introduction","keywords":""},{"title":"p6::Color","type":0,"sectionRef":"#","url":"reference/Classes/classp6_1_1_color","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::Color","url":"reference/Classes/classp6_1_1_color#summary","content":"\tName\tColor(float r =0.f, float g =0.f, float b =0.f, float a =1.f) float\tr() const float\tg() const float\tb() const float\ta() const glm::vec3\tas_vec3() const glm::vec4\tas_vec4() const "},{"title":"Details","type":1,"pageTitle":"p6::Color","url":"reference/Classes/classp6_1_1_color#details","content":""},{"title":"Color()","type":1,"pageTitle":"p6::Color","url":"reference/Classes/classp6_1_1_color#color","content":"Color(float r =0.f, float g =0.f, float b =0.f, float a =1.f); "},{"title":"r()","type":1,"pageTitle":"p6::Color","url":"reference/Classes/classp6_1_1_color#r","content":"r() const; "},{"title":"g()","type":1,"pageTitle":"p6::Color","url":"reference/Classes/classp6_1_1_color#g","content":"g() const; "},{"title":"b()","type":1,"pageTitle":"p6::Color","url":"reference/Classes/classp6_1_1_color#b","content":"b() const; "},{"title":"a()","type":1,"pageTitle":"p6::Color","url":"reference/Classes/classp6_1_1_color#a","content":"a() const; "},{"title":"as_vec3()","type":1,"pageTitle":"p6::Color","url":"reference/Classes/classp6_1_1_color#as_vec3","content":"as_vec3() const; "},{"title":"as_vec4()","type":1,"pageTitle":"p6::Color","url":"reference/Classes/classp6_1_1_color#as_vec4","content":"as_vec4() const;  Updated on 2022 January 08 "},{"title":"p6::Image","type":0,"sectionRef":"#","url":"reference/Classes/classp6_1_1_image","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::Image","url":"reference/Classes/classp6_1_1_image#summary","content":"\tName\tImage(ImageSize size, const uint8_t data =nullptr) data must be nullptr, or an array of size size.width() size.height() * 4, with R, G, B and A channels, starting with the bottom left pixel, and going row by row ImageSize\tsize() const Returns the size in pixels of the image. const Texture &amp;\ttexture() const Returns the internal texture, that you can use to do advanced stuff with custom shaders. void\tdestructive_resize(ImageSize size) Resizes the image /!\\ All of its content is lost. void\tresize(ImageSize size) Resizes the image. "},{"title":"Detailed Description","type":1,"pageTitle":"p6::Image","url":"reference/Classes/classp6_1_1_image#detailed-description","content":"class p6::Image; Copy An image can be drawn onto, and can be displayed. If you plan on drawing on the image, you can create it without data (it will create a black and transparent image). If you want to load an image, you can use load_image() instead of the constructor "},{"title":"Details","type":1,"pageTitle":"p6::Image","url":"reference/Classes/classp6_1_1_image#details","content":""},{"title":"Image()","type":1,"pageTitle":"p6::Image","url":"reference/Classes/classp6_1_1_image#image","content":"Image(ImageSize size, const uint8_t * data =nullptr); data must be nullptr, or an array of size size.width() size.height() 4, with R, G, B and A channels, starting with the bottom left pixel, and going row by row "},{"title":"size()","type":1,"pageTitle":"p6::Image","url":"reference/Classes/classp6_1_1_image#size","content":"size() const; Returns the size in pixels of the image. "},{"title":"texture()","type":1,"pageTitle":"p6::Image","url":"reference/Classes/classp6_1_1_image#texture","content":"texture() const; Returns the internal texture, that you can use to do advanced stuff with custom shaders. "},{"title":"destructive_resize()","type":1,"pageTitle":"p6::Image","url":"reference/Classes/classp6_1_1_image#destructive_resize","content":"destructive_resize(ImageSize size); Resizes the image /!\\ All of its content is lost. If you don't want that you can use resize() instead "},{"title":"resize()","type":1,"pageTitle":"p6::Image","url":"reference/Classes/classp6_1_1_image#resize","content":"resize(ImageSize size); Resizes the image.  Updated on 2022 January 08 "},{"title":"p6::Shader","type":0,"sectionRef":"#","url":"reference/Classes/classp6_1_1_shader","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::Shader","url":"reference/Classes/classp6_1_1_shader#summary","content":"\tName\tShader(const std::string &amp; fragment_source_code) Throws std::runtime_error if there is an error while compiling the shader source code. void\tbind() const void\tset(const std::string &amp; uniform_name, int v) const void\tset(const std::string &amp; uniform_name, unsigned int v) const void\tset(const std::string &amp; uniform_name, bool v) const void\tset(const std::string &amp; uniform_name, float v) const void\tset(const std::string &amp; uniform_name, const glm::vec2 &amp; v) const void\tset(const std::string &amp; uniform_name, const glm::vec3 &amp; v) const void\tset(const std::string &amp; uniform_name, const glm::vec4 &amp; v) const void\tset(const std::string &amp; uniform_name, const glm::mat2 &amp; mat) const void\tset(const std::string &amp; uniform_name, const glm::mat3 &amp; mat) const void\tset(const std::string &amp; uniform_name, const glm::mat4 &amp; mat) const "},{"title":"Details","type":1,"pageTitle":"p6::Shader","url":"reference/Classes/classp6_1_1_shader#details","content":""},{"title":"Shader()","type":1,"pageTitle":"p6::Shader","url":"reference/Classes/classp6_1_1_shader#shader","content":"Shader(const std::string &amp; fragment_source_code); Throws std::runtime_error if there is an error while compiling the shader source code. "},{"title":"bind()","type":1,"pageTitle":"p6::Shader","url":"reference/Classes/classp6_1_1_shader#bind","content":"bind() const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Classes/classp6_1_1_shader#set","content":"set(const std::string &amp; uniform_name, int v) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Classes/classp6_1_1_shader#set-1","content":"set(const std::string &amp; uniform_name, unsigned int v) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Classes/classp6_1_1_shader#set-2","content":"set(const std::string &amp; uniform_name, bool v) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Classes/classp6_1_1_shader#set-3","content":"set(const std::string &amp; uniform_name, float v) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Classes/classp6_1_1_shader#set-4","content":"set(const std::string &amp; uniform_name, const glm::vec2 &amp; v) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Classes/classp6_1_1_shader#set-5","content":"set(const std::string &amp; uniform_name, const glm::vec3 &amp; v) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Classes/classp6_1_1_shader#set-6","content":"set(const std::string &amp; uniform_name, const glm::vec4 &amp; v) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Classes/classp6_1_1_shader#set-7","content":"set(const std::string &amp; uniform_name, const glm::mat2 &amp; mat) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Classes/classp6_1_1_shader#set-8","content":"set(const std::string &amp; uniform_name, const glm::mat3 &amp; mat) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Classes/classp6_1_1_shader#set-9","content":"set(const std::string &amp; uniform_name, const glm::mat4 &amp; mat) const;  Updated on 2022 January 08 "},{"title":"p6::KeyEvent","type":0,"sectionRef":"#","url":"reference/Classes/structp6_1_1_key_event","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::KeyEvent","url":"reference/Classes/structp6_1_1_key_event#summary","content":"\tNamestd::string\tlogical_key The character that was pressed. int\tphysical_key The key at a given position on the keyboard. It is independent of the keyboard layout (e.g. GLFW_KEY_Q will correspond to the first key on the first row of your keyboard, no matter if you are using azerty instead of qwerty) "},{"title":"Details","type":1,"pageTitle":"p6::KeyEvent","url":"reference/Classes/structp6_1_1_key_event#details","content":""},{"title":"logical_key","type":1,"pageTitle":"p6::KeyEvent","url":"reference/Classes/structp6_1_1_key_event#logical_key","content":"std::string logical_key; Copy The character that was pressed. This depends on the keyboard layout (qwerty vs azerty). If the key pressed was not a character (for example ENTER, SHIFT etc.) then this is an empty string. "},{"title":"physical_key","type":1,"pageTitle":"p6::KeyEvent","url":"reference/Classes/structp6_1_1_key_event#physical_key","content":"int physical_key; Copy The key at a given position on the keyboard. It is independent of the keyboard layout (e.g. GLFW_KEY_Q will correspond to the first key on the first row of your keyboard, no matter if you are using azerty instead of qwerty)  Updated on 2022 January 08 "},{"title":"p6::Context","type":0,"sectionRef":"#","url":"reference/Classes/classp6_1_1_context","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#summary","content":"\tName\tContext(WindowCreationParams window_creation_params ={}) void\tbackground(Color color) const Sets the color and alpha of each pixel of the canvas. void\trectangle(RectangleParams params) const Draws a rectangle. void\tellipse(RectangleParams params) const Draws an ellipse. void\timage(const Image &amp; img, RectangleParams params) const Draws an image. void\trender_to_image(const Image &amp; image) const Sets the image where all the drawing commands will happen on. void\trender_to_screen() const Reset p6 to render to the screen. glm::vec2\tmouse() const Returns the current mouse position. glm::vec2\tmouse_delta() const Returns the movement of the mouse since last update() bool\tmouse_is_in_window() const Returns true iff the coordinates returned by mouse() correspond to a position inside the window, and the window is focused. bool\tctrl() const Returns true iff the CTRL key is pressed (or CMD on Mac) bool\tshift() const Returns true iff the SHIFT key is pressed. bool\talt() const Returns true iff the ALT key is pressed. float\taspect_ratio() const Returns the aspect ratio of the window (a.k.a. width / height) ImageSize\twindow_size() const Returns the size of the window. int\twindow_width() const Returns the width of the window. int\twindow_height() const Returns the height of the window. bool\twindow_is_focused() const Returns true iff the window is currently focused. void\tmaximize_window() Maximizes the window. float\ttime() const Returns the time in seconds since the creation of the Context. float\tdelta_time() const Returns the time in seconds since the last update() call (or 0 if this is the first update) void\tset_time_mode_realtime() Sets the time_mode as realtime. void\tset_time_mode_fixedstep() Sets the time_mode as fixedstep. void\trun() Starts the update() loop. void\texit() Stops the run() loop. void\tpause() Pauses the run() loop. void\tresume() Starts the run() loop again if it was paused with pause(). bool\tis_paused() const Returns true iff we are currently paused. See pause() and resume(). std::function&lt; void()&gt;\tupdate This function is called repeatedly, once every 1/framerate() seconds (or at least it will try, if your update code is too slow then the next updates will necessarily be delayed). std::function&lt; void(MouseMove)&gt;\tmouse_moved This function is called whenever the mouse is moved. std::function&lt; void(MouseDrag)&gt;\tmouse_dragged This function is called whenever the mouse is dragged. std::function&lt; void(MouseButton)&gt;\tmouse_pressed This function is called whenever a mouse button is pressed. std::function&lt; void(MouseButton)&gt;\tmouse_released This function is called whenever a mouse button is released. std::function&lt; void(MouseScroll)&gt;\tmouse_scrolled This function is called whenever the mouse wheel is scrolled. std::function&lt; void(KeyEvent)&gt;\tkey_pressed This function is called whenever a keyboard key is pressed. std::function&lt; void(KeyEvent)&gt;\tkey_released This function is called whenever a keyboard key is released. std::function&lt; void(KeyEvent)&gt;\tkey_repeated This function is called repeatedly whenever a keyboard key is held. std::function&lt; void(std::string &amp;&amp;)&gt;\ton_error This function is called whenever an error occurs. Color\tfill Color\tstroke float\tstroke_weight "},{"title":"Details","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#details","content":""},{"title":"Context()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#context","content":"Context(WindowCreationParams window_creation_params ={}); "},{"title":"background()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#background","content":"background(Color color) const; Sets the color and alpha of each pixel of the canvas. NB: No blending is applied ; even if you specify an alpha of 0.5 the old canvas is completely erased. This means that setting an alpha here doesn't matter much. It is only meaningful if you export the canvas as a png, or if you try to blend the canvas on top of another image. "},{"title":"rectangle()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#rectangle","content":"rectangle(RectangleParams params) const; Draws a rectangle. Parameters: params Shape of the rect p6.fill = {0.f, 0.8f, 0.3f};p6.rectangle({}); Copy "},{"title":"ellipse()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#ellipse","content":"ellipse(RectangleParams params) const; Draws an ellipse. "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#image","content":"image(const Image &amp; img, RectangleParams params) const; Draws an image. "},{"title":"render_to_image()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#render_to_image","content":"render_to_image(const Image &amp; image) const; Sets the image where all the drawing commands will happen on. "},{"title":"render_to_screen()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#render_to_screen","content":"render_to_screen() const; Reset p6 to render to the screen. "},{"title":"mouse()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#mouse","content":"mouse() const; Returns the current mouse position. "},{"title":"mouse_delta()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#mouse_delta","content":"mouse_delta() const; Returns the movement of the mouse since last update() "},{"title":"mouse_is_in_window()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#mouse_is_in_window","content":"mouse_is_in_window() const; Returns true iff the coordinates returned by mouse() correspond to a position inside the window, and the window is focused. "},{"title":"ctrl()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#ctrl","content":"ctrl() const; Returns true iff the CTRL key is pressed (or CMD on Mac) "},{"title":"shift()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#shift","content":"shift() const; Returns true iff the SHIFT key is pressed. "},{"title":"alt()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#alt","content":"alt() const; Returns true iff the ALT key is pressed. "},{"title":"aspect_ratio()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#aspect_ratio","content":"aspect_ratio() const; Returns the aspect ratio of the window (a.k.a. width / height) "},{"title":"window_size()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#window_size","content":"window_size() const; Returns the size of the window. "},{"title":"window_width()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#window_width","content":"window_width() const; Returns the width of the window. "},{"title":"window_height()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#window_height","content":"window_height() const; Returns the height of the window. "},{"title":"window_is_focused()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#window_is_focused","content":"window_is_focused() const; Returns true iff the window is currently focused. "},{"title":"maximize_window()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#maximize_window","content":"maximize_window(); Maximizes the window. "},{"title":"time()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#time","content":"time() const; Returns the time in seconds since the creation of the Context. "},{"title":"delta_time()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#delta_time","content":"delta_time() const; Returns the time in seconds since the last update() call (or 0 if this is the first update) "},{"title":"set_time_mode_realtime()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#set_time_mode_realtime","content":"set_time_mode_realtime(); Sets the time_mode as realtime. This means that what is returned by time() and delta_time() corresponds to the actual time that elapsed in the real world. This is ideal when you want to do realtime animation and interactive sketches. "},{"title":"set_time_mode_fixedstep()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#set_time_mode_fixedstep","content":"set_time_mode_fixedstep(); Sets the time_mode as fixedstep. This means that what is returned by time() and delta_time() corresponds to an ideal world where there is exactly 1/framerate seconds between each updates. This is ideal when you are exporting a video and don't want the long export time to influence your animation. "},{"title":"run()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#run","content":"run(); Starts the update() loop. update() will be called repeatedly, until you close the window or call exit() "},{"title":"exit()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#exit","content":"exit(); Stops the run() loop. This is the programatic equivalent of a user closing the window. "},{"title":"pause()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#pause","content":"pause(); Pauses the run() loop. No update() will be called, until you call resume(). User inputs are still processed. "},{"title":"resume()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#resume","content":"resume(); Starts the run() loop again if it was paused with pause(). "},{"title":"is_paused()","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#is_paused","content":"is_paused() const; Returns true iff we are currently paused. See pause() and resume(). "},{"title":"update","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#update","content":"std::function&lt; void()&gt; update = []() {}; Copy This function is called repeatedly, once every 1/framerate() seconds (or at least it will try, if your update code is too slow then the next updates will necessarily be delayed). "},{"title":"mouse_moved","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#mouse_moved","content":"std::function&lt; void(MouseMove)&gt; mouse_moved = [](MouseMove) {}; Copy This function is called whenever the mouse is moved. "},{"title":"mouse_dragged","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#mouse_dragged","content":"std::function&lt; void(MouseDrag)&gt; mouse_dragged = [](MouseDrag) {}; Copy This function is called whenever the mouse is dragged. "},{"title":"mouse_pressed","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#mouse_pressed","content":"std::function&lt; void(MouseButton)&gt; mouse_pressed = [](MouseButton) {}; Copy This function is called whenever a mouse button is pressed. "},{"title":"mouse_released","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#mouse_released","content":"std::function&lt; void(MouseButton)&gt; mouse_released = [](MouseButton) {}; Copy This function is called whenever a mouse button is released. "},{"title":"mouse_scrolled","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#mouse_scrolled","content":"std::function&lt; void(MouseScroll)&gt; mouse_scrolled = [](MouseScroll) {}; Copy This function is called whenever the mouse wheel is scrolled. "},{"title":"key_pressed","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#key_pressed","content":"std::function&lt; void(KeyEvent)&gt; key_pressed = [](KeyEvent) {}; Copy This function is called whenever a keyboard key is pressed. "},{"title":"key_released","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#key_released","content":"std::function&lt; void(KeyEvent)&gt; key_released = [](KeyEvent) {}; Copy This function is called whenever a keyboard key is released. "},{"title":"key_repeated","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#key_repeated","content":"std::function&lt; void(KeyEvent)&gt; key_repeated = [](KeyEvent) {}; Copy This function is called repeatedly whenever a keyboard key is held. (NB: this only starts after holding the key for a little while. The axact behaviour is OS-specific) /!\\ This is less than ideal to do things like handling the movement of a character. You should rather do, in your update function: ```cpp if (p6.is_held(PhysicalKey::W)) { // TODO implement is_held and PhysicalKey and LogicalKey character.move_forward(p6.delta_time()); }  ### on_error ```cppstd::function&lt; void(std::string &amp;&amp;)&gt; on_error = [](std::string&amp;&amp; error_message) { throw std::runtime_error{error_message}; }; Copy This function is called whenever an error occurs. "},{"title":"fill","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#fill","content":"Color fill {1.f, 1.f, 1.f, 0.5f}; Copy "},{"title":"stroke","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#stroke","content":"Color stroke {0.f, 0.f, 0.f}; Copy "},{"title":"stroke_weight","type":1,"pageTitle":"p6::Context","url":"reference/Classes/classp6_1_1_context#stroke_weight","content":"float stroke_weight = 0.01f; Copy  Updated on 2022 January 08 "},{"title":"p6::MouseButton","type":0,"sectionRef":"#","url":"reference/Classes/structp6_1_1_mouse_button","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::MouseButton","url":"reference/Classes/structp6_1_1_mouse_button#summary","content":"\tNameglm::vec2\tposition Button\tbutton "},{"title":"Details","type":1,"pageTitle":"p6::MouseButton","url":"reference/Classes/structp6_1_1_mouse_button#details","content":""},{"title":"position","type":1,"pageTitle":"p6::MouseButton","url":"reference/Classes/structp6_1_1_mouse_button#position","content":"glm::vec2 position; Copy "},{"title":"button","type":1,"pageTitle":"p6::MouseButton","url":"reference/Classes/structp6_1_1_mouse_button#button","content":"Button button; Copy  Updated on 2022 January 08 "},{"title":"p6::MouseMove","type":0,"sectionRef":"#","url":"reference/Classes/structp6_1_1_mouse_move","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::MouseMove","url":"reference/Classes/structp6_1_1_mouse_move#summary","content":"\tNameglm::vec2\tposition glm::vec2\tdelta "},{"title":"Details","type":1,"pageTitle":"p6::MouseMove","url":"reference/Classes/structp6_1_1_mouse_move#details","content":""},{"title":"position","type":1,"pageTitle":"p6::MouseMove","url":"reference/Classes/structp6_1_1_mouse_move#position","content":"glm::vec2 position; Copy "},{"title":"delta","type":1,"pageTitle":"p6::MouseMove","url":"reference/Classes/structp6_1_1_mouse_move#delta","content":"glm::vec2 delta; Copy  Updated on 2022 January 08 "},{"title":"p6::MouseDrag","type":0,"sectionRef":"#","url":"reference/Classes/structp6_1_1_mouse_drag","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::MouseDrag","url":"reference/Classes/structp6_1_1_mouse_drag#summary","content":"\tNameglm::vec2\tposition glm::vec2\tdelta glm::vec2\tstart_position "},{"title":"Details","type":1,"pageTitle":"p6::MouseDrag","url":"reference/Classes/structp6_1_1_mouse_drag#details","content":""},{"title":"position","type":1,"pageTitle":"p6::MouseDrag","url":"reference/Classes/structp6_1_1_mouse_drag#position","content":"glm::vec2 position; Copy "},{"title":"delta","type":1,"pageTitle":"p6::MouseDrag","url":"reference/Classes/structp6_1_1_mouse_drag#delta","content":"glm::vec2 delta; Copy "},{"title":"start_position","type":1,"pageTitle":"p6::MouseDrag","url":"reference/Classes/structp6_1_1_mouse_drag#start_position","content":"glm::vec2 start_position; Copy  Updated on 2022 January 08 "},{"title":"p6::RectangleParams","type":0,"sectionRef":"#","url":"reference/Classes/structp6_1_1_rectangle_params","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::RectangleParams","url":"reference/Classes/structp6_1_1_rectangle_params#summary","content":"\tNameglm::vec2\tposition glm::vec2\tsize float\trotation "},{"title":"Details","type":1,"pageTitle":"p6::RectangleParams","url":"reference/Classes/structp6_1_1_rectangle_params#details","content":""},{"title":"position","type":1,"pageTitle":"p6::RectangleParams","url":"reference/Classes/structp6_1_1_rectangle_params#position","content":"glm::vec2 position = glm::vec2{0.f}; Copy "},{"title":"size","type":1,"pageTitle":"p6::RectangleParams","url":"reference/Classes/structp6_1_1_rectangle_params#size","content":"glm::vec2 size = glm::vec2{1.f}; Copy "},{"title":"rotation","type":1,"pageTitle":"p6::RectangleParams","url":"reference/Classes/structp6_1_1_rectangle_params#rotation","content":"float rotation = 0.f; Copy  Updated on 2022 January 08 "},{"title":"p6::MouseScroll","type":0,"sectionRef":"#","url":"reference/Classes/structp6_1_1_mouse_scroll","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::MouseScroll","url":"reference/Classes/structp6_1_1_mouse_scroll#summary","content":"\tNamefloat\tdx float\tdy "},{"title":"Details","type":1,"pageTitle":"p6::MouseScroll","url":"reference/Classes/structp6_1_1_mouse_scroll#details","content":""},{"title":"dx","type":1,"pageTitle":"p6::MouseScroll","url":"reference/Classes/structp6_1_1_mouse_scroll#dx","content":"float dx; Copy "},{"title":"dy","type":1,"pageTitle":"p6::MouseScroll","url":"reference/Classes/structp6_1_1_mouse_scroll#dy","content":"float dy; Copy  Updated on 2022 January 08 "},{"title":"C:/Dev/C++/p6-docs/examples/basic/p6/src","type":0,"sectionRef":"#","url":"reference/Files/dir_a167643325b6457a5b7a77d5d3220d97","content":"C:/Dev/C++/p6-docs/examples/basic/p6/src Updated on 2022 January 08","keywords":""},{"title":"C:/Dev/C++/p6-docs/examples/basic/p6","type":0,"sectionRef":"#","url":"reference/Files/dir_cc74774aba980793e12e526e494a19e2","content":"","keywords":""},{"title":"Directories","type":1,"pageTitle":"C:/Dev/C++/p6-docs/examples/basic/p6","url":"reference/Files/dir_cc74774aba980793e12e526e494a19e2#directories","content":"NameC:/Dev/C++/p6-docs/examples/basic/p6/src  Updated on 2022 January 08 "},{"title":"C:/Dev/C++/p6-docs/examples/basic","type":0,"sectionRef":"#","url":"reference/Files/dir_b73ade9981abab2b39ba77c7bad6ffea","content":"","keywords":""},{"title":"Directories","type":1,"pageTitle":"C:/Dev/C++/p6-docs/examples/basic","url":"reference/Files/dir_b73ade9981abab2b39ba77c7bad6ffea#directories","content":"NameC:/Dev/C++/p6-docs/examples/basic/p6  Updated on 2022 January 08 "},{"title":"C:/Dev/C++/p6-docs/examples","type":0,"sectionRef":"#","url":"reference/Files/dir_d28a4824dc47e487b107a5db32ef43c4","content":"","keywords":""},{"title":"Directories","type":1,"pageTitle":"C:/Dev/C++/p6-docs/examples","url":"reference/Files/dir_d28a4824dc47e487b107a5db32ef43c4#directories","content":"NameC:/Dev/C++/p6-docs/examples/basic  Updated on 2022 January 08 "},{"title":"Classes","type":0,"sectionRef":"#","url":"reference/index_classes","content":"Classes namespace p6 class Color class Context class Image An image can be drawn onto, and can be displayed. struct KeyEvent struct MouseButton struct MouseDrag struct MouseMove struct MouseScroll struct RectangleParams class Shader Updated on 2022 January 08","keywords":""},{"title":"Examples","type":0,"sectionRef":"#","url":"reference/index_examples","content":"Examples Updated on 2022 January 08","keywords":""},{"title":"math.h","type":0,"sectionRef":"#","url":"reference/Files/math_8h","content":"","keywords":""},{"title":"Namespaces","type":1,"pageTitle":"math.h","url":"reference/Files/math_8h#namespaces","content":"Namep6 "},{"title":"Source code","type":1,"pageTitle":"math.h","url":"reference/Files/math_8h#source-code","content":"#pragma once namespace p6 {/* ------------------------------- *//* ------------------------------- */ template&lt;typename T&gt;T map(T x, T from_min, T from_max, T to_min, T to_max){ return (x - from_min) * (to_max - to_min) / (from_max - from_min) + to_min;}} // namespace p6 Copy  Updated on 2022 January 08 "},{"title":"Modules","type":0,"sectionRef":"#","url":"reference/index_groups","content":"Modules group Drawing group Math group Update Flow Updated on 2022 January 08","keywords":""},{"title":"Files","type":0,"sectionRef":"#","url":"reference/index_files","content":"Files dir C:/Dev/C++/p6-docs/examples dir /Dev/C++/p6-docs/examples/basic dir /Dev/C++/p6-docs/examples/basic/p6 dir /Dev/C++/p6-docs/examples/basic/p6/src file math.h Updated on 2022 January 08","keywords":""},{"title":"Namespaces","type":0,"sectionRef":"#","url":"reference/index_namespaces","content":"Namespaces namespace p6 Updated on 2022 January 08","keywords":""},{"title":"Pages","type":0,"sectionRef":"#","url":"reference/index_pages","content":"Pages page Shader Updated on 2022 January 08","keywords":""},{"title":"Drawing","type":0,"sectionRef":"#","url":"reference/Modules/group__drawing","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"Drawing","url":"reference/Modules/group__drawing#functions","content":"\tNamevoid\tbackground(Color color) const Sets the color and alpha of each pixel of the canvas. void\trectangle(RectangleParams params) const Draws a rectangle. void\tellipse(RectangleParams params) const Draws an ellipse. void\timage(const Image &amp; img, RectangleParams params) const Draws an image. "},{"title":"Attributes","type":1,"pageTitle":"Drawing","url":"reference/Modules/group__drawing#attributes","content":"\tNameColor\tfill Color\tstroke float\tstroke_weight "},{"title":"Functions Documentation","type":1,"pageTitle":"Drawing","url":"reference/Modules/group__drawing#functions-documentation","content":""},{"title":"background()","type":1,"pageTitle":"Drawing","url":"reference/Modules/group__drawing#background","content":"background(Color color) const; Sets the color and alpha of each pixel of the canvas. NB: No blending is applied ; even if you specify an alpha of 0.5 the old canvas is completely erased. This means that setting an alpha here doesn't matter much. It is only meaningful if you export the canvas as a png, or if you try to blend the canvas on top of another image. "},{"title":"rectangle()","type":1,"pageTitle":"Drawing","url":"reference/Modules/group__drawing#rectangle","content":"rectangle(RectangleParams params) const; Draws a rectangle. Parameters: params Shape of the rect p6.fill = {0.f, 0.8f, 0.3f};p6.rectangle({}); Copy "},{"title":"ellipse()","type":1,"pageTitle":"Drawing","url":"reference/Modules/group__drawing#ellipse","content":"ellipse(RectangleParams params) const; Draws an ellipse. "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/Modules/group__drawing#image","content":"image(const Image &amp; img, RectangleParams params) const; Draws an image. "},{"title":"Attributes Documentation","type":1,"pageTitle":"Drawing","url":"reference/Modules/group__drawing#attributes-documentation","content":""},{"title":"fill","type":1,"pageTitle":"Drawing","url":"reference/Modules/group__drawing#fill","content":"Color fill {1.f, 1.f, 1.f, 0.5f}; Copy "},{"title":"stroke","type":1,"pageTitle":"Drawing","url":"reference/Modules/group__drawing#stroke","content":"Color stroke {0.f, 0.f, 0.f}; Copy "},{"title":"stroke_weight","type":1,"pageTitle":"Drawing","url":"reference/Modules/group__drawing#stroke_weight","content":"float stroke_weight = 0.01f; Copy  Updated on 2022 January 08 "},{"title":"Math","type":0,"sectionRef":"#","url":"reference/Modules/group__math","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"Math","url":"reference/Modules/group__math#functions","content":"\tNametemplate &lt;typename T &gt; T\tmap(T x, T from_min, T from_max, T to_min, T to_max) Maps x, which is in the range [from_mix, from_max], to the range [to_min, to_max]. "},{"title":"Functions Documentation","type":1,"pageTitle":"Math","url":"reference/Modules/group__math#functions-documentation","content":""},{"title":"map()","type":1,"pageTitle":"Math","url":"reference/Modules/group__math#map","content":"map(T x, T from_min, T from_max, T to_min, T to_max); Maps x, which is in the range [from_mix, from_max], to the range [to_min, to_max]. For example if x == from_min, then the function returns to_min if x == (from_min + from_max) / 2 then the function returns (to_min + to_max) / 2 if x is outside of the range [from_min, from_max] the result will be outside of [to_min, to_max], the same linear behaviour still applies  Updated on 2022 January 08 "},{"title":"Update Flow","type":0,"sectionRef":"#","url":"reference/Modules/group__update-flow","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"Update Flow","url":"reference/Modules/group__update-flow#functions","content":"\tNamevoid\trun() Starts the update() loop. void\texit() Stops the run() loop. void\tpause() Pauses the run() loop. void\tresume() Starts the run() loop again if it was paused with pause(). bool\tis_paused() const Returns true iff we are currently paused. See pause() and resume(). "},{"title":"Functions Documentation","type":1,"pageTitle":"Update Flow","url":"reference/Modules/group__update-flow#functions-documentation","content":""},{"title":"run()","type":1,"pageTitle":"Update Flow","url":"reference/Modules/group__update-flow#run","content":"run(); Starts the update() loop. update() will be called repeatedly, until you close the window or call exit() "},{"title":"exit()","type":1,"pageTitle":"Update Flow","url":"reference/Modules/group__update-flow#exit","content":"exit(); Stops the run() loop. This is the programatic equivalent of a user closing the window. "},{"title":"pause()","type":1,"pageTitle":"Update Flow","url":"reference/Modules/group__update-flow#pause","content":"pause(); Pauses the run() loop. No update() will be called, until you call resume(). User inputs are still processed. "},{"title":"resume()","type":1,"pageTitle":"Update Flow","url":"reference/Modules/group__update-flow#resume","content":"resume(); Starts the run() loop again if it was paused with pause(). "},{"title":"is_paused()","type":1,"pageTitle":"Update Flow","url":"reference/Modules/group__update-flow#is_paused","content":"is_paused() const; Returns true iff we are currently paused. See pause() and resume().  Updated on 2022 January 08 "},{"title":"Shader","type":0,"sectionRef":"#","url":"reference/Pages/md__c___dev__c___p6_docs_examples_basic_p6_src___r_e_a_d_m_e","content":"","keywords":""},{"title":"set()","type":1,"pageTitle":"Shader","url":"reference/Pages/md__c___dev__c___p6_docs_examples_basic_p6_src___r_e_a_d_m_e#set","content":"We declare all the possible signatures instead of using a template because it makes the API clearer and avoids ugly template errors if an invalid type is passed in. The template is only used internally to avoid code duplication.  Updated on 2022 January 08 "},{"title":"p6","type":0,"sectionRef":"#","url":"reference/Namespaces/namespacep6","content":"","keywords":""},{"title":"Classes","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#classes","content":"\tNameclass\tp6::Color class\tp6::Context class\tp6::Image An image can be drawn onto, and can be displayed. struct\tp6::KeyEvent struct\tp6::MouseButton struct\tp6::MouseDrag struct\tp6::MouseMove struct\tp6::MouseScroll struct\tp6::RectangleParams class\tp6::Shader "},{"title":"Types","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#types","content":"\tNameenum class\tButton { Left, Right, Middle} using glpp::ImageSize\tImageSize using glpp::Texture\tTexture "},{"title":"Functions","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#functions","content":"\tNameContext &amp;\tget_context(GLFWwindow * window) void\twindow_size_callback(GLFWwindow * window, int width, int height) void\tmouse_button_callback(GLFWwindow * window, int button, int action, int mods) void\tscroll_callback(GLFWwindow * window, double x, double y) void\tkey_callback(GLFWwindow * window, int key, int scancode, int action, int mods) Image\tload_image(const char * file_path) template &lt;typename T &gt; T\tmap(T x, T from_min, T from_max, T to_min, T to_max) Maps x, which is in the range [from_mix, from_max], to the range [to_min, to_max]. void\tlink_program(const glpp::ext::Program &amp; program, const glpp::VertexShader &amp; vertex_shader, const glpp::FragmentShader &amp; fragment_shader) template &lt;typename T &gt; void\tset_uniform(const glpp::ext::Program &amp; program, const std::string &amp; uniform_name, T &amp;&amp; v) "},{"title":"Types Documentation","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#types-documentation","content":""},{"title":"Button","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#button","content":"Enumerator\tValue\tDescriptionLeft Right Middle  "},{"title":"ImageSize","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#imagesize","content":"using p6::ImageSize = typedef glpp::ImageSize; Copy "},{"title":"Texture","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#texture","content":"using p6::Texture = typedef glpp::Texture; Copy "},{"title":"Functions Documentation","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#functions-documentation","content":""},{"title":"get_context()","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#get_context","content":"get_context(GLFWwindow * window); "},{"title":"window_size_callback()","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#window_size_callback","content":"window_size_callback(GLFWwindow * window, int width, int height); "},{"title":"mouse_button_callback()","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#mouse_button_callback","content":"mouse_button_callback(GLFWwindow * window, int button, int action, int mods); "},{"title":"scroll_callback()","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#scroll_callback","content":"scroll_callback(GLFWwindow * window, double x, double y); "},{"title":"key_callback()","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#key_callback","content":"key_callback(GLFWwindow * window, int key, int scancode, int action, int mods); "},{"title":"load_image()","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#load_image","content":"load_image(const char * file_path); "},{"title":"map()","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#map","content":"map(T x, T from_min, T from_max, T to_min, T to_max); Maps x, which is in the range [from_mix, from_max], to the range [to_min, to_max]. For example if x == from_min, then the function returns to_min if x == (from_min + from_max) / 2 then the function returns (to_min + to_max) / 2 if x is outside of the range [from_min, from_max] the result will be outside of [to_min, to_max], the same linear behaviour still applies "},{"title":"link_program()","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#link_program","content":"link_program(const glpp::ext::Program &amp; program, const glpp::VertexShader &amp; vertex_shader, const glpp::FragmentShader &amp; fragment_shader); "},{"title":"set_uniform()","type":1,"pageTitle":"p6","url":"reference/Namespaces/namespacep6#set_uniform","content":"set_uniform(const glpp::ext::Program &amp; program, const std::string &amp; uniform_name, T &amp;&amp; v);  Updated on 2022 January 08 "},{"title":"Introduction","type":0,"sectionRef":"#","url":"tutorials","content":"Introduction","keywords":""}]