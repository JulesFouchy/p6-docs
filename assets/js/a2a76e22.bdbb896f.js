"use strict";(self.webpackChunkp6_docs=self.webpackChunkp6_docs||[]).push([[2877],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return f}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),p=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=p(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=p(n),f=o,m=d["".concat(c,".").concat(f)]||d[f]||u[f]||a;return n?r.createElement(m,i(i({ref:t},s),{},{components:n})):r.createElement(m,i({ref:t},s))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var p=2;p<a;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4722:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return p},toc:function(){return s},default:function(){return d}});var r=n(2122),o=n(9756),a=(n(7294),n(3905)),i=["components"],l={title:"Drawing"},c=void 0,p={unversionedId:"tutorials/drawing",id:"tutorials/drawing",isDocsHomePage:!1,title:"Drawing",description:"You can use these functions on the Context at any time, even outside of the update function.",source:"@site/docs/tutorials/04-drawing.md",sourceDirName:"tutorials",slug:"/tutorials/drawing",permalink:"/p6-docs/tutorials/drawing",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Drawing"},sidebar:"tutorials",previous:{title:"The coordinate system",permalink:"/p6-docs/tutorials/the-coordinate-system"},next:{title:"Images",permalink:"/p6-docs/tutorials/images"}},s=[{value:"<code>background()</code>",id:"background",children:[]},{value:"Shapes",id:"shapes",children:[]},{value:"Colors",id:"colors",children:[]},{value:"Line",id:"line",children:[]}],u={toc:s};function d(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"You can use these functions on the ",(0,a.kt)("inlineCode",{parentName:"p"},"Context")," at any time, even outside of the ",(0,a.kt)("inlineCode",{parentName:"p"},"update")," function."),(0,a.kt)("h2",{id:"background"},(0,a.kt)("inlineCode",{parentName:"h2"},"background()")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"background()")," clears the whole canvas with one solid color. It is very useful if you want to do animations and don't want the drawings of the previous frames to remain on your canvas.",(0,a.kt)("br",null),"\nOn the other hand not using ",(0,a.kt)("inlineCode",{parentName:"p"},"background()")," can give you very cool effects."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"ctx.update = [&]() {\n    ctx.background({0.2f, 0.1f, 0.3f}); // Comment out this line for an interesting effect\n    ctx.circle(p6::Center{ctx.mouse()}, p6::Radius{0.3f});\n};\n")),(0,a.kt)("p",null,"And if you want your drawings to slowly fade away, draw a partially transparent rectangle instead of using ",(0,a.kt)("inlineCode",{parentName:"p"},"background()"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"ctx.update = [&]() {\n    // Clear the background with a fading effect\n    ctx.use_stroke = false;\n    ctx.fill       = {0.2f, 0.1f, 0.3f, 0.1f};\n    ctx.rectangle(p6::FullScreen{});\n    // Draw something\n    ctx.fill = {1.f, 0.7f, 0.2f};\n    ctx.circle(p6::Center{ctx.mouse()}, p6::Radius{0.3f});\n};\n")),(0,a.kt)("h2",{id:"shapes"},"Shapes"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"circle()"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"ellipse()"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"square()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"rectangle()")," have many overloads. Go to ",(0,a.kt)("a",{parentName:"p",href:"../reference/drawing"},"the reference")," to learn all about them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <p6/p6.h>\n\nint main()\n{\n    auto      ctx      = p6::Context{};\n    p6::Angle rotation = 0.011_turn;\n    ctx.mouse_scrolled = [&](p6::MouseScroll e) {\n        rotation += e.dy * 0.025_turn;\n    };\n    ctx.update = [&]() {\n        ctx.background({});\n        ctx.stroke = {1, 1, 1, 1};\n        // White square positioned by Center\n        ctx.square(p6::Center{ctx.mouse()},\n                   p6::Radius{0.3f},\n                   p6::Rotation{rotation});\n        // Red square positioned by Top Left Corner\n        ctx.fill = {1, 0, 0, 0.5};\n        ctx.square(p6::TopLeftCorner{ctx.mouse()},\n                   p6::Radius{0.3f},\n                   p6::Rotation{rotation});\n        // Green square positioned by Top Right Corner\n        ctx.fill = {0, 1, 0, 0.5};\n        ctx.square(p6::TopRightCorner{ctx.mouse()},\n                   p6::Radius{0.3f},\n                   p6::Rotation{rotation});\n        // Blue square positioned by Bottom Left Corner\n        ctx.fill = {0, 0, 1, 0.5};\n        ctx.square(p6::BottomLeftCorner{ctx.mouse()},\n                   p6::Radius{0.3f},\n                   p6::Rotation{rotation});\n        // Cyan square positioned by Bottom Right Corner\n        ctx.fill = {0, 1, 1, 0.5};\n        ctx.square(p6::BottomRightCorner{ctx.mouse()},\n                   p6::Radius{0.3f},\n                   p6::Rotation{rotation});\n    };\n    ctx.start();\n}\n")),(0,a.kt)("h2",{id:"colors"},"Colors"),(0,a.kt)("p",null,"Colors are expressed as RGBA, with each value going from 0.0 to 1.0:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"p6::Color color{1.f, 0.7f, 0.2f}; // A nice orange.\n                                  // If you don't specify the fourth value (alpha, the opacity) it will be defaulted to 1.0\n")),(0,a.kt)("p",null,"Shapes have two colors: the ",(0,a.kt)("inlineCode",{parentName:"p"},"fill")," and the ",(0,a.kt)("inlineCode",{parentName:"p"},"stroke"),"."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"fill"),' controls the "main" color of the shape'),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"stroke")," adds a second color on the edges of the shape. The size of that edge is controlled by ",(0,a.kt)("inlineCode",{parentName:"li"},"stroke_weight"),".")),(0,a.kt)("p",null,"Both the fill and the stroke can be disabled with ",(0,a.kt)("inlineCode",{parentName:"p"},"ctx.use_fill = false;")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ctx.use_stroke = false;"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <p6/p6.h>\n\nint main()\n{\n    auto ctx          = p6::Context{};\n    ctx.fill          = {1, 1, 1}; // White\n    ctx.stroke        = {0, 0, 0}; // Black\n    ctx.stroke_weight = 0.1f;\n    ctx.background({0, 1, 1}); // Cyan\n\n    ctx.use_fill   = true;\n    ctx.use_stroke = true;\n    ctx.circle(p6::Center{-0.5f, 0.5f}, p6::Radius{0.5f});\n    ctx.use_fill   = false;\n    ctx.use_stroke = true;\n    ctx.circle(p6::Center{0.5f, 0.5f}, p6::Radius{0.5f});\n    ctx.use_fill   = true;\n    ctx.use_stroke = false;\n    ctx.circle(p6::Center{-0.5f, -0.5f}, p6::Radius{0.5f});\n\n    ctx.start();\n}\n")),(0,a.kt)("h2",{id:"line"},"Line"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"../reference/drawing#line"},(0,a.kt)("inlineCode",{parentName:"a"},"ctx.line()"))," is a bit of a special shape: it has only one color which is the ",(0,a.kt)("inlineCode",{parentName:"p"},"stroke")," color, and its thickness is controlled by ",(0,a.kt)("inlineCode",{parentName:"p"},"stroke_weight"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <p6/p6.h>\n\nint main()\n{\n    auto ctx   = p6::Context{};\n    ctx.update = [&]() {\n        ctx.background({});\n        ctx.stroke        = p6::Color{1.f, 1.f, 1.f, 0.75f};\n        ctx.stroke_weight = 0.1f;\n        ctx.line(glm::vec2{0.f}, ctx.mouse());\n    };\n    ctx.start();\n}\n")))}d.isMDXComponent=!0}}]);