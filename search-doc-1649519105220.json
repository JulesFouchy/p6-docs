[{"title":"Examples","type":0,"sectionRef":"#","url":"examples","content":"Examples To see examples of how to use p6 check out our examples and our tests.","keywords":""},{"title":"Summary","type":0,"sectionRef":"#","url":"reference","content":"Summary Welcome to the reference! In here you can find all the details about everything that is available in p6. Section Canvas You can either draw directly to the screen (the default) or onto a Canvas. Section Drawing Draw shapes and control the look of them. Section Events You can set those functions as you wish to react to various events. Section Image Load and query information about images. Section Input Query the state of the mouse and keyboard. Section Math Mathematical functions and numerical constants. Section Text Write text to the screen. Section Time Query time information and control how it elapses. Section Update Flow Control the update() loop and query information about it. Section Window Query the state of the window and control it.","keywords":""},{"title":"Canvas","type":0,"sectionRef":"#","url":"reference/canvas","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"Canvas","url":"reference/canvas#summary","content":""},{"title":"Classes","type":1,"pageTitle":"Canvas","url":"reference/canvas#classes","content":"\tNameclass\tp6::Canvas A canvas is an image that can be drawn onto. "},{"title":"Functions","type":1,"pageTitle":"Canvas","url":"reference/canvas#functions","content":"\tNamevoid\trender_to_canvas(Canvas &amp; canvas) Sets the canvas where all the drawing commands will happen on. void\trender_to_screen() Reset the Context to render to the screen. "},{"title":"Functions","type":1,"pageTitle":"Canvas","url":"reference/canvas#functions-1","content":""},{"title":"render_to_canvas()","type":1,"pageTitle":"Canvas","url":"reference/canvas#render_to_canvas","content":"void render_to_canvas(Canvas &amp; canvas); Sets the canvas where all the drawing commands will happen on. "},{"title":"render_to_screen()","type":1,"pageTitle":"Canvas","url":"reference/canvas#render_to_screen","content":"void render_to_screen(); Reset the Context to render to the screen.  Updated on 2022 April 09 "},{"title":"Events","type":0,"sectionRef":"#","url":"reference/events","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"Events","url":"reference/events#summary","content":""},{"title":"Attributes","type":1,"pageTitle":"Events","url":"reference/events#attributes","content":"\tNamestd::function&lt; void()&gt;\tupdate This function is called repeatedly. The framerate will be capped at your monitors refresh rate (60 frames per second on a typical monitor). std::function&lt; void()&gt;\timgui In this function you can render all the ImGui windows you want. std::function&lt; void(MouseMove)&gt;\tmouse_moved This function is called whenever the mouse is moved. std::function&lt; void(MouseDrag)&gt;\tmouse_dragged This function is called whenever the mouse is dragged. std::function&lt; void(MouseButton)&gt;\tmouse_pressed This function is called whenever a mouse button is pressed. std::function&lt; void(MouseButton)&gt;\tmouse_released This function is called whenever a mouse button is released. std::function&lt; void(MouseScroll)&gt;\tmouse_scrolled This function is called whenever the mouse wheel is scrolled. std::function&lt; void(Key)&gt;\tkey_pressed This function is called whenever a keyboard key is pressed. std::function&lt; void(Key)&gt;\tkey_released This function is called whenever a keyboard key is released. std::function&lt; void(Key)&gt;\tkey_repeated This function is called repeatedly whenever a keyboard key is held. std::function&lt; void(std::string &amp;&amp;)&gt;\ton_error This function is called whenever an error occurs. std::function&lt; void()&gt;\tframebuffer_resized This function is called whenever the framebuffer is resized. "},{"title":"Detailed Description","type":1,"pageTitle":"Events","url":"reference/events#detailed-description","content":"You can set those functions as you wish to react to various events. The simplest way is to use a lambda: auto ctx = p6::Context{};ctx.mouse_pressed = [](p6::MouseButton) { std::cout &lt;&lt; &quot;Hello World\\n&quot;;}; Copy "},{"title":"Attributes","type":1,"pageTitle":"Events","url":"reference/events#attributes-1","content":""},{"title":"update","type":1,"pageTitle":"Events","url":"reference/events#update","content":"std::function&lt; void()&gt; update = []() { }; Copy This function is called repeatedly. The framerate will be capped at your monitors refresh rate (60 frames per second on a typical monitor). "},{"title":"imgui","type":1,"pageTitle":"Events","url":"reference/events#imgui","content":"std::function&lt; void()&gt; imgui = []() { }; Copy In this function you can render all the ImGui windows you want. "},{"title":"mouse_moved","type":1,"pageTitle":"Events","url":"reference/events#mouse_moved","content":"std::function&lt; void(MouseMove)&gt; mouse_moved = [](MouseMove) { }; Copy This function is called whenever the mouse is moved. "},{"title":"mouse_dragged","type":1,"pageTitle":"Events","url":"reference/events#mouse_dragged","content":"std::function&lt; void(MouseDrag)&gt; mouse_dragged = [](MouseDrag) { }; Copy This function is called whenever the mouse is dragged. "},{"title":"mouse_pressed","type":1,"pageTitle":"Events","url":"reference/events#mouse_pressed","content":"std::function&lt; void(MouseButton)&gt; mouse_pressed = [](MouseButton) { }; Copy This function is called whenever a mouse button is pressed. "},{"title":"mouse_released","type":1,"pageTitle":"Events","url":"reference/events#mouse_released","content":"std::function&lt; void(MouseButton)&gt; mouse_released = [](MouseButton) { }; Copy This function is called whenever a mouse button is released. "},{"title":"mouse_scrolled","type":1,"pageTitle":"Events","url":"reference/events#mouse_scrolled","content":"std::function&lt; void(MouseScroll)&gt; mouse_scrolled = [](MouseScroll) { }; Copy This function is called whenever the mouse wheel is scrolled. "},{"title":"key_pressed","type":1,"pageTitle":"Events","url":"reference/events#key_pressed","content":"std::function&lt; void(Key)&gt; key_pressed = [](Key) { }; Copy This function is called whenever a keyboard key is pressed. "},{"title":"key_released","type":1,"pageTitle":"Events","url":"reference/events#key_released","content":"std::function&lt; void(Key)&gt; key_released = [](Key) { }; Copy This function is called whenever a keyboard key is released. "},{"title":"key_repeated","type":1,"pageTitle":"Events","url":"reference/events#key_repeated","content":"std::function&lt; void(Key)&gt; key_repeated = [](Key) { }; Copy This function is called repeatedly whenever a keyboard key is held. (NB: this only starts after holding the key for a little while. The axact behaviour is OS-specific) ⚠️ This is less than ideal to do things like handling the movement of a character. You should rather do, in your update function: if (p6.is_held(PhysicalKey::W)) { // TODO implement is_held and PhysicalKey and LogicalKey character.move_forward(p6.delta_time());} Copy "},{"title":"on_error","type":1,"pageTitle":"Events","url":"reference/events#on_error","content":"std::function&lt; void(std::string &amp;&amp;)&gt; on_error = [](std::string&amp;&amp; error_message) { throw std::runtime_error{error_message}; }; Copy This function is called whenever an error occurs. "},{"title":"framebuffer_resized","type":1,"pageTitle":"Events","url":"reference/events#framebuffer_resized","content":"std::function&lt; void()&gt; framebuffer_resized = []() { }; Copy This function is called whenever the framebuffer is resized. If you call framebuffer_size(), framebuffer_width(), framebuffer_height() or aspect_ratio() inside framebuffer_resized() they will already be referring to the new size.  Updated on 2022 April 09 "},{"title":"Image","type":0,"sectionRef":"#","url":"reference/image","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"Image","url":"reference/image#summary","content":""},{"title":"Classes","type":1,"pageTitle":"Image","url":"reference/image#classes","content":"\tNameclass\tp6::Image "},{"title":"Functions","type":1,"pageTitle":"Image","url":"reference/image#functions","content":"\tNameImage\tload_image(const char * file_path) Loads an image from a file. "},{"title":"Functions","type":1,"pageTitle":"Image","url":"reference/image#functions-1","content":""},{"title":"load_image()","type":1,"pageTitle":"Image","url":"reference/image#load_image","content":"Image load_image(const char * file_path); Loads an image from a file. Throws a std::runtime_error if the file doesn't exist or isn't a valid image file.  Updated on 2022 April 09 "},{"title":"Input","type":0,"sectionRef":"#","url":"reference/input","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"Input","url":"reference/input#summary","content":""},{"title":"Functions","type":1,"pageTitle":"Input","url":"reference/input#functions","content":"\tNameglm::vec2\tmouse() const Returns the current mouse position. glm::vec2\tmouse_delta() const Returns the movement of the mouse since last update(). bool\tmouse_is_in_window() const Returns true iff the window is focused and the coordinates returned by mouse() correspond to a position inside the window. bool\tctrl() const Returns true iff the CTRL key is pressed (or CMD on Mac) bool\tshift() const Returns true iff the SHIFT key is pressed. bool\talt() const Returns true iff the ALT key is pressed. "},{"title":"Functions","type":1,"pageTitle":"Input","url":"reference/input#functions-1","content":""},{"title":"mouse()","type":1,"pageTitle":"Input","url":"reference/input#mouse","content":"glm::vec2 mouse() const; Returns the current mouse position. "},{"title":"mouse_delta()","type":1,"pageTitle":"Input","url":"reference/input#mouse_delta","content":"glm::vec2 mouse_delta() const; Returns the movement of the mouse since last update(). "},{"title":"mouse_is_in_window()","type":1,"pageTitle":"Input","url":"reference/input#mouse_is_in_window","content":"bool mouse_is_in_window() const; Returns true iff the window is focused and the coordinates returned by mouse() correspond to a position inside the window. "},{"title":"ctrl()","type":1,"pageTitle":"Input","url":"reference/input#ctrl","content":"bool ctrl() const; Returns true iff the CTRL key is pressed (or CMD on Mac) "},{"title":"shift()","type":1,"pageTitle":"Input","url":"reference/input#shift","content":"bool shift() const; Returns true iff the SHIFT key is pressed. "},{"title":"alt()","type":1,"pageTitle":"Input","url":"reference/input#alt","content":"bool alt() const; Returns true iff the ALT key is pressed.  Updated on 2022 April 09 "},{"title":"Math","type":0,"sectionRef":"#","url":"reference/math","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"Math","url":"reference/math#summary","content":""},{"title":"Functions","type":1,"pageTitle":"Math","url":"reference/math#functions","content":"\tNametemplate &lt;typename T &gt; T\tmap(T x, T from_min, T from_max, T to_min, T to_max) Maps x, which is in the range [from_mix, from_max] to the range [to_min, to_max]. glm::vec2\trotated_by(Angle angle, glm::vec2 vector) Returns a new vector equal to vector rotated by angle "},{"title":"Attributes","type":1,"pageTitle":"Math","url":"reference/math#attributes","content":"\tNameconstexpr float\tTAU constexpr float\tPI "},{"title":"Functions","type":1,"pageTitle":"Math","url":"reference/math#functions-1","content":""},{"title":"map()","type":1,"pageTitle":"Math","url":"reference/math#map","content":"T map(T x, T from_min, T from_max, T to_min, T to_max); Maps x, which is in the range [from_mix, from_max] to the range [to_min, to_max]. For example if x == from_min then the function returns to_min. If x == (from_min + from_max) / 2 then the function returns (to_min + to_max) / 2. If x is outside of the range [from_min, from_max] the result will be outside of [to_min, to_max], the same linear behaviour still applies. "},{"title":"rotated_by()","type":1,"pageTitle":"Math","url":"reference/math#rotated_by","content":"glm::vec2 rotated_by(Angle angle, glm::vec2 vector); Returns a new vector equal to vector rotated by angle "},{"title":"Attributes","type":1,"pageTitle":"Math","url":"reference/math#attributes-1","content":""},{"title":"TAU","type":1,"pageTitle":"Math","url":"reference/math#tau","content":"static constexpr float TAU = 6.2831853f; Copy "},{"title":"PI","type":1,"pageTitle":"Math","url":"reference/math#pi","content":"static constexpr float PI = TAU / 2.f; Copy  Updated on 2022 April 09 "},{"title":"Drawing","type":0,"sectionRef":"#","url":"reference/drawing","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"Drawing","url":"reference/drawing#summary","content":""},{"title":"Functions","type":1,"pageTitle":"Drawing","url":"reference/drawing#functions","content":"\tNamevoid\tbackground(Color color) Sets the color and alpha of each pixel of the canvas. void\tsquare(FullScreen ) Draws a square. void\tsquare(Center center = {}, Radius radius = {}, Rotation rotation = {}) void\tsquare(TopLeftCorner corner, Radius radius = {}, Rotation rotation = {}) void\tsquare(TopRightCorner corner, Radius radius = {}, Rotation rotation = {}) void\tsquare(BottomLeftCorner corner, Radius radius = {}, Rotation rotation = {}) void\tsquare(BottomRightCorner corner, Radius radius = {}, Rotation rotation = {}) void\trectangle(FullScreen = {}) Draws a rectangle. void\trectangle(Center center, Radii radii = {}, Rotation rotation = {}) void\trectangle(TopLeftCorner corner, Radii radii = {}, Rotation rotation = {}) void\trectangle(TopRightCorner corner, Radii radii = {}, Rotation rotation = {}) void\trectangle(BottomLeftCorner corner, Radii radii = {}, Rotation rotation = {}) void\trectangle(BottomRightCorner corner, Radii radii = {}, Rotation rotation = {}) void\trectangle(Transform2D transform) void\tcircle(FullScreen ) Draws a circle. void\tcircle(Center center = {}, Radius radius = {}) void\tellipse(FullScreen = {}) Draws an ellipse. void\tellipse(Center center, Radii radii = {}, Rotation rotation = {}) void\tellipse(Transform2D transform) void\timage(const ImageOrCanvas &amp; img, Center center, RadiusX radiusX = {}, Rotation rotation = {}) Draws an image. This will respect the aspect ratio of the image. void\timage(const ImageOrCanvas &amp; img, TopLeftCorner corner, RadiusX radiusX = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, TopRightCorner corner, RadiusX radiusX = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, BottomLeftCorner corner, RadiusX radiusX = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, BottomRightCorner corner, RadiusX radiusX = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, Center center, RadiusY radiusY = {}, Rotation rotation = {}) Draws an image. This will respect the aspect ratio of the image. void\timage(const ImageOrCanvas &amp; img, TopLeftCorner corner, RadiusY radiusY = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, TopRightCorner corner, RadiusY radiusY = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, BottomLeftCorner corner, RadiusY radiusY = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, BottomRightCorner corner, RadiusY radiusY = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, FitX ) Draws an image as big as possible on the screen. This will respect the aspect ratio of the image. void\timage(const ImageOrCanvas &amp; img, FitY = {}) void\timage(const ImageOrCanvas &amp; img, FullScreen ) Draws an image that takes the entire window. ⚠️ This might distort the image if the window doesn't have the same aspect ratio as the image. void\timage(const ImageOrCanvas &amp; img, Center center, Radii radii = {}, Rotation rotation = {}) Draws an image. ⚠️ This might distort the image if radii doesn't have the same aspect ratio as the image. void\timage(const ImageOrCanvas &amp; img, TopLeftCorner corner, Radii radii = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, TopRightCorner corner, Radii radii = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, BottomLeftCorner corner, Radii radii = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, BottomRightCorner corner, Radii radii = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, Transform2D transform) void\trectangle_with_shader(const Shader &amp; shader, FullScreen = {}) Draws a rectangle using a custom fragment shader. void\trectangle_with_shader(const Shader &amp; shader, Center center, Radii radii = {}, Rotation rotation = {}) void\trectangle_with_shader(const Shader &amp; shader, TopLeftCorner corner, Radii radii = {}, Rotation rotation = {}) void\trectangle_with_shader(const Shader &amp; shader, TopRightCorner corner, Radii radii = {}, Rotation rotation = {}) void\trectangle_with_shader(const Shader &amp; shader, BottomLeftCorner corner, Radii radii = {}, Rotation rotation = {}) void\trectangle_with_shader(const Shader &amp; shader, BottomRightCorner corner, Radii radii = {}, Rotation rotation = {}) void\tsquare_with_shader(const Shader &amp; shader, Center center = {}, Radius radius = {}, Rotation rotation = {}) void\tsquare_with_shader(const Shader &amp; shader, TopLeftCorner corner, Radius radius = {}, Rotation rotation = {}) void\tsquare_with_shader(const Shader &amp; shader, TopRightCorner corner, Radius radius = {}, Rotation rotation = {}) void\tsquare_with_shader(const Shader &amp; shader, BottomLeftCorner corner, Radius radius = {}, Rotation rotation = {}) void\tsquare_with_shader(const Shader &amp; shader, BottomRightCorner corner, Radius radius = {}, Rotation rotation = {}) void\trectangle_with_shader(const Shader &amp; shader, Transform2D transform) void\tline(glm::vec2 start, glm::vec2 end) Draws a line between two points. "},{"title":"Attributes","type":1,"pageTitle":"Drawing","url":"reference/drawing#attributes","content":"\tNameColor\tfill The color that is used for the interior of the shapes. bool\tuse_fill Whether the shapes will have an interior. Color\tstroke The color that is used for the boundary of the shapes. float\tstroke_weight The size of the boundary of the shapes. bool\tuse_stroke Whether there will be a boundary on the shape. "},{"title":"Functions","type":1,"pageTitle":"Drawing","url":"reference/drawing#functions-1","content":""},{"title":"background()","type":1,"pageTitle":"Drawing","url":"reference/drawing#background","content":"void background(Color color); Sets the color and alpha of each pixel of the canvas. NB: No blending is applied; even if you specify an alpha of 0.5 the old canvas is completely erased. This means that setting an alpha here doesn't matter much. It is only meaningful if you export the canvas as a png, or if you later try to blend the canvas on top of another image. "},{"title":"square()","type":1,"pageTitle":"Drawing","url":"reference/drawing#square","content":"void square(FullScreen ); Draws a square. "},{"title":"square()","type":1,"pageTitle":"Drawing","url":"reference/drawing#square-1","content":"void square(Center center ={}, Radius radius ={}, Rotation rotation ={}); "},{"title":"square()","type":1,"pageTitle":"Drawing","url":"reference/drawing#square-2","content":"void square(TopLeftCorner corner, Radius radius ={}, Rotation rotation ={}); "},{"title":"square()","type":1,"pageTitle":"Drawing","url":"reference/drawing#square-3","content":"void square(TopRightCorner corner, Radius radius ={}, Rotation rotation ={}); "},{"title":"square()","type":1,"pageTitle":"Drawing","url":"reference/drawing#square-4","content":"void square(BottomLeftCorner corner, Radius radius ={}, Rotation rotation ={}); "},{"title":"square()","type":1,"pageTitle":"Drawing","url":"reference/drawing#square-5","content":"void square(BottomRightCorner corner, Radius radius ={}, Rotation rotation ={}); "},{"title":"rectangle()","type":1,"pageTitle":"Drawing","url":"reference/drawing#rectangle","content":"void rectangle(FullScreen ={}); Draws a rectangle. "},{"title":"rectangle()","type":1,"pageTitle":"Drawing","url":"reference/drawing#rectangle-1","content":"void rectangle(Center center, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle()","type":1,"pageTitle":"Drawing","url":"reference/drawing#rectangle-2","content":"void rectangle(TopLeftCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle()","type":1,"pageTitle":"Drawing","url":"reference/drawing#rectangle-3","content":"void rectangle(TopRightCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle()","type":1,"pageTitle":"Drawing","url":"reference/drawing#rectangle-4","content":"void rectangle(BottomLeftCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle()","type":1,"pageTitle":"Drawing","url":"reference/drawing#rectangle-5","content":"void rectangle(BottomRightCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle()","type":1,"pageTitle":"Drawing","url":"reference/drawing#rectangle-6","content":"void rectangle(Transform2D transform); "},{"title":"circle()","type":1,"pageTitle":"Drawing","url":"reference/drawing#circle","content":"void circle(FullScreen ); Draws a circle. "},{"title":"circle()","type":1,"pageTitle":"Drawing","url":"reference/drawing#circle-1","content":"void circle(Center center ={}, Radius radius ={}); "},{"title":"ellipse()","type":1,"pageTitle":"Drawing","url":"reference/drawing#ellipse","content":"void ellipse(FullScreen ={}); Draws an ellipse. "},{"title":"ellipse()","type":1,"pageTitle":"Drawing","url":"reference/drawing#ellipse-1","content":"void ellipse(Center center, Radii radii ={}, Rotation rotation ={}); "},{"title":"ellipse()","type":1,"pageTitle":"Drawing","url":"reference/drawing#ellipse-2","content":"void ellipse(Transform2D transform); "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image","content":"void image(const ImageOrCanvas &amp; img, Center center, RadiusX radiusX ={}, Rotation rotation ={}); Draws an image. This will respect the aspect ratio of the image. "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-1","content":"void image(const ImageOrCanvas &amp; img, TopLeftCorner corner, RadiusX radiusX ={}, Rotation rotation ={}); "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-2","content":"void image(const ImageOrCanvas &amp; img, TopRightCorner corner, RadiusX radiusX ={}, Rotation rotation ={}); "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-3","content":"void image(const ImageOrCanvas &amp; img, BottomLeftCorner corner, RadiusX radiusX ={}, Rotation rotation ={}); "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-4","content":"void image(const ImageOrCanvas &amp; img, BottomRightCorner corner, RadiusX radiusX ={}, Rotation rotation ={}); "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-5","content":"void image(const ImageOrCanvas &amp; img, Center center, RadiusY radiusY ={}, Rotation rotation ={}); Draws an image. This will respect the aspect ratio of the image. "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-6","content":"void image(const ImageOrCanvas &amp; img, TopLeftCorner corner, RadiusY radiusY ={}, Rotation rotation ={}); "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-7","content":"void image(const ImageOrCanvas &amp; img, TopRightCorner corner, RadiusY radiusY ={}, Rotation rotation ={}); "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-8","content":"void image(const ImageOrCanvas &amp; img, BottomLeftCorner corner, RadiusY radiusY ={}, Rotation rotation ={}); "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-9","content":"void image(const ImageOrCanvas &amp; img, BottomRightCorner corner, RadiusY radiusY ={}, Rotation rotation ={}); "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-10","content":"void image(const ImageOrCanvas &amp; img, FitX ); Draws an image as big as possible on the screen. This will respect the aspect ratio of the image. "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-11","content":"void image(const ImageOrCanvas &amp; img, FitY ={}); "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-12","content":"void image(const ImageOrCanvas &amp; img, FullScreen ); Draws an image that takes the entire window. ⚠️ This might distort the image if the window doesn't have the same aspect ratio as the image. "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-13","content":"void image(const ImageOrCanvas &amp; img, Center center, Radii radii ={}, Rotation rotation ={}); Draws an image. ⚠️ This might distort the image if radii doesn't have the same aspect ratio as the image. "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-14","content":"void image(const ImageOrCanvas &amp; img, TopLeftCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-15","content":"void image(const ImageOrCanvas &amp; img, TopRightCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-16","content":"void image(const ImageOrCanvas &amp; img, BottomLeftCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-17","content":"void image(const ImageOrCanvas &amp; img, BottomRightCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"image()","type":1,"pageTitle":"Drawing","url":"reference/drawing#image-18","content":"void image(const ImageOrCanvas &amp; img, Transform2D transform); "},{"title":"rectangle_with_shader()","type":1,"pageTitle":"Drawing","url":"reference/drawing#rectangle_with_shader","content":"void rectangle_with_shader(const Shader &amp; shader, FullScreen ={}); Draws a rectangle using a custom fragment shader. "},{"title":"rectangle_with_shader()","type":1,"pageTitle":"Drawing","url":"reference/drawing#rectangle_with_shader-1","content":"void rectangle_with_shader(const Shader &amp; shader, Center center, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle_with_shader()","type":1,"pageTitle":"Drawing","url":"reference/drawing#rectangle_with_shader-2","content":"void rectangle_with_shader(const Shader &amp; shader, TopLeftCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle_with_shader()","type":1,"pageTitle":"Drawing","url":"reference/drawing#rectangle_with_shader-3","content":"void rectangle_with_shader(const Shader &amp; shader, TopRightCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle_with_shader()","type":1,"pageTitle":"Drawing","url":"reference/drawing#rectangle_with_shader-4","content":"void rectangle_with_shader(const Shader &amp; shader, BottomLeftCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle_with_shader()","type":1,"pageTitle":"Drawing","url":"reference/drawing#rectangle_with_shader-5","content":"void rectangle_with_shader(const Shader &amp; shader, BottomRightCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"square_with_shader()","type":1,"pageTitle":"Drawing","url":"reference/drawing#square_with_shader","content":"void square_with_shader(const Shader &amp; shader, Center center ={}, Radius radius ={}, Rotation rotation ={}); "},{"title":"square_with_shader()","type":1,"pageTitle":"Drawing","url":"reference/drawing#square_with_shader-1","content":"void square_with_shader(const Shader &amp; shader, TopLeftCorner corner, Radius radius ={}, Rotation rotation ={}); "},{"title":"square_with_shader()","type":1,"pageTitle":"Drawing","url":"reference/drawing#square_with_shader-2","content":"void square_with_shader(const Shader &amp; shader, TopRightCorner corner, Radius radius ={}, Rotation rotation ={}); "},{"title":"square_with_shader()","type":1,"pageTitle":"Drawing","url":"reference/drawing#square_with_shader-3","content":"void square_with_shader(const Shader &amp; shader, BottomLeftCorner corner, Radius radius ={}, Rotation rotation ={}); "},{"title":"square_with_shader()","type":1,"pageTitle":"Drawing","url":"reference/drawing#square_with_shader-4","content":"void square_with_shader(const Shader &amp; shader, BottomRightCorner corner, Radius radius ={}, Rotation rotation ={}); "},{"title":"rectangle_with_shader()","type":1,"pageTitle":"Drawing","url":"reference/drawing#rectangle_with_shader-6","content":"void rectangle_with_shader(const Shader &amp; shader, Transform2D transform); "},{"title":"line()","type":1,"pageTitle":"Drawing","url":"reference/drawing#line","content":"void line(glm::vec2 start, glm::vec2 end); Draws a line between two points. It uses the stroke color, and stroke_weight as its thickness. "},{"title":"Attributes","type":1,"pageTitle":"Drawing","url":"reference/drawing#attributes-1","content":""},{"title":"fill","type":1,"pageTitle":"Drawing","url":"reference/drawing#fill","content":"Color fill {1.f, 1.f, 1.f, 0.5f}; Copy The color that is used for the interior of the shapes. "},{"title":"use_fill","type":1,"pageTitle":"Drawing","url":"reference/drawing#use_fill","content":"bool use_fill = true; Copy Whether the shapes will have an interior. "},{"title":"stroke","type":1,"pageTitle":"Drawing","url":"reference/drawing#stroke","content":"Color stroke {0.f, 0.f, 0.f}; Copy The color that is used for the boundary of the shapes. "},{"title":"stroke_weight","type":1,"pageTitle":"Drawing","url":"reference/drawing#stroke_weight","content":"float stroke_weight = 0.01f; Copy The size of the boundary of the shapes. "},{"title":"use_stroke","type":1,"pageTitle":"Drawing","url":"reference/drawing#use_stroke","content":"bool use_stroke = true; Copy Whether there will be a boundary on the shape.  Updated on 2022 April 09 "},{"title":"Text","type":0,"sectionRef":"#","url":"reference/text","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"Text","url":"reference/text#summary","content":""},{"title":"Functions","type":1,"pageTitle":"Text","url":"reference/text#functions","content":"\tNamevoid\ttext(const std::u16string &amp; str, Center center, Rotation rotation = {}) void\ttext(const std::u16string &amp; str, TopLeftCorner corner, Rotation rotation = {}) void\ttext(const std::u16string &amp; str, TopRightCorner corner, Rotation rotation = {}) void\ttext(const std::u16string &amp; str, BottomLeftCorner corner, Rotation rotation = {}) void\ttext(const std::u16string &amp; str, BottomRightCorner corner, Rotation rotation = {}) "},{"title":"Attributes","type":1,"pageTitle":"Text","url":"reference/text#attributes","content":"\tNamefloat\ttext_size Height of the text. float\ttext_inflating Gives some &quot;boldness&quot; to the text. "},{"title":"Functions","type":1,"pageTitle":"Text","url":"reference/text#functions-1","content":""},{"title":"text()","type":1,"pageTitle":"Text","url":"reference/text#text-1","content":"void text(const std::u16string &amp; str, Center center, Rotation rotation ={}); "},{"title":"text()","type":1,"pageTitle":"Text","url":"reference/text#text-2","content":"void text(const std::u16string &amp; str, TopLeftCorner corner, Rotation rotation ={}); "},{"title":"text()","type":1,"pageTitle":"Text","url":"reference/text#text-3","content":"void text(const std::u16string &amp; str, TopRightCorner corner, Rotation rotation ={}); "},{"title":"text()","type":1,"pageTitle":"Text","url":"reference/text#text-4","content":"void text(const std::u16string &amp; str, BottomLeftCorner corner, Rotation rotation ={}); "},{"title":"text()","type":1,"pageTitle":"Text","url":"reference/text#text-5","content":"void text(const std::u16string &amp; str, BottomRightCorner corner, Rotation rotation ={}); "},{"title":"Attributes","type":1,"pageTitle":"Text","url":"reference/text#attributes-1","content":""},{"title":"text_size","type":1,"pageTitle":"Text","url":"reference/text#text_size","content":"float text_size = 0.03f; Copy Height of the text. "},{"title":"text_inflating","type":1,"pageTitle":"Text","url":"reference/text#text_inflating","content":"float text_inflating = 0.01f; Copy Gives some &quot;boldness&quot; to the text.  Updated on 2022 April 09 "},{"title":"p6::Angle","type":0,"sectionRef":"#","url":"reference/Types/angle","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::Angle","url":"reference/Types/angle#summary","content":"\tNameconstexpr\tAngle() =default constexpr\tAngle([Radians](/reference/Types/radians) value) float\tas_turns() const float\tas_radians() const float\tas_degrees() const Radians\tvalue "},{"title":"Details","type":1,"pageTitle":"p6::Angle","url":"reference/Types/angle#details","content":""},{"title":"Angle()","type":1,"pageTitle":"p6::Angle","url":"reference/Types/angle#angle","content":"constexpr Angle() =default; "},{"title":"Angle()","type":1,"pageTitle":"p6::Angle","url":"reference/Types/angle#angle-1","content":"constexpr Angle([Radians](/reference/Types/radians) value); "},{"title":"as_turns()","type":1,"pageTitle":"p6::Angle","url":"reference/Types/angle#as_turns","content":"float as_turns() const; "},{"title":"as_radians()","type":1,"pageTitle":"p6::Angle","url":"reference/Types/angle#as_radians","content":"float as_radians() const; "},{"title":"as_degrees()","type":1,"pageTitle":"p6::Angle","url":"reference/Types/angle#as_degrees","content":"float as_degrees() const; "},{"title":"value","type":1,"pageTitle":"p6::Angle","url":"reference/Types/angle#value","content":"Radians value {}; Copy  Updated on 2022 April 09 "},{"title":"Time","type":0,"sectionRef":"#","url":"reference/time","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"Time","url":"reference/time#summary","content":""},{"title":"Functions","type":1,"pageTitle":"Time","url":"reference/time#functions","content":"\tNamefloat\ttime() const Returns the time in seconds since the creation of the Context. float\tdelta_time() const Returns an estimate of the time that elapses between two update() calls. void\ttime_perceived_as_realtime() Sets the time mode as realtime. void\ttime_perceived_as_constant_delta_time(float framerate) Sets the time mode as constant delta time. void\tframerate_synced_with_monitor() Makes sure that the framerate is adapted to your monitor: it will be 60 fps if you have a 60 Hertz monitor (which is the most common), or 120 fps if you have a 120 Hertz monitor, etc. void\tframerate_as_high_as_possible() Removes any limit on the framerate. update() will be called as fast as possible. void\tframerate_capped_at(float framerate) Keeps the framerate at the given value. "},{"title":"Functions","type":1,"pageTitle":"Time","url":"reference/time#functions-1","content":""},{"title":"time()","type":1,"pageTitle":"Time","url":"reference/time#time-1","content":"float time() const; Returns the time in seconds since the creation of the Context. "},{"title":"delta_time()","type":1,"pageTitle":"Time","url":"reference/time#delta_time","content":"float delta_time() const; Returns an estimate of the time that elapses between two update() calls. "},{"title":"time_perceived_as_realtime()","type":1,"pageTitle":"Time","url":"reference/time#time_perceived_as_realtime","content":"void time_perceived_as_realtime(); Sets the time mode as realtime. This means that what is returned by time() and delta_time() corresponds to the actual time that elapsed in the real world. This is ideal when you want to do realtime animation and interactive sketches. "},{"title":"time_perceived_as_constant_delta_time()","type":1,"pageTitle":"Time","url":"reference/time#time_perceived_as_constant_delta_time","content":"void time_perceived_as_constant_delta_time(float framerate); Sets the time mode as constant delta time. This means that what is returned by time() and delta_time() corresponds to an ideal world where there is exactly 1/framerate seconds between each updates. This is ideal when you are exporting a video and don't want the long export time to influence your animation. framerate is expressed in frames per second "},{"title":"framerate_synced_with_monitor()","type":1,"pageTitle":"Time","url":"reference/time#framerate_synced_with_monitor","content":"void framerate_synced_with_monitor(); Makes sure that the framerate is adapted to your monitor: it will be 60 fps if you have a 60 Hertz monitor (which is the most common), or 120 fps if you have a 120 Hertz monitor, etc. This is the default framerate mode. "},{"title":"framerate_as_high_as_possible()","type":1,"pageTitle":"Time","url":"reference/time#framerate_as_high_as_possible","content":"void framerate_as_high_as_possible(); Removes any limit on the framerate. update() will be called as fast as possible. "},{"title":"framerate_capped_at()","type":1,"pageTitle":"Time","url":"reference/time#framerate_capped_at","content":"void framerate_capped_at(float framerate); Keeps the framerate at the given value.  Updated on 2022 April 09 "},{"title":"p6::BottomRightCorner","type":0,"sectionRef":"#","url":"reference/Types/bottom_right_corner","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::BottomRightCorner","url":"reference/Types/bottom_right_corner#summary","content":"\tName\tBottomRightCorner() =default BottomRightCorner(float x, float y) BottomRightCorner(glm::vec2 value) glm::vec2\tvalue "},{"title":"Details","type":1,"pageTitle":"p6::BottomRightCorner","url":"reference/Types/bottom_right_corner#details","content":""},{"title":"BottomRightCorner()","type":1,"pageTitle":"p6::BottomRightCorner","url":"reference/Types/bottom_right_corner#bottomrightcorner","content":"BottomRightCorner() =default; "},{"title":"BottomRightCorner()","type":1,"pageTitle":"p6::BottomRightCorner","url":"reference/Types/bottom_right_corner#bottomrightcorner-1","content":"BottomRightCorner(float x, float y); "},{"title":"BottomRightCorner()","type":1,"pageTitle":"p6::BottomRightCorner","url":"reference/Types/bottom_right_corner#bottomrightcorner-2","content":"BottomRightCorner(glm::vec2 value); "},{"title":"value","type":1,"pageTitle":"p6::BottomRightCorner","url":"reference/Types/bottom_right_corner#value","content":"glm::vec2 value {0.f}; Copy  Updated on 2022 April 09 "},{"title":"p6::BottomLeftCorner","type":0,"sectionRef":"#","url":"reference/Types/bottom_left_corner","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::BottomLeftCorner","url":"reference/Types/bottom_left_corner#summary","content":"\tName\tBottomLeftCorner() =default BottomLeftCorner(float x, float y) BottomLeftCorner(glm::vec2 value) glm::vec2\tvalue "},{"title":"Details","type":1,"pageTitle":"p6::BottomLeftCorner","url":"reference/Types/bottom_left_corner#details","content":""},{"title":"BottomLeftCorner()","type":1,"pageTitle":"p6::BottomLeftCorner","url":"reference/Types/bottom_left_corner#bottomleftcorner","content":"BottomLeftCorner() =default; "},{"title":"BottomLeftCorner()","type":1,"pageTitle":"p6::BottomLeftCorner","url":"reference/Types/bottom_left_corner#bottomleftcorner-1","content":"BottomLeftCorner(float x, float y); "},{"title":"BottomLeftCorner()","type":1,"pageTitle":"p6::BottomLeftCorner","url":"reference/Types/bottom_left_corner#bottomleftcorner-2","content":"BottomLeftCorner(glm::vec2 value); "},{"title":"value","type":1,"pageTitle":"p6::BottomLeftCorner","url":"reference/Types/bottom_left_corner#value","content":"glm::vec2 value {0.f}; Copy  Updated on 2022 April 09 "},{"title":"p6::Center","type":0,"sectionRef":"#","url":"reference/Types/center","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::Center","url":"reference/Types/center#summary","content":"\tName\tCenter() =default Center(float x, float y) Center(glm::vec2 value) glm::vec2\tvalue "},{"title":"Details","type":1,"pageTitle":"p6::Center","url":"reference/Types/center#details","content":""},{"title":"Center()","type":1,"pageTitle":"p6::Center","url":"reference/Types/center#center","content":"Center() =default; "},{"title":"Center()","type":1,"pageTitle":"p6::Center","url":"reference/Types/center#center-1","content":"Center(float x, float y); "},{"title":"Center()","type":1,"pageTitle":"p6::Center","url":"reference/Types/center#center-2","content":"Center(glm::vec2 value); "},{"title":"value","type":1,"pageTitle":"p6::Center","url":"reference/Types/center#value","content":"glm::vec2 value {0.f}; Copy  Updated on 2022 April 09 "},{"title":"p6::Canvas","type":0,"sectionRef":"#","url":"reference/Types/canvas","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::Canvas","url":"reference/Types/canvas#summary","content":"\tName\tCanvas(ImageSize size, glpp::TextureLayout texture_layout = {glpp::InternalFormat::RGBA16, glpp::Channels::RGBA, glpp::TexelDataType::UnsignedByte}) Creates an empty canvas texture_layout is an advanced setting; it controls how the pixels are gonna be stored on the GPU. ImageSize\tsize() const Returns the size in pixels. virtual float\taspect_ratio() const override Returns the aspect ratio (width / height) float\tinverse_aspect_ratio() const Returns the inverse aspect ratio (height / width) virtual const Texture &amp;\ttexture() const override Returns the internal texture, that you can use to do advanced stuff with custom shaders. const glpp::RenderTarget &amp;\trender_target() const Returns the internal render target, that you can use to do advanced stuff. glpp::RenderTarget &amp;\trender_target() Returns the internal render target, that you can use to do advanced stuff. void\tresize(ImageSize size) Resizes the canvas. void\tdestructive_resize(ImageSize size) Resizes the canvas. "},{"title":"Details","type":1,"pageTitle":"p6::Canvas","url":"reference/Types/canvas#details","content":""},{"title":"Canvas()","type":1,"pageTitle":"p6::Canvas","url":"reference/Types/canvas#canvas","content":"Canvas(ImageSize size, glpp::TextureLayout texture_layout ={glpp::InternalFormat::RGBA16, glpp::Channels::RGBA, glpp::TexelDataType::UnsignedByte}); Creates an empty canvas texture_layout is an advanced setting; it controls how the pixels are gonna be stored on the GPU. "},{"title":"size()","type":1,"pageTitle":"p6::Canvas","url":"reference/Types/canvas#size","content":"ImageSize size() const; Returns the size in pixels. "},{"title":"aspect_ratio()","type":1,"pageTitle":"p6::Canvas","url":"reference/Types/canvas#aspect_ratio","content":"float aspect_ratio() const override; Returns the aspect ratio (width / height) Reimplements: p6::ImageOrCanvas::aspect_ratio "},{"title":"inverse_aspect_ratio()","type":1,"pageTitle":"p6::Canvas","url":"reference/Types/canvas#inverse_aspect_ratio","content":"float inverse_aspect_ratio() const; Returns the inverse aspect ratio (height / width) "},{"title":"texture()","type":1,"pageTitle":"p6::Canvas","url":"reference/Types/canvas#texture","content":"const Texture &amp; texture() const override; Returns the internal texture, that you can use to do advanced stuff with custom shaders. Reimplements: p6::ImageOrCanvas::texture "},{"title":"render_target()","type":1,"pageTitle":"p6::Canvas","url":"reference/Types/canvas#render_target","content":"const glpp::RenderTarget &amp; render_target() const; Returns the internal render target, that you can use to do advanced stuff. "},{"title":"render_target()","type":1,"pageTitle":"p6::Canvas","url":"reference/Types/canvas#render_target-1","content":"glpp::RenderTarget &amp; render_target(); Returns the internal render target, that you can use to do advanced stuff. "},{"title":"resize()","type":1,"pageTitle":"p6::Canvas","url":"reference/Types/canvas#resize","content":"void resize(ImageSize size); Resizes the canvas. "},{"title":"destructive_resize()","type":1,"pageTitle":"p6::Canvas","url":"reference/Types/canvas#destructive_resize","content":"void destructive_resize(ImageSize size); Resizes the canvas. ⚠️ All of its pixel content is lost. If you don't want that you can use resize() instead.  Updated on 2022 April 09 "},{"title":"p6::Color","type":0,"sectionRef":"#","url":"reference/Types/color","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::Color","url":"reference/Types/color#summary","content":"\tNameconstexpr\tColor(float r = 0.f, float g = 0.f, float b = 0.f, float a = 1.f) float\tr() const float\tg() const float\tb() const float\ta() const glm::vec3\tas_premultiplied_vec3() const glm::vec3\tas_straight_vec3() const glm::vec4\tas_premultiplied_vec4() const glm::vec4\tas_straight_vec4() const "},{"title":"Details","type":1,"pageTitle":"p6::Color","url":"reference/Types/color#details","content":""},{"title":"Color()","type":1,"pageTitle":"p6::Color","url":"reference/Types/color#color","content":"constexpr Color(float r =0.f, float g =0.f, float b =0.f, float a =1.f); "},{"title":"r()","type":1,"pageTitle":"p6::Color","url":"reference/Types/color#r","content":"float r() const; "},{"title":"g()","type":1,"pageTitle":"p6::Color","url":"reference/Types/color#g","content":"float g() const; "},{"title":"b()","type":1,"pageTitle":"p6::Color","url":"reference/Types/color#b","content":"float b() const; "},{"title":"a()","type":1,"pageTitle":"p6::Color","url":"reference/Types/color#a","content":"float a() const; "},{"title":"as_premultiplied_vec3()","type":1,"pageTitle":"p6::Color","url":"reference/Types/color#as_premultiplied_vec3","content":"glm::vec3 as_premultiplied_vec3() const; "},{"title":"as_straight_vec3()","type":1,"pageTitle":"p6::Color","url":"reference/Types/color#as_straight_vec3","content":"glm::vec3 as_straight_vec3() const; "},{"title":"as_premultiplied_vec4()","type":1,"pageTitle":"p6::Color","url":"reference/Types/color#as_premultiplied_vec4","content":"glm::vec4 as_premultiplied_vec4() const; "},{"title":"as_straight_vec4()","type":1,"pageTitle":"p6::Color","url":"reference/Types/color#as_straight_vec4","content":"glm::vec4 as_straight_vec4() const;  Updated on 2022 April 09 "},{"title":"p6::FitX","type":0,"sectionRef":"#","url":"reference/Types/fit_x","content":"","keywords":""},{"title":"Details","type":1,"pageTitle":"p6::FitX","url":"reference/Types/fit_x#details","content":" Updated on 2022 April 09 "},{"title":"p6::FitY","type":0,"sectionRef":"#","url":"reference/Types/fit_y","content":"","keywords":""},{"title":"Details","type":1,"pageTitle":"p6::FitY","url":"reference/Types/fit_y#details","content":" Updated on 2022 April 09 "},{"title":"p6::FullScreen","type":0,"sectionRef":"#","url":"reference/Types/full_screen","content":"","keywords":""},{"title":"Details","type":1,"pageTitle":"p6::FullScreen","url":"reference/Types/full_screen#details","content":" Updated on 2022 April 09 "},{"title":"p6::Image","type":0,"sectionRef":"#","url":"reference/Types/image","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::Image","url":"reference/Types/image#summary","content":"\tName\tImage(ImageSize size, const uint8_t * data, glpp::TextureLayout texture_layout = {glpp::InternalFormat::RGBA8, glpp::Channels::RGBA, glpp::TexelDataType::UnsignedByte}) Creates an Image filled with data. ImageSize\tsize() const Returns the size in pixels. virtual float\taspect_ratio() const override Returns the aspect ratio (width / height) float\tinverse_aspect_ratio() const Returns the inverse aspect ratio (height / width) virtual const glpp::Texture2D &amp;\ttexture() const override "},{"title":"Details","type":1,"pageTitle":"p6::Image","url":"reference/Types/image#details","content":""},{"title":"Image()","type":1,"pageTitle":"p6::Image","url":"reference/Types/image#image","content":"Image(ImageSize size, const uint8_t * data, glpp::TextureLayout texture_layout ={glpp::InternalFormat::RGBA8, glpp::Channels::RGBA, glpp::TexelDataType::UnsignedByte}); Creates an Image filled with data. This is for advanded uses; prefer using p6::load_image(). data must be an array of size size.width() * size.height() * 4, with R, G, B and A channels, starting with the bottom left pixel, and going row by row. texture_layout is an advanced setting; it controls how the pixels are gonna be stored on the GPU. "},{"title":"size()","type":1,"pageTitle":"p6::Image","url":"reference/Types/image#size","content":"ImageSize size() const; Returns the size in pixels. "},{"title":"aspect_ratio()","type":1,"pageTitle":"p6::Image","url":"reference/Types/image#aspect_ratio","content":"float aspect_ratio() const override; Returns the aspect ratio (width / height) Reimplements: p6::ImageOrCanvas::aspect_ratio "},{"title":"inverse_aspect_ratio()","type":1,"pageTitle":"p6::Image","url":"reference/Types/image#inverse_aspect_ratio","content":"float inverse_aspect_ratio() const; Returns the inverse aspect ratio (height / width) "},{"title":"texture()","type":1,"pageTitle":"p6::Image","url":"reference/Types/image#texture","content":"const glpp::Texture2D &amp; texture() const override; Reimplements: p6::ImageOrCanvas::texture  Updated on 2022 April 09 "},{"title":"p6::ImageOrCanvas","type":0,"sectionRef":"#","url":"reference/Types/image_or_canvas","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::ImageOrCanvas","url":"reference/Types/image_or_canvas#summary","content":"\tNamevirtual const glpp::Texture2D &amp;\ttexture() const =0 virtual float\taspect_ratio() const =0 "},{"title":"Details","type":1,"pageTitle":"p6::ImageOrCanvas","url":"reference/Types/image_or_canvas#details","content":""},{"title":"texture()","type":1,"pageTitle":"p6::ImageOrCanvas","url":"reference/Types/image_or_canvas#texture","content":"const glpp::Texture2D &amp; texture() const =0; Reimplemented by: p6::Canvas::texture, p6::Image::texture "},{"title":"aspect_ratio()","type":1,"pageTitle":"p6::ImageOrCanvas","url":"reference/Types/image_or_canvas#aspect_ratio","content":"float aspect_ratio() const =0; Reimplemented by: p6::Canvas::aspect_ratio, p6::Image::aspect_ratio  Updated on 2022 April 09 "},{"title":"p6::Key","type":0,"sectionRef":"#","url":"reference/Types/key","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::Key","url":"reference/Types/key#summary","content":"\tNamestd::string\tlogical The character that was pressed. int\tphysical The key at a given position on the keyboard. It is independent of the keyboard layout (e.g. GLFW_KEY_Q will correspond to the first key on the first row of your keyboard, no matter if you are using azerty instead of qwerty) "},{"title":"Details","type":1,"pageTitle":"p6::Key","url":"reference/Types/key#details","content":""},{"title":"logical","type":1,"pageTitle":"p6::Key","url":"reference/Types/key#logical","content":"std::string logical; Copy The character that was pressed. This depends on the keyboard layout (qwerty vs azerty). If the key pressed was not a character (for example ENTER, SHIFT etc.) then this is an empty string. "},{"title":"physical","type":1,"pageTitle":"p6::Key","url":"reference/Types/key#physical","content":"int physical; Copy The key at a given position on the keyboard. It is independent of the keyboard layout (e.g. GLFW_KEY_Q will correspond to the first key on the first row of your keyboard, no matter if you are using azerty instead of qwerty)  Updated on 2022 April 09 "},{"title":"p6::Context","type":0,"sectionRef":"#","url":"reference/Types/context","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#summary","content":"\tName\tContext(WindowCreationParams window_creation_params = {}) void\tbackground([Color](/reference/Types/color) color) Sets the color and alpha of each pixel of the canvas. void\tsquare([FullScreen](/reference/Types/full_screen) ) Draws a square. void\tsquare([Center](/reference/Types/center) center = {}, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare([TopLeftCorner](/reference/Types/top_left_corner) corner, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare([TopRightCorner](/reference/Types/top_right_corner) corner, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare([BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare([BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle([FullScreen](/reference/Types/full_screen) = {}) Draws a rectangle. void\trectangle([Center](/reference/Types/center) center, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle([TopLeftCorner](/reference/Types/top_left_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle([TopRightCorner](/reference/Types/top_right_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle([BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle([BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle([Transform2D](/reference/Types/transform2_d) transform) void\tcircle([FullScreen](/reference/Types/full_screen) ) Draws a circle. void\tcircle([Center](/reference/Types/center) center = {}, [Radius](/reference/Types/radius) radius = {}) void\tellipse([FullScreen](/reference/Types/full_screen) = {}) Draws an ellipse. void\tellipse([Center](/reference/Types/center) center, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tellipse([Transform2D](/reference/Types/transform2_d) transform) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Center](/reference/Types/center) center, [RadiusX](/reference/Types/radius_x) radiusX = {}, [Rotation](/reference/Types/angle) rotation = {}) Draws an image. This will respect the aspect ratio of the image. void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopLeftCorner](/reference/Types/top_left_corner) corner, [RadiusX](/reference/Types/radius_x) radiusX = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopRightCorner](/reference/Types/top_right_corner) corner, [RadiusX](/reference/Types/radius_x) radiusX = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [RadiusX](/reference/Types/radius_x) radiusX = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [RadiusX](/reference/Types/radius_x) radiusX = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Center](/reference/Types/center) center, [RadiusY](/reference/Types/radius_y) radiusY = {}, [Rotation](/reference/Types/angle) rotation = {}) Draws an image. This will respect the aspect ratio of the image. void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopLeftCorner](/reference/Types/top_left_corner) corner, [RadiusY](/reference/Types/radius_y) radiusY = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopRightCorner](/reference/Types/top_right_corner) corner, [RadiusY](/reference/Types/radius_y) radiusY = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [RadiusY](/reference/Types/radius_y) radiusY = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [RadiusY](/reference/Types/radius_y) radiusY = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [FitX](/reference/Types/fit_x) ) Draws an image as big as possible on the screen. This will respect the aspect ratio of the image. void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [FitY](/reference/Types/fit_y) = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [FullScreen](/reference/Types/full_screen) ) Draws an image that takes the entire window. ⚠️ This might distort the image if the window doesn't have the same aspect ratio as the image. void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Center](/reference/Types/center) center, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) Draws an image. ⚠️ This might distort the image if radii doesn't have the same aspect ratio as the image. void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopLeftCorner](/reference/Types/top_left_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopRightCorner](/reference/Types/top_right_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Transform2D](/reference/Types/transform2_d) transform) void\trectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [FullScreen](/reference/Types/full_screen) = {}) Draws a rectangle using a custom fragment shader. void\trectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [Center](/reference/Types/center) center, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [TopLeftCorner](/reference/Types/top_left_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [TopRightCorner](/reference/Types/top_right_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [Center](/reference/Types/center) center = {}, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [TopLeftCorner](/reference/Types/top_left_corner) corner, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [TopRightCorner](/reference/Types/top_right_corner) corner, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [Transform2D](/reference/Types/transform2_d) transform) void\tline(glm::vec2 start, glm::vec2 end) Draws a line between two points. void\ttext(const std::u16string &amp; str, [Center](/reference/Types/center) center, [Rotation](/reference/Types/angle) rotation = {}) void\ttext(const std::u16string &amp; str, [TopLeftCorner](/reference/Types/top_left_corner) corner, [Rotation](/reference/Types/angle) rotation = {}) void\ttext(const std::u16string &amp; str, [TopRightCorner](/reference/Types/top_right_corner) corner, [Rotation](/reference/Types/angle) rotation = {}) void\ttext(const std::u16string &amp; str, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Rotation](/reference/Types/angle) rotation = {}) void\ttext(const std::u16string &amp; str, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Rotation](/reference/Types/angle) rotation = {}) void\trender_to_canvas([Canvas](/reference/Types/canvas) &amp; canvas) Sets the canvas where all the drawing commands will happen on. void\trender_to_screen() Reset the Context to render to the screen. glm::vec2\tmouse() const Returns the current mouse position. glm::vec2\tmouse_delta() const Returns the movement of the mouse since last update(). bool\tmouse_is_in_window() const Returns true iff the window is focused and the coordinates returned by mouse() correspond to a position inside the window. bool\tctrl() const Returns true iff the CTRL key is pressed (or CMD on Mac) bool\tshift() const Returns true iff the SHIFT key is pressed. bool\talt() const Returns true iff the ALT key is pressed. float\taspect_ratio() const Returns the aspect ratio of the window (a.k.a. width / height). float\tinverse_aspect_ratio() const Returns the inverse aspect ratio of the window (a.k.a. height / width). ImageSize\tframebuffer_size() const Returns the size of the framebuffer (width and height). int\tframebuffer_width() const Returns the width of the framebuffer. int\tframebuffer_height() const Returns the height of the framebuffer. Color\tread_pixel(glm::vec2 position) const Returns the color of the pixel at the given position. bool\twindow_is_focused() const Returns true iff the window is currently focused. void\tfocus_window() const Focuses the window, making it pop to the foreground. void\tmaximize_window() Maximizes the window. void\tminimize_window() Minimizes the window. Note that while your window is minimized everything will be frozen and no update, event or anything will happen. void\trestore_window() Restores the window if it is currently maximized. Does nothing otherwise. bool\twindow_is_maximized() const Returns true iff the window is currently maximized. float\ttime() const Returns the time in seconds since the creation of the Context. float\tdelta_time() const Returns an estimate of the time that elapses between two update() calls. void\ttime_perceived_as_realtime() Sets the time mode as realtime. void\ttime_perceived_as_constant_delta_time(float framerate) Sets the time mode as constant delta time. void\tframerate_synced_with_monitor() Makes sure that the framerate is adapted to your monitor: it will be 60 fps if you have a 60 Hertz monitor (which is the most common), or 120 fps if you have a 120 Hertz monitor, etc. void\tframerate_as_high_as_possible() Removes any limit on the framerate. update() will be called as fast as possible. void\tframerate_capped_at(float framerate) Keeps the framerate at the given value. void\tstart() Starts the update() loop. void\tstop() Stops the update() loop. void\tpause() Pauses the update() loop. void\tresume() Resumes the update() loop if it was paused with pause(). bool\tis_paused() const Returns true iff the update() loop is currently paused. std::function&lt; void()&gt;\tupdate This function is called repeatedly. The framerate will be capped at your monitors refresh rate (60 frames per second on a typical monitor). std::function&lt; void()&gt;\timgui In this function you can render all the ImGui windows you want. std::function&lt; void(MouseMove)&gt;\tmouse_moved This function is called whenever the mouse is moved. std::function&lt; void(MouseDrag)&gt;\tmouse_dragged This function is called whenever the mouse is dragged. std::function&lt; void(MouseButton)&gt;\tmouse_pressed This function is called whenever a mouse button is pressed. std::function&lt; void(MouseButton)&gt;\tmouse_released This function is called whenever a mouse button is released. std::function&lt; void(MouseScroll)&gt;\tmouse_scrolled This function is called whenever the mouse wheel is scrolled. std::function&lt; void(Key)&gt;\tkey_pressed This function is called whenever a keyboard key is pressed. std::function&lt; void(Key)&gt;\tkey_released This function is called whenever a keyboard key is released. std::function&lt; void(Key)&gt;\tkey_repeated This function is called repeatedly whenever a keyboard key is held. std::function&lt; void(std::string &amp;&amp;)&gt;\ton_error This function is called whenever an error occurs. std::function&lt; void()&gt;\tframebuffer_resized This function is called whenever the framebuffer is resized. Color\tfill The color that is used for the interior of the shapes. bool\tuse_fill Whether the shapes will have an interior. Color\tstroke The color that is used for the boundary of the shapes. float\tstroke_weight The size of the boundary of the shapes. bool\tuse_stroke Whether there will be a boundary on the shape. float\ttext_size Height of the text. float\ttext_inflating Gives some &quot;boldness&quot; to the text. "},{"title":"Details","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#details","content":""},{"title":"Context()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#context","content":"Context(WindowCreationParams window_creation_params ={}); "},{"title":"background()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#background","content":"void background([Color](/reference/Types/color) color); Sets the color and alpha of each pixel of the canvas. NB: No blending is applied; even if you specify an alpha of 0.5 the old canvas is completely erased. This means that setting an alpha here doesn't matter much. It is only meaningful if you export the canvas as a png, or if you later try to blend the canvas on top of another image. "},{"title":"square()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#square","content":"void square([FullScreen](/reference/Types/full_screen) ); Draws a square. "},{"title":"square()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#square-1","content":"void square([Center](/reference/Types/center) center ={}, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#square-2","content":"void square([TopLeftCorner](/reference/Types/top_left_corner) corner, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#square-3","content":"void square([TopRightCorner](/reference/Types/top_right_corner) corner, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#square-4","content":"void square([BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#square-5","content":"void square([BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#rectangle","content":"void rectangle([FullScreen](/reference/Types/full_screen) ={}); Draws a rectangle. "},{"title":"rectangle()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#rectangle-1","content":"void rectangle([Center](/reference/Types/center) center, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#rectangle-2","content":"void rectangle([TopLeftCorner](/reference/Types/top_left_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#rectangle-3","content":"void rectangle([TopRightCorner](/reference/Types/top_right_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#rectangle-4","content":"void rectangle([BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#rectangle-5","content":"void rectangle([BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#rectangle-6","content":"void rectangle([Transform2D](/reference/Types/transform2_d) transform); "},{"title":"circle()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#circle","content":"void circle([FullScreen](/reference/Types/full_screen) ); Draws a circle. "},{"title":"circle()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#circle-1","content":"void circle([Center](/reference/Types/center) center ={}, [Radius](/reference/Types/radius) radius ={}); "},{"title":"ellipse()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#ellipse","content":"void ellipse([FullScreen](/reference/Types/full_screen) ={}); Draws an ellipse. "},{"title":"ellipse()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#ellipse-1","content":"void ellipse([Center](/reference/Types/center) center, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"ellipse()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#ellipse-2","content":"void ellipse([Transform2D](/reference/Types/transform2_d) transform); "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Center](/reference/Types/center) center, [RadiusX](/reference/Types/radius_x) radiusX ={}, [Rotation](/reference/Types/angle) rotation ={}); Draws an image. This will respect the aspect ratio of the image. "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-1","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopLeftCorner](/reference/Types/top_left_corner) corner, [RadiusX](/reference/Types/radius_x) radiusX ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-2","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopRightCorner](/reference/Types/top_right_corner) corner, [RadiusX](/reference/Types/radius_x) radiusX ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-3","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [RadiusX](/reference/Types/radius_x) radiusX ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-4","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [RadiusX](/reference/Types/radius_x) radiusX ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-5","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Center](/reference/Types/center) center, [RadiusY](/reference/Types/radius_y) radiusY ={}, [Rotation](/reference/Types/angle) rotation ={}); Draws an image. This will respect the aspect ratio of the image. "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-6","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopLeftCorner](/reference/Types/top_left_corner) corner, [RadiusY](/reference/Types/radius_y) radiusY ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-7","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopRightCorner](/reference/Types/top_right_corner) corner, [RadiusY](/reference/Types/radius_y) radiusY ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-8","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [RadiusY](/reference/Types/radius_y) radiusY ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-9","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [RadiusY](/reference/Types/radius_y) radiusY ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-10","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [FitX](/reference/Types/fit_x) ); Draws an image as big as possible on the screen. This will respect the aspect ratio of the image. "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-11","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [FitY](/reference/Types/fit_y) ={}); "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-12","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [FullScreen](/reference/Types/full_screen) ); Draws an image that takes the entire window. ⚠️ This might distort the image if the window doesn't have the same aspect ratio as the image. "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-13","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Center](/reference/Types/center) center, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); Draws an image. ⚠️ This might distort the image if radii doesn't have the same aspect ratio as the image. "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-14","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopLeftCorner](/reference/Types/top_left_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-15","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopRightCorner](/reference/Types/top_right_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-16","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-17","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#image-18","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Transform2D](/reference/Types/transform2_d) transform); "},{"title":"rectangle_with_shader()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#rectangle_with_shader","content":"void rectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [FullScreen](/reference/Types/full_screen) ={}); Draws a rectangle using a custom fragment shader. "},{"title":"rectangle_with_shader()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#rectangle_with_shader-1","content":"void rectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [Center](/reference/Types/center) center, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle_with_shader()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#rectangle_with_shader-2","content":"void rectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [TopLeftCorner](/reference/Types/top_left_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle_with_shader()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#rectangle_with_shader-3","content":"void rectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [TopRightCorner](/reference/Types/top_right_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle_with_shader()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#rectangle_with_shader-4","content":"void rectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle_with_shader()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#rectangle_with_shader-5","content":"void rectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square_with_shader()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#square_with_shader","content":"void square_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [Center](/reference/Types/center) center ={}, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square_with_shader()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#square_with_shader-1","content":"void square_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [TopLeftCorner](/reference/Types/top_left_corner) corner, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square_with_shader()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#square_with_shader-2","content":"void square_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [TopRightCorner](/reference/Types/top_right_corner) corner, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square_with_shader()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#square_with_shader-3","content":"void square_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square_with_shader()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#square_with_shader-4","content":"void square_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle_with_shader()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#rectangle_with_shader-6","content":"void rectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [Transform2D](/reference/Types/transform2_d) transform); "},{"title":"line()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#line","content":"void line(glm::vec2 start, glm::vec2 end); Draws a line between two points. It uses the stroke color, and stroke_weight as its thickness. "},{"title":"text()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#text","content":"void text(const std::u16string &amp; str, [Center](/reference/Types/center) center, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"text()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#text-1","content":"void text(const std::u16string &amp; str, [TopLeftCorner](/reference/Types/top_left_corner) corner, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"text()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#text-2","content":"void text(const std::u16string &amp; str, [TopRightCorner](/reference/Types/top_right_corner) corner, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"text()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#text-3","content":"void text(const std::u16string &amp; str, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"text()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#text-4","content":"void text(const std::u16string &amp; str, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"render_to_canvas()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#render_to_canvas","content":"void render_to_canvas([Canvas](/reference/Types/canvas) &amp; canvas); Sets the canvas where all the drawing commands will happen on. "},{"title":"render_to_screen()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#render_to_screen","content":"void render_to_screen(); Reset the Context to render to the screen. "},{"title":"mouse()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#mouse","content":"glm::vec2 mouse() const; Returns the current mouse position. "},{"title":"mouse_delta()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#mouse_delta","content":"glm::vec2 mouse_delta() const; Returns the movement of the mouse since last update(). "},{"title":"mouse_is_in_window()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#mouse_is_in_window","content":"bool mouse_is_in_window() const; Returns true iff the window is focused and the coordinates returned by mouse() correspond to a position inside the window. "},{"title":"ctrl()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#ctrl","content":"bool ctrl() const; Returns true iff the CTRL key is pressed (or CMD on Mac) "},{"title":"shift()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#shift","content":"bool shift() const; Returns true iff the SHIFT key is pressed. "},{"title":"alt()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#alt","content":"bool alt() const; Returns true iff the ALT key is pressed. "},{"title":"aspect_ratio()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#aspect_ratio","content":"float aspect_ratio() const; Returns the aspect ratio of the window (a.k.a. width / height). "},{"title":"inverse_aspect_ratio()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#inverse_aspect_ratio","content":"float inverse_aspect_ratio() const; Returns the inverse aspect ratio of the window (a.k.a. height / width). "},{"title":"framebuffer_size()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#framebuffer_size","content":"ImageSize framebuffer_size() const; Returns the size of the framebuffer (width and height). "},{"title":"framebuffer_width()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#framebuffer_width","content":"int framebuffer_width() const; Returns the width of the framebuffer. "},{"title":"framebuffer_height()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#framebuffer_height","content":"int framebuffer_height() const; Returns the height of the framebuffer. "},{"title":"read_pixel()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#read_pixel","content":"[Color](/reference/Types/color) read_pixel(glm::vec2 position) const; Returns the color of the pixel at the given position. The coordinates are expressed in the usual p6 coordinate system. The pixel is read from the current render target (which will be the screen in most cases, unless you used render_to_canvas()) "},{"title":"window_is_focused()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#window_is_focused","content":"bool window_is_focused() const; Returns true iff the window is currently focused. "},{"title":"focus_window()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#focus_window","content":"void focus_window() const; Focuses the window, making it pop to the foreground. "},{"title":"maximize_window()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#maximize_window","content":"void maximize_window(); Maximizes the window. "},{"title":"minimize_window()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#minimize_window","content":"void minimize_window(); Minimizes the window. Note that while your window is minimized everything will be frozen and no update, event or anything will happen. "},{"title":"restore_window()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#restore_window","content":"void restore_window(); Restores the window if it is currently maximized. Does nothing otherwise. "},{"title":"window_is_maximized()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#window_is_maximized","content":"bool window_is_maximized() const; Returns true iff the window is currently maximized. "},{"title":"time()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#time","content":"float time() const; Returns the time in seconds since the creation of the Context. "},{"title":"delta_time()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#delta_time","content":"float delta_time() const; Returns an estimate of the time that elapses between two update() calls. "},{"title":"time_perceived_as_realtime()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#time_perceived_as_realtime","content":"void time_perceived_as_realtime(); Sets the time mode as realtime. This means that what is returned by time() and delta_time() corresponds to the actual time that elapsed in the real world. This is ideal when you want to do realtime animation and interactive sketches. "},{"title":"time_perceived_as_constant_delta_time()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#time_perceived_as_constant_delta_time","content":"void time_perceived_as_constant_delta_time(float framerate); Sets the time mode as constant delta time. This means that what is returned by time() and delta_time() corresponds to an ideal world where there is exactly 1/framerate seconds between each updates. This is ideal when you are exporting a video and don't want the long export time to influence your animation. framerate is expressed in frames per second "},{"title":"framerate_synced_with_monitor()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#framerate_synced_with_monitor","content":"void framerate_synced_with_monitor(); Makes sure that the framerate is adapted to your monitor: it will be 60 fps if you have a 60 Hertz monitor (which is the most common), or 120 fps if you have a 120 Hertz monitor, etc. This is the default framerate mode. "},{"title":"framerate_as_high_as_possible()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#framerate_as_high_as_possible","content":"void framerate_as_high_as_possible(); Removes any limit on the framerate. update() will be called as fast as possible. "},{"title":"framerate_capped_at()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#framerate_capped_at","content":"void framerate_capped_at(float framerate); Keeps the framerate at the given value. "},{"title":"start()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#start","content":"void start(); Starts the update() loop. update() will be called repeatedly, until you close the window or call stop(). "},{"title":"stop()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#stop","content":"void stop(); Stops the update() loop. This is the programatic equivalent of a user closing the window. "},{"title":"pause()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#pause","content":"void pause(); Pauses the update() loop. No update() will be called, until you call resume(). User inputs are still processed. "},{"title":"resume()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#resume","content":"void resume(); Resumes the update() loop if it was paused with pause(). It has no effect if the loop was already playing. "},{"title":"is_paused()","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#is_paused","content":"bool is_paused() const; Returns true iff the update() loop is currently paused. "},{"title":"update","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#update","content":"std::function&lt; void()&gt; update = []() { }; Copy This function is called repeatedly. The framerate will be capped at your monitors refresh rate (60 frames per second on a typical monitor). "},{"title":"imgui","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#imgui","content":"std::function&lt; void()&gt; imgui = []() { }; Copy In this function you can render all the ImGui windows you want. "},{"title":"mouse_moved","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#mouse_moved","content":"std::function&lt; void(MouseMove)&gt; mouse_moved = [](MouseMove) { }; Copy This function is called whenever the mouse is moved. "},{"title":"mouse_dragged","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#mouse_dragged","content":"std::function&lt; void(MouseDrag)&gt; mouse_dragged = [](MouseDrag) { }; Copy This function is called whenever the mouse is dragged. "},{"title":"mouse_pressed","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#mouse_pressed","content":"std::function&lt; void(MouseButton)&gt; mouse_pressed = [](MouseButton) { }; Copy This function is called whenever a mouse button is pressed. "},{"title":"mouse_released","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#mouse_released","content":"std::function&lt; void(MouseButton)&gt; mouse_released = [](MouseButton) { }; Copy This function is called whenever a mouse button is released. "},{"title":"mouse_scrolled","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#mouse_scrolled","content":"std::function&lt; void(MouseScroll)&gt; mouse_scrolled = [](MouseScroll) { }; Copy This function is called whenever the mouse wheel is scrolled. "},{"title":"key_pressed","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#key_pressed","content":"std::function&lt; void(Key)&gt; key_pressed = [](Key) { }; Copy This function is called whenever a keyboard key is pressed. "},{"title":"key_released","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#key_released","content":"std::function&lt; void(Key)&gt; key_released = [](Key) { }; Copy This function is called whenever a keyboard key is released. "},{"title":"key_repeated","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#key_repeated","content":"std::function&lt; void(Key)&gt; key_repeated = [](Key) { }; Copy This function is called repeatedly whenever a keyboard key is held. (NB: this only starts after holding the key for a little while. The axact behaviour is OS-specific) ⚠️ This is less than ideal to do things like handling the movement of a character. You should rather do, in your update function: if (p6.is_held(PhysicalKey::W)) { // TODO implement is_held and PhysicalKey and LogicalKey character.move_forward(p6.delta_time());} Copy "},{"title":"on_error","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#on_error","content":"std::function&lt; void(std::string &amp;&amp;)&gt; on_error = [](std::string&amp;&amp; error_message) { throw std::runtime_error{error_message}; }; Copy This function is called whenever an error occurs. "},{"title":"framebuffer_resized","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#framebuffer_resized","content":"std::function&lt; void()&gt; framebuffer_resized = []() { }; Copy This function is called whenever the framebuffer is resized. If you call framebuffer_size(), framebuffer_width(), framebuffer_height() or aspect_ratio() inside framebuffer_resized() they will already be referring to the new size. "},{"title":"fill","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#fill","content":"Color fill {1.f, 1.f, 1.f, 0.5f}; Copy The color that is used for the interior of the shapes. "},{"title":"use_fill","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#use_fill","content":"bool use_fill = true; Copy Whether the shapes will have an interior. "},{"title":"stroke","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#stroke","content":"Color stroke {0.f, 0.f, 0.f}; Copy The color that is used for the boundary of the shapes. "},{"title":"stroke_weight","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#stroke_weight","content":"float stroke_weight = 0.01f; Copy The size of the boundary of the shapes. "},{"title":"use_stroke","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#use_stroke","content":"bool use_stroke = true; Copy Whether there will be a boundary on the shape. "},{"title":"text_size","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#text_size","content":"float text_size = 0.03f; Copy Height of the text. "},{"title":"text_inflating","type":1,"pageTitle":"p6::Context","url":"reference/Types/context#text_inflating","content":"float text_inflating = 0.01f; Copy Gives some &quot;boldness&quot; to the text.  Updated on 2022 April 09 "},{"title":"p6::MouseButton","type":0,"sectionRef":"#","url":"reference/Types/mouse_button","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::MouseButton","url":"reference/Types/mouse_button#summary","content":"\tNameglm::vec2\tposition Button\tbutton "},{"title":"Details","type":1,"pageTitle":"p6::MouseButton","url":"reference/Types/mouse_button#details","content":""},{"title":"position","type":1,"pageTitle":"p6::MouseButton","url":"reference/Types/mouse_button#position","content":"glm::vec2 position; Copy "},{"title":"button","type":1,"pageTitle":"p6::MouseButton","url":"reference/Types/mouse_button#button","content":"Button button; Copy  Updated on 2022 April 09 "},{"title":"p6::MouseMove","type":0,"sectionRef":"#","url":"reference/Types/mouse_move","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::MouseMove","url":"reference/Types/mouse_move#summary","content":"\tNameglm::vec2\tposition glm::vec2\tdelta "},{"title":"Details","type":1,"pageTitle":"p6::MouseMove","url":"reference/Types/mouse_move#details","content":""},{"title":"position","type":1,"pageTitle":"p6::MouseMove","url":"reference/Types/mouse_move#position","content":"glm::vec2 position; Copy "},{"title":"delta","type":1,"pageTitle":"p6::MouseMove","url":"reference/Types/mouse_move#delta","content":"glm::vec2 delta; Copy  Updated on 2022 April 09 "},{"title":"p6::MouseDrag","type":0,"sectionRef":"#","url":"reference/Types/mouse_drag","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::MouseDrag","url":"reference/Types/mouse_drag#summary","content":"\tNameglm::vec2\tposition glm::vec2\tdelta glm::vec2\tstart_position "},{"title":"Details","type":1,"pageTitle":"p6::MouseDrag","url":"reference/Types/mouse_drag#details","content":""},{"title":"position","type":1,"pageTitle":"p6::MouseDrag","url":"reference/Types/mouse_drag#position","content":"glm::vec2 position; Copy "},{"title":"delta","type":1,"pageTitle":"p6::MouseDrag","url":"reference/Types/mouse_drag#delta","content":"glm::vec2 delta; Copy "},{"title":"start_position","type":1,"pageTitle":"p6::MouseDrag","url":"reference/Types/mouse_drag#start_position","content":"glm::vec2 start_position; Copy  Updated on 2022 April 09 "},{"title":"p6::Radians","type":0,"sectionRef":"#","url":"reference/Types/radians","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::Radians","url":"reference/Types/radians#summary","content":"\tNameconstexpr\tRadians() =default constexpr\tRadians(float value) float\tvalue "},{"title":"Details","type":1,"pageTitle":"p6::Radians","url":"reference/Types/radians#details","content":""},{"title":"Radians()","type":1,"pageTitle":"p6::Radians","url":"reference/Types/radians#radians","content":"constexpr Radians() =default; "},{"title":"Radians()","type":1,"pageTitle":"p6::Radians","url":"reference/Types/radians#radians-1","content":"constexpr Radians(float value); "},{"title":"value","type":1,"pageTitle":"p6::Radians","url":"reference/Types/radians#value","content":"float value {0.f}; Copy  Updated on 2022 April 09 "},{"title":"p6::MouseScroll","type":0,"sectionRef":"#","url":"reference/Types/mouse_scroll","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::MouseScroll","url":"reference/Types/mouse_scroll#summary","content":"\tNamefloat\tdx float\tdy "},{"title":"Details","type":1,"pageTitle":"p6::MouseScroll","url":"reference/Types/mouse_scroll#details","content":""},{"title":"dx","type":1,"pageTitle":"p6::MouseScroll","url":"reference/Types/mouse_scroll#dx","content":"float dx; Copy "},{"title":"dy","type":1,"pageTitle":"p6::MouseScroll","url":"reference/Types/mouse_scroll#dy","content":"float dy; Copy  Updated on 2022 April 09 "},{"title":"p6::Radius","type":0,"sectionRef":"#","url":"reference/Types/radius","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::Radius","url":"reference/Types/radius#summary","content":"\tName\tRadius() =default Radius(float value) float\tvalue "},{"title":"Details","type":1,"pageTitle":"p6::Radius","url":"reference/Types/radius#details","content":""},{"title":"Radius()","type":1,"pageTitle":"p6::Radius","url":"reference/Types/radius#radius","content":"Radius() =default; "},{"title":"Radius()","type":1,"pageTitle":"p6::Radius","url":"reference/Types/radius#radius-1","content":"Radius(float value); "},{"title":"value","type":1,"pageTitle":"p6::Radius","url":"reference/Types/radius#value","content":"float value {1.f}; Copy  Updated on 2022 April 09 "},{"title":"p6::Radii","type":0,"sectionRef":"#","url":"reference/Types/radii","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::Radii","url":"reference/Types/radii#summary","content":"\tName\tRadii() =default Radii(float x, float y) Radii(glm::vec2 v) glm::vec2\tvalue "},{"title":"Details","type":1,"pageTitle":"p6::Radii","url":"reference/Types/radii#details","content":""},{"title":"Radii()","type":1,"pageTitle":"p6::Radii","url":"reference/Types/radii#radii","content":"Radii() =default; "},{"title":"Radii()","type":1,"pageTitle":"p6::Radii","url":"reference/Types/radii#radii-1","content":"Radii(float x, float y); "},{"title":"Radii()","type":1,"pageTitle":"p6::Radii","url":"reference/Types/radii#radii-2","content":"Radii(glm::vec2 v); "},{"title":"value","type":1,"pageTitle":"p6::Radii","url":"reference/Types/radii#value","content":"glm::vec2 value {1.f}; Copy  Updated on 2022 April 09 "},{"title":"p6::RadiusX","type":0,"sectionRef":"#","url":"reference/Types/radius_x","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::RadiusX","url":"reference/Types/radius_x#summary","content":"\tName\tRadiusX() =default RadiusX(float value) float\tvalue "},{"title":"Details","type":1,"pageTitle":"p6::RadiusX","url":"reference/Types/radius_x#details","content":""},{"title":"RadiusX()","type":1,"pageTitle":"p6::RadiusX","url":"reference/Types/radius_x#radiusx","content":"RadiusX() =default; "},{"title":"RadiusX()","type":1,"pageTitle":"p6::RadiusX","url":"reference/Types/radius_x#radiusx-1","content":"RadiusX(float value); "},{"title":"value","type":1,"pageTitle":"p6::RadiusX","url":"reference/Types/radius_x#value","content":"float value {1.f}; Copy  Updated on 2022 April 09 "},{"title":"p6::RadiusY","type":0,"sectionRef":"#","url":"reference/Types/radius_y","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::RadiusY","url":"reference/Types/radius_y#summary","content":"\tName\tRadiusY() =default RadiusY(float value) float\tvalue "},{"title":"Details","type":1,"pageTitle":"p6::RadiusY","url":"reference/Types/radius_y#details","content":""},{"title":"RadiusY()","type":1,"pageTitle":"p6::RadiusY","url":"reference/Types/radius_y#radiusy","content":"RadiusY() =default; "},{"title":"RadiusY()","type":1,"pageTitle":"p6::RadiusY","url":"reference/Types/radius_y#radiusy-1","content":"RadiusY(float value); "},{"title":"value","type":1,"pageTitle":"p6::RadiusY","url":"reference/Types/radius_y#value","content":"float value {1.f}; Copy  Updated on 2022 April 09 "},{"title":"p6::TopLeftCorner","type":0,"sectionRef":"#","url":"reference/Types/top_left_corner","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::TopLeftCorner","url":"reference/Types/top_left_corner#summary","content":"\tName\tTopLeftCorner() =default TopLeftCorner(float x, float y) TopLeftCorner(glm::vec2 value) glm::vec2\tvalue "},{"title":"Details","type":1,"pageTitle":"p6::TopLeftCorner","url":"reference/Types/top_left_corner#details","content":""},{"title":"TopLeftCorner()","type":1,"pageTitle":"p6::TopLeftCorner","url":"reference/Types/top_left_corner#topleftcorner","content":"TopLeftCorner() =default; "},{"title":"TopLeftCorner()","type":1,"pageTitle":"p6::TopLeftCorner","url":"reference/Types/top_left_corner#topleftcorner-1","content":"TopLeftCorner(float x, float y); "},{"title":"TopLeftCorner()","type":1,"pageTitle":"p6::TopLeftCorner","url":"reference/Types/top_left_corner#topleftcorner-2","content":"TopLeftCorner(glm::vec2 value); "},{"title":"value","type":1,"pageTitle":"p6::TopLeftCorner","url":"reference/Types/top_left_corner#value","content":"glm::vec2 value {0.f}; Copy  Updated on 2022 April 09 "},{"title":"p6::TopRightCorner","type":0,"sectionRef":"#","url":"reference/Types/top_right_corner","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::TopRightCorner","url":"reference/Types/top_right_corner#summary","content":"\tName\tTopRightCorner() =default TopRightCorner(float x, float y) TopRightCorner(glm::vec2 value) glm::vec2\tvalue "},{"title":"Details","type":1,"pageTitle":"p6::TopRightCorner","url":"reference/Types/top_right_corner#details","content":""},{"title":"TopRightCorner()","type":1,"pageTitle":"p6::TopRightCorner","url":"reference/Types/top_right_corner#toprightcorner","content":"TopRightCorner() =default; "},{"title":"TopRightCorner()","type":1,"pageTitle":"p6::TopRightCorner","url":"reference/Types/top_right_corner#toprightcorner-1","content":"TopRightCorner(float x, float y); "},{"title":"TopRightCorner()","type":1,"pageTitle":"p6::TopRightCorner","url":"reference/Types/top_right_corner#toprightcorner-2","content":"TopRightCorner(glm::vec2 value); "},{"title":"value","type":1,"pageTitle":"p6::TopRightCorner","url":"reference/Types/top_right_corner#value","content":"glm::vec2 value {0.f}; Copy  Updated on 2022 April 09 "},{"title":"p6::Transform2D","type":0,"sectionRef":"#","url":"reference/Types/transform2_d","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::Transform2D","url":"reference/Types/transform2_d#summary","content":"\tNameglm::vec2\tposition glm::vec2\tscale Rotation\trotation "},{"title":"Details","type":1,"pageTitle":"p6::Transform2D","url":"reference/Types/transform2_d#details","content":""},{"title":"position","type":1,"pageTitle":"p6::Transform2D","url":"reference/Types/transform2_d#position","content":"glm::vec2 position {0.f}; Copy "},{"title":"scale","type":1,"pageTitle":"p6::Transform2D","url":"reference/Types/transform2_d#scale","content":"glm::vec2 scale {1.f}; Copy "},{"title":"rotation","type":1,"pageTitle":"p6::Transform2D","url":"reference/Types/transform2_d#rotation","content":"Rotation rotation {0.0_radians}; Copy  Updated on 2022 April 09 "},{"title":"p6::Shader","type":0,"sectionRef":"#","url":"reference/Types/shader","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"p6::Shader","url":"reference/Types/shader#summary","content":"\tName\tShader(std::string_view fragment_source_code) Throws std::runtime_error if there is an error while compiling the shader source code. void\tset(std::string_view uniform_name, int value) const void\tset(std::string_view uniform_name, unsigned int value) const void\tset(std::string_view uniform_name, bool value) const void\tset(std::string_view uniform_name, float value) const void\tset(std::string_view uniform_name, const glm::vec2 &amp; value) const void\tset(std::string_view uniform_name, const glm::vec3 &amp; value) const void\tset(std::string_view uniform_name, const glm::vec4 &amp; value) const void\tset(std::string_view uniform_name, const glm::mat2 &amp; value) const void\tset(std::string_view uniform_name, const glm::mat3 &amp; value) const void\tset(std::string_view uniform_name, const glm::mat4 &amp; value) const "},{"title":"Details","type":1,"pageTitle":"p6::Shader","url":"reference/Types/shader#details","content":""},{"title":"Shader()","type":1,"pageTitle":"p6::Shader","url":"reference/Types/shader#shader","content":"Shader(std::string_view fragment_source_code); Throws std::runtime_error if there is an error while compiling the shader source code. "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Types/shader#set","content":"void set(std::string_view uniform_name, int value) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Types/shader#set-1","content":"void set(std::string_view uniform_name, unsigned int value) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Types/shader#set-2","content":"void set(std::string_view uniform_name, bool value) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Types/shader#set-3","content":"void set(std::string_view uniform_name, float value) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Types/shader#set-4","content":"void set(std::string_view uniform_name, const glm::vec2 &amp; value) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Types/shader#set-5","content":"void set(std::string_view uniform_name, const glm::vec3 &amp; value) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Types/shader#set-6","content":"void set(std::string_view uniform_name, const glm::vec4 &amp; value) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Types/shader#set-7","content":"void set(std::string_view uniform_name, const glm::mat2 &amp; value) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Types/shader#set-8","content":"void set(std::string_view uniform_name, const glm::mat3 &amp; value) const; "},{"title":"set()","type":1,"pageTitle":"p6::Shader","url":"reference/Types/shader#set-9","content":"void set(std::string_view uniform_name, const glm::mat4 &amp; value) const;  Updated on 2022 April 09 "},{"title":"Update Flow","type":0,"sectionRef":"#","url":"reference/update-flow","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"Update Flow","url":"reference/update-flow#summary","content":""},{"title":"Functions","type":1,"pageTitle":"Update Flow","url":"reference/update-flow#functions","content":"\tNamevoid\tstart() Starts the update() loop. void\tstop() Stops the update() loop. void\tpause() Pauses the update() loop. void\tresume() Resumes the update() loop if it was paused with pause(). bool\tis_paused() const Returns true iff the update() loop is currently paused. "},{"title":"Functions","type":1,"pageTitle":"Update Flow","url":"reference/update-flow#functions-1","content":""},{"title":"start()","type":1,"pageTitle":"Update Flow","url":"reference/update-flow#start","content":"void start(); Starts the update() loop. update() will be called repeatedly, until you close the window or call stop(). "},{"title":"stop()","type":1,"pageTitle":"Update Flow","url":"reference/update-flow#stop","content":"void stop(); Stops the update() loop. This is the programatic equivalent of a user closing the window. "},{"title":"pause()","type":1,"pageTitle":"Update Flow","url":"reference/update-flow#pause","content":"void pause(); Pauses the update() loop. No update() will be called, until you call resume(). User inputs are still processed. "},{"title":"resume()","type":1,"pageTitle":"Update Flow","url":"reference/update-flow#resume","content":"void resume(); Resumes the update() loop if it was paused with pause(). It has no effect if the loop was already playing. "},{"title":"is_paused()","type":1,"pageTitle":"Update Flow","url":"reference/update-flow#is_paused","content":"bool is_paused() const; Returns true iff the update() loop is currently paused.  Updated on 2022 April 09 "},{"title":"Introduction","type":0,"sectionRef":"#","url":"tutorials","content":"Introduction p6 is designed to be very easy to use. Here is all the code you need to create a window: #include &lt;p6/p6.h&gt; int main(){ auto ctx = p6::Context{{1280, 720, &quot;Hello p6&quot;}}; // Create a context with a window ctx.start(); // Start the p6 application} Copy And with just a little more code you can draw a circle: #include &lt;p6/p6.h&gt; int main(){ auto ctx = p6::Context{{1280, 720, &quot;Hello p6&quot;}}; ctx.update = [&amp;]() { // Define the function that will be called in a loop once you call ctx.start() ctx.background({0.5f, 0.3f, 0.8f}); // Clear the background with some color (Try to comment out this line to see what happens) ctx.circle(p6::Center{ctx.mouse()}, // Draw a circle centered on the mouse cursor p6::Radius{0.3f}); // with a radius of 0.3 }; ctx.start();} Copy","keywords":""},{"title":"Window","type":0,"sectionRef":"#","url":"reference/window","content":"","keywords":""},{"title":"Summary","type":1,"pageTitle":"Window","url":"reference/window#summary","content":""},{"title":"Functions","type":1,"pageTitle":"Window","url":"reference/window#functions","content":"\tNamefloat\taspect_ratio() const Returns the aspect ratio of the window (a.k.a. width / height). float\tinverse_aspect_ratio() const Returns the inverse aspect ratio of the window (a.k.a. height / width). ImageSize\tframebuffer_size() const Returns the size of the framebuffer (width and height). int\tframebuffer_width() const Returns the width of the framebuffer. int\tframebuffer_height() const Returns the height of the framebuffer. Color\tread_pixel(glm::vec2 position) const Returns the color of the pixel at the given position. bool\twindow_is_focused() const Returns true iff the window is currently focused. void\tfocus_window() const Focuses the window, making it pop to the foreground. void\tmaximize_window() Maximizes the window. void\tminimize_window() Minimizes the window. Note that while your window is minimized everything will be frozen and no update, event or anything will happen. void\trestore_window() Restores the window if it is currently maximized. Does nothing otherwise. bool\twindow_is_maximized() const Returns true iff the window is currently maximized. "},{"title":"Functions","type":1,"pageTitle":"Window","url":"reference/window#functions-1","content":""},{"title":"aspect_ratio()","type":1,"pageTitle":"Window","url":"reference/window#aspect_ratio","content":"float aspect_ratio() const; Returns the aspect ratio of the window (a.k.a. width / height). "},{"title":"inverse_aspect_ratio()","type":1,"pageTitle":"Window","url":"reference/window#inverse_aspect_ratio","content":"float inverse_aspect_ratio() const; Returns the inverse aspect ratio of the window (a.k.a. height / width). "},{"title":"framebuffer_size()","type":1,"pageTitle":"Window","url":"reference/window#framebuffer_size","content":"ImageSize framebuffer_size() const; Returns the size of the framebuffer (width and height). "},{"title":"framebuffer_width()","type":1,"pageTitle":"Window","url":"reference/window#framebuffer_width","content":"int framebuffer_width() const; Returns the width of the framebuffer. "},{"title":"framebuffer_height()","type":1,"pageTitle":"Window","url":"reference/window#framebuffer_height","content":"int framebuffer_height() const; Returns the height of the framebuffer. "},{"title":"read_pixel()","type":1,"pageTitle":"Window","url":"reference/window#read_pixel","content":"Color read_pixel(glm::vec2 position) const; Returns the color of the pixel at the given position. The coordinates are expressed in the usual p6 coordinate system. The pixel is read from the current render target (which will be the screen in most cases, unless you used render_to_canvas()) "},{"title":"window_is_focused()","type":1,"pageTitle":"Window","url":"reference/window#window_is_focused","content":"bool window_is_focused() const; Returns true iff the window is currently focused. "},{"title":"focus_window()","type":1,"pageTitle":"Window","url":"reference/window#focus_window","content":"void focus_window() const; Focuses the window, making it pop to the foreground. "},{"title":"maximize_window()","type":1,"pageTitle":"Window","url":"reference/window#maximize_window","content":"void maximize_window(); Maximizes the window. "},{"title":"minimize_window()","type":1,"pageTitle":"Window","url":"reference/window#minimize_window","content":"void minimize_window(); Minimizes the window. Note that while your window is minimized everything will be frozen and no update, event or anything will happen. "},{"title":"restore_window()","type":1,"pageTitle":"Window","url":"reference/window#restore_window","content":"void restore_window(); Restores the window if it is currently maximized. Does nothing otherwise. "},{"title":"window_is_maximized()","type":1,"pageTitle":"Window","url":"reference/window#window_is_maximized","content":"bool window_is_maximized() const; Returns true iff the window is currently maximized.  Updated on 2022 April 09 "},{"title":"angles","type":0,"sectionRef":"#","url":"tutorials/angles","content":"angles const p6::Angle angle = 0.5_turn;const p6::Angle angle2 = 180_degrees;const p6::Angle angle3 = 3.14_radians; Copy","keywords":""},{"title":"Creating a project","type":0,"sectionRef":"#","url":"tutorials/creating-a-project","content":"","keywords":""},{"title":"Structure","type":1,"pageTitle":"Creating a project","url":"tutorials/creating-a-project#structure","content":"Here is the minimal project structure that you need to have:  "},{"title":"CMakeLists.txt","type":1,"pageTitle":"Creating a project","url":"tutorials/creating-a-project#cmakeliststxt","content":"CMakeLists.txt cmake_minimum_required(VERSION 3.20)project(my-p6-project) add_executable(${PROJECT_NAME} main.cpp)target_compile_features(${PROJECT_NAME} PRIVATE cxx_std_17) # ---Add p6---add_subdirectory(p6)target_link_p6_library(${PROJECT_NAME}) # We don't use the usual target_link_libraries() because p6 needs some additional setup Copy "},{"title":"main.cpp","type":1,"pageTitle":"Creating a project","url":"tutorials/creating-a-project#maincpp","content":"main.cpp #include &lt;p6/p6.h&gt; int main(){ auto ctx = p6::Context{{1280, 720, &quot;My p6 project&quot;}}; // Create a context with a window ctx.start(); // Start the p6 application} Copy "},{"title":"p6","type":1,"pageTitle":"Creating a project","url":"tutorials/creating-a-project#p6","content":"To get the p6 folder, open a terminal at the root of your project and run: git clone --recursive https://github.com/JulesFouchy/p6 Copy Or, if you have already setup a git repository for your project, you can add p6 as a submodule instead: git submodule add https://github.com/JulesFouchy/p6git submodule update --init --recursive Copy (To learn about Git submodules, check out this lesson). tip You can always compare with the basic example if something is not quite working for you. "},{"title":"Conclusion","type":1,"pageTitle":"Creating a project","url":"tutorials/creating-a-project#conclusion","content":"If everything went well you should be able to run your project and see this window:  Congrats 🎉 You can now start using p6 to build amazing artworks, interactive experiences and games! "},{"title":"Canvases","type":0,"sectionRef":"#","url":"tutorials/canvases","content":"","keywords":""},{"title":"Drawing on a Canvas","type":1,"pageTitle":"Canvases","url":"tutorials/canvases#drawing-on-a-canvas","content":"You can draw onto a canvas just as you would with the screen. All drawings between the calls to ctx.render_to_canvas(canvas) and ctx.render_to_screen() will apply to the canvas, not to the screen: #include &lt;p6/p6.h&gt; int main(){ auto ctx = p6::Context{}; auto canvas = p6::Canvas{ctx.framebuffer_size()}; // Create an empty canvas with the same size as the window's framebuffer ctx.render_to_canvas(canvas); ctx.background({0.3f, 0.5f, 0.9f, 0.5f}); // background() applies to canvas, not to the screen ctx.circle(); // circle() applies to canvas, not to the screen ctx.render_to_screen(); ctx.framebuffer_resized = [&amp;]() { canvas.resize(ctx.framebuffer_size()); // Make sure that the canvas still has the same size as the window's framebuffer even after it resizes }; ctx.update = [&amp;]() { ctx.background({}); ctx.image(canvas); }; ctx.start();} Copy For a more detailed example, check this one out. "},{"title":"Displaying a canvas","type":1,"pageTitle":"Canvases","url":"tutorials/canvases#displaying-a-canvas","content":"You can show a canvas with the image() function: ctx.image(canvas, p6::Center{}, p6::RadiusY{0.2f}); // Give it a height of 0.4 The width will be deduced based on the aspect_ratio of the canvas Copy Since a canvas has an aspect ratio that we want to try and preserve it is recommended to use either p6::RadiusX, p6::RadiusY, p6::FitX or p6::FitY to describe the size of the canvas. If you are ok with getting a distorted image then you can use p6::Radii to specify both the width and the height, or p6::FullScreen. "},{"title":"Custom Shaders","type":0,"sectionRef":"#","url":"tutorials/custom-shaders","content":"","keywords":""},{"title":"Load and Draw a shader","type":1,"pageTitle":"Custom Shaders","url":"tutorials/custom-shaders#load-and-draw-a-shader","content":"#include &lt;p6/p6.h&gt; int main(){ auto ctx = p6::Context{}; const p6::Shader my_shader = p6::load_shader(&quot;res/my_shader.frag&quot;); ctx.update = [&amp;]() { ctx.background({}); ctx.rectangle_with_shader(my_shader, p6::FullScreen{}); }; ctx.start();} Copy res/my_shader.frag #version 330out vec4 _frag_color; in vec2 _uniform_uv;in vec2 _raw_uv;in vec2 _canvas_uv; uniform float _aspect_ratio;uniform float _inverse_aspect_ratio;uniform vec2 _size;uniform float _window_aspect_ratio;uniform float _window_inverse_aspect_ratio; void main(){ vec2 uv = _uniform_uv; _frag_color = vec4(vec3(smoothstep(0.301, 0.3, length(uv))), 1.); // Draw a white disk} Copy NB: For this example to work you must ask p6 to copy your res folder. To do so, add this line in your CMakeLists.txt: p6_copy_folder(${PROJECT_NAME} res). "},{"title":"Available information","type":1,"pageTitle":"Custom Shaders","url":"tutorials/custom-shaders#available-information","content":""},{"title":"UV","type":1,"pageTitle":"Custom Shaders","url":"tutorials/custom-shaders#uv","content":"You have different coordinate systems available to you: _uniform_uv is what you should use most of the time. It is centered around (0, 0) and the y-axis goes from -1 to 1. The x-axis will adapt to the aspect ratio of the rectangle (goes from -_aspect_ratio to +_aspect_ratio)._raw_uv goes from 0 to 1 on both axes, no matter the aspect ratio of the rectangle. (0, 0) is in the bottom-left corner._canvas_uv is like _uniform_uv but the axes go from -rectangle_radii to +rectangle_radii. You will probably never have a use case for this one. It is used internally to draw strokes with an absolute size instead of them beeing proportional to the size of the rectangle. "},{"title":"Shape of the rectangle","type":1,"pageTitle":"Custom Shaders","url":"tutorials/custom-shaders#shape-of-the-rectangle","content":"_aspect_ratio: Aspect ratio of the rectangle (width / height)._inverse_aspect_ratio: Inverse aspect ratio of the rectangle (height / width)._size: Size of the rectangle. "},{"title":"Window","type":1,"pageTitle":"Custom Shaders","url":"tutorials/custom-shaders#window","content":"_window_aspect_ratio: Aspect ratio of the window (width / height)._window_inverse_aspect_ratio: Inverse aspect ratio of the window (height / width). "},{"title":"Sending parameters to shaders","type":1,"pageTitle":"Custom Shaders","url":"tutorials/custom-shaders#sending-parameters-to-shaders","content":"Parameters for shaders are called uniforms. You declare them in your shader like so: res/my_shader.frag #version 330 uniform float my_parameter;uniform vec3 another_parameter;// . . . void main() { _frag_color = vec4(another_parameter, 1.); // Use another_parameter like any other variable} Copy And you send them to your shader with set(): ctx.update = [&amp;]() { my_shader.set(&quot;my_parameter&quot;, 3.14f); my_shader.set(&quot;another_parameter&quot;, glm::vec3{0.1f, 0.4f, ctx.time()}); // . . .}; Copy "},{"title":"Dear ImGui","type":0,"sectionRef":"#","url":"tutorials/dear-imgui","content":"","keywords":""},{"title":"ctx.imgui","type":1,"pageTitle":"Dear ImGui","url":"tutorials/dear-imgui#ctximgui","content":"You simply have to render all your ImGui windows inside the ctx.imgui function: #include &lt;p6/p6.h&gt; int main(){ auto ctx = p6::Context{{1280, 720, &quot;Dear ImGui&quot;}}; auto square_radius = 0.5f; std::string text = &quot;Hello&quot;; ctx.imgui = [&amp;]() { // Show a simple window ImGui::Begin(&quot;Test&quot;); ImGui::SliderFloat(&quot;Square size&quot;, &amp;square_radius, 0.f, 1.f); ImGui::InputText(&quot;Text&quot;, &amp;text); ImGui::End(); // Show the official ImGui demo window // It is very useful to discover all the widgets available in ImGui ImGui::ShowDemoWindow(); }; ctx.update = [&amp;]() { ctx.background({1, 1, 0, 1}); ctx.square(p6::Center{}, p6::Radius{square_radius}); }; ctx.start();} Copy "},{"title":"Learning Dear ImGui","type":1,"pageTitle":"Dear ImGui","url":"tutorials/dear-imgui#learning-dear-imgui","content":"Here is Dear ImGui's GitHub tip Dear ImGui doesn't have an official documentation, but you can look at their demo window to see all the available widgets. To open it simply call ImGui::ShowDemoWindow(); inside ctx.imgui. And if you want to see the associated code, open Tools-&gt;Metrics/Debugger and then choose the Item Picker: it will allow you to click on any widget and have your IDE take you to the code that created it. (NB: you might have to go up in the callstack a little bit). "},{"title":"Images","type":0,"sectionRef":"#","url":"tutorials/images","content":"","keywords":""},{"title":"Loading an image","type":1,"pageTitle":"Images","url":"tutorials/images#loading-an-image","content":"You can load any image (png, jpeg, etc.) with load_image(): const p6::Image image = p6::load_image(&quot;img/my_file.png&quot;); Copy In order for this to work you must have an img folder at the root of your project, with a my_file.png file in it. AND you must declare your images folder in CMake: p6_copy_folder(${PROJECT_NAME} img). For a complete example of this, check out this example. "},{"title":"Displaying an image","type":1,"pageTitle":"Images","url":"tutorials/images#displaying-an-image","content":"You can draw an image with the image() function: const auto image = p6::load_image(&quot;img/my_file.png&quot;);ctx.image(image, p6::Center{}, p6::RadiusY{0.2f}); // Give it a height of 0.4 The width will be deduced based on the aspect_ratio of the image Copy Since an image has an aspect ratio that we want to try and preserve it is recommended to use either p6::RadiusX, p6::RadiusY, p6::FitX or p6::FitY to describe the size of the image. If you are ok with getting a distorted image then you can use p6::Radii to specify both the width and the height, or p6::FullScreen. "},{"title":"Read Pixel","type":0,"sectionRef":"#","url":"tutorials/read-pixel","content":"","keywords":""},{"title":"Brief","type":1,"pageTitle":"Read Pixel","url":"tutorials/read-pixel#brief","content":"You can ask for the color of a pixel with ctx.read_pixel(position). "},{"title":"Example","type":1,"pageTitle":"Read Pixel","url":"tutorials/read-pixel#example","content":"#include &lt;p6/p6.h&gt; int main(){ auto ctx = p6::Context{}; ctx.update = [&amp;]() { ctx.background(p6::Color{1, 0, 0}); }; ctx.mouse_pressed = [&amp;](p6::MouseButton button) { const p6::Color color = ctx.read_pixel(button.position); assert(color == p6::Color{1, 0, 0}); }; ctx.start();} Copy "},{"title":"Nota Bene","type":1,"pageTitle":"Read Pixel","url":"tutorials/read-pixel#nota-bene","content":"This function is meant to be used to read one single pixel from time to time, for example in mouse_pressed() or mouse_moved(). If you want to loop and read the color of all the pixels, using read_pixel() will be pretty slow. A much better alternative (but arguably more complex to setup) would be to use a shader. "},{"title":"Drawing","type":0,"sectionRef":"#","url":"tutorials/drawing","content":"","keywords":""},{"title":"background()","type":1,"pageTitle":"Drawing","url":"tutorials/drawing#background","content":"background() clears the whole canvas with one solid color. It is very useful if you want to do animations and don't want the drawings of the previous frames to remain on your canvas. On the other hand not using background() can give you very cool effects. ctx.update = [&amp;]() { ctx.background({0.2f, 0.1f, 0.3f}); // Comment out this line for an interesting effect ctx.circle(p6::Center{ctx.mouse()}, p6::Radius{0.3f});}; Copy And if you want your drawings to slowly fade away, draw a partially transparent rectangle instead of using background(): ctx.update = [&amp;]() { // Clear the background with a fading effect ctx.use_stroke = false; ctx.fill = {0.2f, 0.1f, 0.3f, 0.1f}; ctx.rectangle(p6::FullScreen{}); // Draw something ctx.fill = {1.f, 0.7f, 0.2f}; ctx.circle(p6::Center{ctx.mouse()}, p6::Radius{0.3f});}; Copy "},{"title":"Shapes","type":1,"pageTitle":"Drawing","url":"tutorials/drawing#shapes","content":"circle(), ellipse(), square() and rectangle() have many overloads. Go to the reference to learn all about them. #include &lt;p6/p6.h&gt; int main(){ auto ctx = p6::Context{}; p6::Angle rotation = 0.011_turn; ctx.mouse_scrolled = [&amp;](p6::MouseScroll e) { rotation += e.dy * 0.025_turn; }; ctx.update = [&amp;]() { ctx.background({}); ctx.stroke = {1, 1, 1, 1}; // White square positioned by Center ctx.square(p6::Center{ctx.mouse()}, p6::Radius{0.3f}, p6::Rotation{rotation}); // Red square positioned by Top Left Corner ctx.fill = {1, 0, 0, 0.5}; ctx.square(p6::TopLeftCorner{ctx.mouse()}, p6::Radius{0.3f}, p6::Rotation{rotation}); // Green square positioned by Top Right Corner ctx.fill = {0, 1, 0, 0.5}; ctx.square(p6::TopRightCorner{ctx.mouse()}, p6::Radius{0.3f}, p6::Rotation{rotation}); // Blue square positioned by Bottom Left Corner ctx.fill = {0, 0, 1, 0.5}; ctx.square(p6::BottomLeftCorner{ctx.mouse()}, p6::Radius{0.3f}, p6::Rotation{rotation}); // Cyan square positioned by Bottom Right Corner ctx.fill = {0, 1, 1, 0.5}; ctx.square(p6::BottomRightCorner{ctx.mouse()}, p6::Radius{0.3f}, p6::Rotation{rotation}); }; ctx.start();} Copy "},{"title":"Colors","type":1,"pageTitle":"Drawing","url":"tutorials/drawing#colors","content":"Colors are expressed as RGBA, with each value going from 0.0 to 1.0: p6::Color color{1.f, 0.7f, 0.2f}; // A nice orange. // If you don't specify the fourth value (alpha, the opacity) it will be defaulted to 1.0 Copy Shapes have two colors: the fill and the stroke. The fill controls the &quot;main&quot; color of the shapeThe stroke adds a second color on the edges of the shape. The size of that edge is controlled by stroke_weight. Both the fill and the stroke can be disabled with ctx.use_fill = false; and ctx.use_stroke = false;. #include &lt;p6/p6.h&gt; int main(){ auto ctx = p6::Context{}; ctx.fill = {1, 1, 1}; // White ctx.stroke = {0, 0, 0}; // Black ctx.stroke_weight = 0.1f; ctx.background({0, 1, 1}); // Cyan ctx.use_fill = true; ctx.use_stroke = true; ctx.circle(p6::Center{-0.5f, 0.5f}, p6::Radius{0.5f}); ctx.use_fill = false; ctx.use_stroke = true; ctx.circle(p6::Center{0.5f, 0.5f}, p6::Radius{0.5f}); ctx.use_fill = true; ctx.use_stroke = false; ctx.circle(p6::Center{-0.5f, -0.5f}, p6::Radius{0.5f}); ctx.start();} Copy "},{"title":"Line","type":1,"pageTitle":"Drawing","url":"tutorials/drawing#line","content":"ctx.line() is a bit of a special shape: it has only one color which is the stroke color, and its thickness is controlled by stroke_weight: #include &lt;p6/p6.h&gt; int main(){ auto ctx = p6::Context{}; ctx.update = [&amp;]() { ctx.background({}); ctx.stroke = p6::Color{1.f, 1.f, 1.f, 0.75f}; ctx.stroke_weight = 0.1f; ctx.line(glm::vec2{0.f}, ctx.mouse()); }; ctx.start();} Copy  "},{"title":"Text","type":0,"sectionRef":"#","url":"tutorials/text","content":"","keywords":""},{"title":"Rendering text","type":1,"pageTitle":"Text","url":"tutorials/text#rendering-text","content":"You can use the ctx.text() function. The color of the text is controlled by ctx.fill. The size of the text is controlled by ctx.text_size. #include &lt;p6/p6.h&gt; int main(){ auto ctx = p6::Context{}; ctx.update = [&amp;]() { ctx.background(p6::NamedColor::Black); ctx.fill = p6::NamedColor::Red; ctx.text_size = 0.04f; ctx.text(u&quot;Some unicode text: éç&quot;, p6::Center{}); }; ctx.start();} Copy info We support unicode characters (a.k.a. every character you could possibly ever want), but the default C++ strings only support ASCII. This is why text() takes a std::u16string, that you can create by adding the u prefix to your strings: u&quot;Some unicode text: éç&quot;. "},{"title":"The Context","type":0,"sectionRef":"#","url":"tutorials/the-context","content":"The Context The Context is the center of your p6 application. It is responsible for the window you see on screen, and all the drawing and interaction happens through the Context. tip You can read the reference to discover everything that is available in the Context.","keywords":""},{"title":"The coordinate system","type":0,"sectionRef":"#","url":"tutorials/the-coordinate-system","content":"","keywords":""},{"title":"Framebuffer","type":1,"pageTitle":"The coordinate system","url":"tutorials/the-coordinate-system#framebuffer","content":"If you need to you can access the size of the window's framebuffer through the ctx.framebuffer_size(), ctx.framebuffer_width() and ctx.framebuffer_height() functions. But I would not recommend to do so because in most cases you will be better off using relative coordinates. These functions are mainly here to allow you to create an Image that has the same size as the window's framebuffer, but this is an advanced use case. NB: the framebuffer is the image that you see in your window. It does not necessarily have the same size as the window itself since retina displays exist (see glfw's documentation). This is why we always talk about the size of the framebuffer instead of the size of the window. "},{"title":"Time and Framerate","type":0,"sectionRef":"#","url":"tutorials/time-and-framerate","content":"","keywords":""},{"title":"Querying time information","type":1,"pageTitle":"Time and Framerate","url":"tutorials/time-and-framerate#querying-time-information","content":""},{"title":"time()","type":1,"pageTitle":"Time and Framerate","url":"tutorials/time-and-framerate#time","content":"ctx.time() returns the time in seconds since the creation of the Context. It is useful for example if you want your drawing to be a direct function of time: ctx.circle(p6::Center{sin(ctx.time(),0.f)}); Copy "},{"title":"delta_time()","type":1,"pageTitle":"Time and Framerate","url":"tutorials/time-and-framerate#delta_time","content":"ctx.delta_time() returns the time in seconds that elapsed since the last update() call. It is useful for example if you want to do incremental movements frame by frame: taking delta_time() into account will make sure that your animation is independent of the framerate and will be perceived the same even if your computer starts lagging a little bit, or if you change the framerate mode. You really want to try and not depend on the framerate, for the framerate is an implementation detail and you would rather want to work at a conceptual level, with an animation that is continuous and only depends on the actual amount of time that elapses. This will also simplify your life when you will try to export your animation as a video. For more details, see this article: Understanding Time.deltaTime. float x = 0.f;ctx.update = [&amp;]() { x += 0.001f; // Bad, if the framerate doubles x will change twice as fast. x += 0.06f * ctx.delta_time(); // Good, we express our speed in units per second and changing the framerate won't change the animation speed.} Copy "},{"title":"Framerate","type":1,"pageTitle":"Time and Framerate","url":"tutorials/time-and-framerate#framerate","content":"The framerate mode controls the speed at which update() will be called, a.k.a. the amount of physical time that elapses between two updates. NB: all of these modes will try to satisfy your request but if your update() function takes too long to run we might not be able to call it as often as you would like. "},{"title":"Synced with monitor","type":1,"pageTitle":"Time and Framerate","url":"tutorials/time-and-framerate#synced-with-monitor","content":"ctx.framerate_synced_with_monitor(); Copy This is the default mode. It makes sure that the framerate will be adapted to your monitor (which is 60 Hertz in most cases). This is known as vsync or vertical synchronization. This will ask less unnecessary work to your computer because it is pointless to render more frames than your monitor can display anyways. It also prevents visual artifacts like screen tearing. "},{"title":"As high as possible","type":1,"pageTitle":"Time and Framerate","url":"tutorials/time-and-framerate#as-high-as-possible","content":"ctx.framerate_as_high_as_possible(); Copy This will remove any constraint on your framerate and call update() as fast as physically possible for your computer. This can be useful sometimes if you want to loop as fast as possible to see the end result of an animation. Please note that an alternative solution would be to keep framerate_synced_with_monitor() and call your animation in your own loop: MyParticleSystem particles{};ctx.update = [&amp;]() { for (int _ = 0; _ &lt; 100; ++_) { // Do 100 particle updates in each ctx.update() to speed up the simulation particles.update(); }}; Copy "},{"title":"Capped at","type":1,"pageTitle":"Time and Framerate","url":"tutorials/time-and-framerate#capped-at","content":"ctx.framerate_capped_at(5); // 5 fps Copy Allows you to decide what the framerate should be. This can be useful for example if you want to slow down your animation to see each frame better. "},{"title":"Time perceived as","type":1,"pageTitle":"Time and Framerate","url":"tutorials/time-and-framerate#time-perceived-as","content":"Controls what is returned by ctx.time() and ctx.delta_time(). "},{"title":"Realtime","type":1,"pageTitle":"Time and Framerate","url":"tutorials/time-and-framerate#realtime","content":"ctx.time_perceived_as_realtime(); Copy ctx.time() and ctx.delta_time() will correspond to the actual amount of time that elapses in the real world. This is the default mode and it is ideal for realtime rendering. "},{"title":"Constant delta time","type":1,"pageTitle":"Time and Framerate","url":"tutorials/time-and-framerate#constant-delta-time","content":"ctx.time_perceived_as_constant_delta_time(30.f); // I want to export a 30 fps video Copy ctx.time() and ctx.delta_time() will pretend that time elapses at exactly the framerate you asked. This is ideal for offline rendering because it won't be affected by the time it actually takes to run your update() function. "},{"title":"Pause and resume","type":1,"pageTitle":"Time and Framerate","url":"tutorials/time-and-framerate#pause-and-resume","content":"Note that using pause() will not only prevent update() from beeing called, but also freeze the time (even if you use realtime mode). For example if time() was 10.f when you called pause(), and if you wait 5 seconds before calling resume(), time will still be 10.f after that and delta_time() will not be 5 seconds, it will be approximately 1/60 (if your framerate is set to 60 fps). "}]