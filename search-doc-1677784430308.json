[{"title":"Summary","type":0,"sectionRef":"#","url":"/p6-docs/reference","content":"Summary Welcome to the reference! In here you can find all the details about everything that is available in p6. Section Canvas You can either draw directly in the window (the default) or onto a custom Canvas. Section Drawing Draw shapes and control the look of them. Section Events You can set those functions as you wish to react to various events. Section Image Load and query information about images. Section Input Query the state of the mouse and keyboard. Section Math Mathematical functions and numerical constants. Section Random Pick random numbers, points, directions, etc. Section Text Write text to the screen. Section Time Query time information and control how it elapses. Section Transform Allows you to translate / rotate / scale all your drawings at once. Section Update Flow Control the update() loop and query information about it. Section Window Query the state of the window and control it.","keywords":""},{"title":"Examples","type":0,"sectionRef":"#","url":"/p6-docs/examples","content":"Examples To see examples of how to use p6 check out our tests.","keywords":""},{"title":"Canvas","type":0,"sectionRef":"#","url":"/p6-docs/reference/canvas","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#summary","content":""},{"title":"Classes​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#classes","content":"\tNameclass\tp6::Canvas A canvas is an image that can be drawn onto. "},{"title":"Functions​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#functions","content":"\tNamevoid\tsave_image(const Canvas &amp; canvas, std::filesystem::path path) Saves the content of the canvas as an image file. void\trender_to_canvas(Canvas &amp; canvas) Sets a canvas to be the one that all the drawing commands will draw on, until you call render_to_main_canvas. void\trender_to_main_canvas() Reset the Context to render to the main canvas. The main canvas is the one that will be displayed in the window. Canvas &amp;\tmain_canvas() const Canvas &amp;\tmain_canvas() const Canvas &amp;\tcurrent_canvas() const Canvas &amp;\tcurrent_canvas() const float\taspect_ratio() const Returns the aspect ratio (a.k.a. float\tinverse_aspect_ratio() const Returns the inverse aspect ratio (a.k.a. ImageSize\tmain_canvas_size() const Returns the size of the main canvas (width and height). int\tmain_canvas_width() const Returns the width of the main canvas. int\tmain_canvas_height() const Returns the height of the main canvas. ImageSize\tcurrent_canvas_size() const Returns the size of the current canvas (width and height). int\tcurrent_canvas_width() const Returns the width of the current canvas. int\tcurrent_canvas_height() const Returns the height of the current canvas. void\tmain_canvas_mode(CanvasSizeMode mode) Sets how the size of the main canvas will be computed. float\tcanvas_ratio(const Canvas &amp; canvas) const Returns the ratio that you need to multiply with in order to match the position and size of the canvas when it is fitted in the window. void\tsave_image(std::filesystem::path path) const Saves the content of the window's main canvas as an image file. Color\tread_pixel(glm::vec2 position) const Returns the color of the pixel at the given position in the main canvas. "},{"title":"Functions​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#functions-1","content":""},{"title":"save_image()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#save_image","content":"void save_image(const Canvas &amp; canvas, std::filesystem::path path); Saves the content of the canvas as an image file. Supported file types are .png and .jpeg/.jpg Simply use the corresponding extension to save in the desired format. If the path already exists, a number will be appended to the name and the previous file won't be overwritten. If the path is relative, it will be relative to the directory containing your executable. If some directories in the path don't exist yet, they will be created automatically. "},{"title":"render_to_canvas()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#render_to_canvas","content":"void render_to_canvas(Canvas &amp; canvas); Sets a canvas to be the one that all the drawing commands will draw on, until you call render_to_main_canvas. "},{"title":"render_to_main_canvas()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#render_to_main_canvas","content":"void render_to_main_canvas(); Reset the Context to render to the main canvas. The main canvas is the one that will be displayed in the window. "},{"title":"main_canvas()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#main_canvas","content":"Canvas &amp; main_canvas(); "},{"title":"main_canvas()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#main_canvas-1","content":"const Canvas &amp; main_canvas() const; "},{"title":"current_canvas()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#current_canvas","content":"Canvas &amp; current_canvas(); "},{"title":"current_canvas()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#current_canvas-1","content":"const Canvas &amp; current_canvas() const; "},{"title":"aspect_ratio()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#aspect_ratio","content":"float aspect_ratio() const; Returns the aspect ratio (a.k.a. width / height) of the current canvas. This canvas is the window's main canvas by default, unless you called render_to_canvas() in which case it will be the given canvas. When you call render_to_main_canvas() the current canvas goes back to beeing the window's main canvas. "},{"title":"inverse_aspect_ratio()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#inverse_aspect_ratio","content":"float inverse_aspect_ratio() const; Returns the inverse aspect ratio (a.k.a. height / width) of the current canvas. This canvas is the window's main canvas by default, unless you called render_to_canvas() in which case it will be the given canvas. When you call render_to_main_canvas() the current canvas goes back to beeing the window's main canvas. "},{"title":"main_canvas_size()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#main_canvas_size","content":"ImageSize main_canvas_size() const; Returns the size of the main canvas (width and height). "},{"title":"main_canvas_width()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#main_canvas_width","content":"int main_canvas_width() const; Returns the width of the main canvas. "},{"title":"main_canvas_height()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#main_canvas_height","content":"int main_canvas_height() const; Returns the height of the main canvas. "},{"title":"current_canvas_size()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#current_canvas_size","content":"ImageSize current_canvas_size() const; Returns the size of the current canvas (width and height). "},{"title":"current_canvas_width()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#current_canvas_width","content":"int current_canvas_width() const; Returns the width of the current canvas. "},{"title":"current_canvas_height()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#current_canvas_height","content":"int current_canvas_height() const; Returns the height of the current canvas. "},{"title":"main_canvas_mode()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#main_canvas_mode","content":"void main_canvas_mode(CanvasSizeMode mode); Sets how the size of the main canvas will be computed. The default mode is CanvasSizeMode_SameAsWindow. "},{"title":"canvas_ratio()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#canvas_ratio","content":"float canvas_ratio(const Canvas &amp; canvas) const; Returns the ratio that you need to multiply with in order to match the position and size of the canvas when it is fitted in the window. "},{"title":"save_image()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#save_image-1","content":"void save_image(std::filesystem::path path) const; Saves the content of the window's main canvas as an image file. Supported file types are .png and .jpeg/.jpg Simply use the corresponding extension to save in the desired format. If the path already exists, a number will be appended to the name and the previous file won't be overwritten. If the path is relative, it will be relative to the directory containing your executable. If some directories in the path don't exist yet, they will be created automatically. "},{"title":"read_pixel()​","type":1,"pageTitle":"Canvas","url":"/p6-docs/reference/canvas#read_pixel","content":"Color read_pixel(glm::vec2 position) const; Returns the color of the pixel at the given position in the main canvas. The coordinates are expressed in the usual p6 coordinate system.  Updated on 2023 March 02 "},{"title":"Events","type":0,"sectionRef":"#","url":"/p6-docs/reference/events","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#summary","content":""},{"title":"Attributes​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#attributes","content":"\tNamestd::function&lt; void()&gt;\tupdate This function is called repeatedly. The framerate is controlled by the framerate_xxx() functions. std::function&lt; void()&gt;\timgui In this function you can call all the ImGui code you want. std::function&lt; void(MouseMove)&gt;\tmouse_moved This function is called whenever the mouse is moved. std::function&lt; void(MouseDrag)&gt;\tmouse_dragged This function is called whenever the mouse is dragged. std::function&lt; void(MouseButton)&gt;\tmouse_pressed This function is called whenever a mouse button is pressed. std::function&lt; void(MouseButton)&gt;\tmouse_released This function is called whenever a mouse button is released. std::function&lt; void(MouseScroll)&gt;\tmouse_scrolled This function is called whenever the mouse wheel is scrolled. std::function&lt; void(Key)&gt;\tkey_pressed This function is called whenever a keyboard key is pressed. std::function&lt; void(Key)&gt;\tkey_released This function is called whenever a keyboard key is released. std::function&lt; void(Key)&gt;\tkey_repeated This function is called repeatedly whenever a keyboard key is held. std::function&lt; void(std::string &amp;&amp;)&gt;\ton_error This function is called whenever an error occurs. std::function&lt; void()&gt;\tmain_canvas_resized This function is called whenever the main canvas is resized. std::function&lt; void(Event)&gt;\ton_event This function is called whenever any event occurs (key pressed, mouse moved, etc.). "},{"title":"Detailed Description​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#detailed-description","content":"You can set those functions as you wish to react to various events. The simplest way is to use a lambda: auto ctx = p6::Context{}; ctx.mouse_pressed = [](p6::MouseButton) { std::cout &lt;&lt; &quot;Hello World\\n&quot;; };  "},{"title":"Attributes​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#attributes-1","content":""},{"title":"update​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#update","content":"std::function&lt; void()&gt; update = []() { };  This function is called repeatedly. The framerate is controlled by the framerate_xxx() functions. "},{"title":"imgui​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#imgui","content":"std::function&lt; void()&gt; imgui = []() { };  In this function you can call all the ImGui code you want. Note that you can also do it during the [update()](/reference/events#update) function. This [imgui()](/reference/events#imgui) function is just here to help you organize your code if you want to. "},{"title":"mouse_moved​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#mouse_moved","content":"std::function&lt; void(MouseMove)&gt; mouse_moved = [](MouseMove) { };  This function is called whenever the mouse is moved. "},{"title":"mouse_dragged​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#mouse_dragged","content":"std::function&lt; void(MouseDrag)&gt; mouse_dragged = [](MouseDrag) { };  This function is called whenever the mouse is dragged. "},{"title":"mouse_pressed​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#mouse_pressed","content":"std::function&lt; void(MouseButton)&gt; mouse_pressed = [](MouseButton) { };  This function is called whenever a mouse button is pressed. "},{"title":"mouse_released​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#mouse_released","content":"std::function&lt; void(MouseButton)&gt; mouse_released = [](MouseButton) { };  This function is called whenever a mouse button is released. "},{"title":"mouse_scrolled​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#mouse_scrolled","content":"std::function&lt; void(MouseScroll)&gt; mouse_scrolled = [](MouseScroll) { };  This function is called whenever the mouse wheel is scrolled. "},{"title":"key_pressed​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#key_pressed","content":"std::function&lt; void(Key)&gt; key_pressed = [](Key) { };  This function is called whenever a keyboard key is pressed. "},{"title":"key_released​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#key_released","content":"std::function&lt; void(Key)&gt; key_released = [](Key) { };  This function is called whenever a keyboard key is released. "},{"title":"key_repeated​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#key_repeated","content":"std::function&lt; void(Key)&gt; key_repeated = [](Key) { };  This function is called repeatedly whenever a keyboard key is held. (NB: this only starts after holding the key for a little while. The exact behaviour is OS-specific) ⚠️ This is less than ideal to do things like handling the movement of a character. You should rather do, in your update function: if (ctx.key_is_held(GLFW_KEY_W)) { character.move_forward(ctx.delta_time()); }  "},{"title":"on_error​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#on_error","content":"std::function&lt; void(std::string &amp;&amp;)&gt; on_error = [](std::string&amp;&amp; error_message) { std::cerr &lt;&lt; error_message &lt;&lt; '\\n'; throw std::runtime_error{error_message}; };  This function is called whenever an error occurs. "},{"title":"main_canvas_resized​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#main_canvas_resized","content":"std::function&lt; void()&gt; main_canvas_resized = []() { };  This function is called whenever the main canvas is resized. If you call main_canvas_size(), main_canvas_width(), main_canvas_height() or aspect_ratio() inside main_canvas_resized() they will already be referring to the new size. "},{"title":"on_event​","type":1,"pageTitle":"Events","url":"/p6-docs/reference/events#on_event","content":"std::function&lt; void(Event)&gt; on_event = [](Event const&amp;) { };  This function is called whenever any event occurs (key pressed, mouse moved, etc.). It can be useful to use this function instead of the more specific ones (key_pressed, mouse_moved, etc.) if for example you want to forward several events to a function that will handle them. For example in order to control a camera you might need to forward the key, mouse and update events to it. Instead of having to put the code inside those three event functions, you can just put it in on_event and let the camera handle each event as it so pleases.  Updated on 2023 March 02 "},{"title":"Drawing","type":0,"sectionRef":"#","url":"/p6-docs/reference/drawing","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#summary","content":""},{"title":"Functions​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#functions","content":"\tNamevoid\tbackground(Color color) Sets the color and alpha of each pixel of the canvas. void\tsquare(FullScreen ) Draws a square. void\tsquare(Center center = {}, Radius radius = {}, Rotation rotation = {}) void\tsquare(TopLeftCorner corner, Radius radius = {}, Rotation rotation = {}) void\tsquare(TopRightCorner corner, Radius radius = {}, Rotation rotation = {}) void\tsquare(BottomLeftCorner corner, Radius radius = {}, Rotation rotation = {}) void\tsquare(BottomRightCorner corner, Radius radius = {}, Rotation rotation = {}) void\trectangle(FullScreen = {}) Draws a rectangle. void\trectangle(Center center, Radii radii = {}, Rotation rotation = {}) void\trectangle(TopLeftCorner corner, Radii radii = {}, Rotation rotation = {}) void\trectangle(TopRightCorner corner, Radii radii = {}, Rotation rotation = {}) void\trectangle(BottomLeftCorner corner, Radii radii = {}, Rotation rotation = {}) void\trectangle(BottomRightCorner corner, Radii radii = {}, Rotation rotation = {}) void\trectangle(Transform2D transform) void\tcircle(FullScreen ) Draws a circle. void\tcircle(Center center = {}, Radius radius = {}) void\tellipse(FullScreen = {}) Draws an ellipse. void\tellipse(Center center, Radii radii = {}, Rotation rotation = {}) void\tellipse(Transform2D transform) void\tequilateral_triangle(Center center, Radius radius = {}, Rotation rotation = {}) Draws an equilateral triangle. [Radius](/reference/Types/radius) is the distance between the [Center](/reference/Types/center) and one of the tips of the triangle. void\ttriangle(Point2D p1, Point2D p2, Point2D p3, Center center = {}, Rotation rotation = {}) Draws a triangle between the three points, translated by [Center](/reference/Types/center) and rotated by Rotation. void\ttriangle(Point2D p1, Point2D p2, Point2D p3, Transform2D transform) Draws a triangle between the three points, and applies the transform to the triangle. void\timage(const ImageOrCanvas &amp; img, Fit = {}) Draws an image as big as possible on the screen. This will respect the aspect ratio of the image. void\timage(const ImageOrCanvas &amp; img, FitX ) void\timage(const ImageOrCanvas &amp; img, FitY ) void\timage(const ImageOrCanvas &amp; img, Center center, RadiusX radiusX = {}, Rotation rotation = {}) Draws an image. This will respect the aspect ratio of the image. void\timage(const ImageOrCanvas &amp; img, TopLeftCorner corner, RadiusX radiusX = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, TopRightCorner corner, RadiusX radiusX = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, BottomLeftCorner corner, RadiusX radiusX = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, BottomRightCorner corner, RadiusX radiusX = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, Center center, RadiusY radiusY = {}, Rotation rotation = {}) Draws an image. This will respect the aspect ratio of the image. void\timage(const ImageOrCanvas &amp; img, TopLeftCorner corner, RadiusY radiusY = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, TopRightCorner corner, RadiusY radiusY = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, BottomLeftCorner corner, RadiusY radiusY = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, BottomRightCorner corner, RadiusY radiusY = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, FullScreen ) Draws an image that takes the entire window. ⚠️ This might distort the image if the window doesn't have the same aspect ratio as the image. void\timage(const ImageOrCanvas &amp; img, Center center, Radii radii = {}, Rotation rotation = {}) Draws an image. ⚠️ This might distort the image if radii doesn't have the same aspect ratio as the image. void\timage(const ImageOrCanvas &amp; img, TopLeftCorner corner, Radii radii = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, TopRightCorner corner, Radii radii = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, BottomLeftCorner corner, Radii radii = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, BottomRightCorner corner, Radii radii = {}, Rotation rotation = {}) void\timage(const ImageOrCanvas &amp; img, Transform2D transform) void\trectangle_with_shader(const Shader &amp; shader, FullScreen = {}) Draws a rectangle using a custom fragment shader. void\trectangle_with_shader(const Shader &amp; shader, Center center, Radii radii = {}, Rotation rotation = {}) void\trectangle_with_shader(const Shader &amp; shader, TopLeftCorner corner, Radii radii = {}, Rotation rotation = {}) void\trectangle_with_shader(const Shader &amp; shader, TopRightCorner corner, Radii radii = {}, Rotation rotation = {}) void\trectangle_with_shader(const Shader &amp; shader, BottomLeftCorner corner, Radii radii = {}, Rotation rotation = {}) void\trectangle_with_shader(const Shader &amp; shader, BottomRightCorner corner, Radii radii = {}, Rotation rotation = {}) void\tsquare_with_shader(const Shader &amp; shader, Center center = {}, Radius radius = {}, Rotation rotation = {}) void\tsquare_with_shader(const Shader &amp; shader, TopLeftCorner corner, Radius radius = {}, Rotation rotation = {}) void\tsquare_with_shader(const Shader &amp; shader, TopRightCorner corner, Radius radius = {}, Rotation rotation = {}) void\tsquare_with_shader(const Shader &amp; shader, BottomLeftCorner corner, Radius radius = {}, Rotation rotation = {}) void\tsquare_with_shader(const Shader &amp; shader, BottomRightCorner corner, Radius radius = {}, Rotation rotation = {}) void\trectangle_with_shader(const Shader &amp; shader, Transform2D transform) void\tline(glm::vec2 start, glm::vec2 end) Draws a line between two points. "},{"title":"Attributes​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#attributes","content":"\tNameColor\tfill The color that is used for the interior of the shapes. bool\tuse_fill Whether the shapes will have an interior. Color\tstroke The color that is used for the boundary of the shapes. float\tstroke_weight The size of the boundary of the shapes. bool\tuse_stroke Whether there will be a boundary on the shape. "},{"title":"Functions​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#functions-1","content":""},{"title":"background()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#background","content":"void background(Color color); Sets the color and alpha of each pixel of the canvas. NB: No blending is applied; even if you specify an alpha of 0.5 the old canvas is completely erased. This means that setting an alpha here doesn't matter much. It is only meaningful if you export the canvas as a png, or if you later try to blend the canvas on top of another image. "},{"title":"square()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#square","content":"void square(FullScreen ); Draws a square. "},{"title":"square()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#square-1","content":"void square(Center center ={}, Radius radius ={}, Rotation rotation ={}); "},{"title":"square()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#square-2","content":"void square(TopLeftCorner corner, Radius radius ={}, Rotation rotation ={}); "},{"title":"square()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#square-3","content":"void square(TopRightCorner corner, Radius radius ={}, Rotation rotation ={}); "},{"title":"square()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#square-4","content":"void square(BottomLeftCorner corner, Radius radius ={}, Rotation rotation ={}); "},{"title":"square()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#square-5","content":"void square(BottomRightCorner corner, Radius radius ={}, Rotation rotation ={}); "},{"title":"rectangle()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#rectangle","content":"void rectangle(FullScreen ={}); Draws a rectangle. "},{"title":"rectangle()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#rectangle-1","content":"void rectangle(Center center, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#rectangle-2","content":"void rectangle(TopLeftCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#rectangle-3","content":"void rectangle(TopRightCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#rectangle-4","content":"void rectangle(BottomLeftCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#rectangle-5","content":"void rectangle(BottomRightCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#rectangle-6","content":"void rectangle(Transform2D transform); "},{"title":"circle()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#circle","content":"void circle(FullScreen ); Draws a circle. "},{"title":"circle()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#circle-1","content":"void circle(Center center ={}, Radius radius ={}); "},{"title":"ellipse()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#ellipse","content":"void ellipse(FullScreen ={}); Draws an ellipse. "},{"title":"ellipse()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#ellipse-1","content":"void ellipse(Center center, Radii radii ={}, Rotation rotation ={}); "},{"title":"ellipse()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#ellipse-2","content":"void ellipse(Transform2D transform); "},{"title":"equilateral_triangle()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#equilateral_triangle","content":"void equilateral_triangle(Center center, Radius radius ={}, Rotation rotation ={}); Draws an equilateral triangle. [Radius](/reference/Types/radius) is the distance between the [Center](/reference/Types/center) and one of the tips of the triangle. "},{"title":"triangle()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#triangle","content":"void triangle(Point2D p1, Point2D p2, Point2D p3, Center center ={}, Rotation rotation ={}); Draws a triangle between the three points, translated by [Center](/reference/Types/center) and rotated by Rotation. "},{"title":"triangle()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#triangle-1","content":"void triangle(Point2D p1, Point2D p2, Point2D p3, Transform2D transform); Draws a triangle between the three points, and applies the transform to the triangle. "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image","content":"void image(const ImageOrCanvas &amp; img, Fit ={}); Draws an image as big as possible on the screen. This will respect the aspect ratio of the image. "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-1","content":"void image(const ImageOrCanvas &amp; img, FitX ); "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-2","content":"void image(const ImageOrCanvas &amp; img, FitY ); "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-3","content":"void image(const ImageOrCanvas &amp; img, Center center, RadiusX radiusX ={}, Rotation rotation ={}); Draws an image. This will respect the aspect ratio of the image. "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-4","content":"void image(const ImageOrCanvas &amp; img, TopLeftCorner corner, RadiusX radiusX ={}, Rotation rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-5","content":"void image(const ImageOrCanvas &amp; img, TopRightCorner corner, RadiusX radiusX ={}, Rotation rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-6","content":"void image(const ImageOrCanvas &amp; img, BottomLeftCorner corner, RadiusX radiusX ={}, Rotation rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-7","content":"void image(const ImageOrCanvas &amp; img, BottomRightCorner corner, RadiusX radiusX ={}, Rotation rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-8","content":"void image(const ImageOrCanvas &amp; img, Center center, RadiusY radiusY ={}, Rotation rotation ={}); Draws an image. This will respect the aspect ratio of the image. "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-9","content":"void image(const ImageOrCanvas &amp; img, TopLeftCorner corner, RadiusY radiusY ={}, Rotation rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-10","content":"void image(const ImageOrCanvas &amp; img, TopRightCorner corner, RadiusY radiusY ={}, Rotation rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-11","content":"void image(const ImageOrCanvas &amp; img, BottomLeftCorner corner, RadiusY radiusY ={}, Rotation rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-12","content":"void image(const ImageOrCanvas &amp; img, BottomRightCorner corner, RadiusY radiusY ={}, Rotation rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-13","content":"void image(const ImageOrCanvas &amp; img, FullScreen ); Draws an image that takes the entire window. ⚠️ This might distort the image if the window doesn't have the same aspect ratio as the image. "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-14","content":"void image(const ImageOrCanvas &amp; img, Center center, Radii radii ={}, Rotation rotation ={}); Draws an image. ⚠️ This might distort the image if radii doesn't have the same aspect ratio as the image. "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-15","content":"void image(const ImageOrCanvas &amp; img, TopLeftCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-16","content":"void image(const ImageOrCanvas &amp; img, TopRightCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-17","content":"void image(const ImageOrCanvas &amp; img, BottomLeftCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-18","content":"void image(const ImageOrCanvas &amp; img, BottomRightCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#image-19","content":"void image(const ImageOrCanvas &amp; img, Transform2D transform); "},{"title":"rectangle_with_shader()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#rectangle_with_shader","content":"void rectangle_with_shader(const Shader &amp; shader, FullScreen ={}); Draws a rectangle using a custom fragment shader. "},{"title":"rectangle_with_shader()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#rectangle_with_shader-1","content":"void rectangle_with_shader(const Shader &amp; shader, Center center, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle_with_shader()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#rectangle_with_shader-2","content":"void rectangle_with_shader(const Shader &amp; shader, TopLeftCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle_with_shader()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#rectangle_with_shader-3","content":"void rectangle_with_shader(const Shader &amp; shader, TopRightCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle_with_shader()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#rectangle_with_shader-4","content":"void rectangle_with_shader(const Shader &amp; shader, BottomLeftCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"rectangle_with_shader()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#rectangle_with_shader-5","content":"void rectangle_with_shader(const Shader &amp; shader, BottomRightCorner corner, Radii radii ={}, Rotation rotation ={}); "},{"title":"square_with_shader()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#square_with_shader","content":"void square_with_shader(const Shader &amp; shader, Center center ={}, Radius radius ={}, Rotation rotation ={}); "},{"title":"square_with_shader()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#square_with_shader-1","content":"void square_with_shader(const Shader &amp; shader, TopLeftCorner corner, Radius radius ={}, Rotation rotation ={}); "},{"title":"square_with_shader()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#square_with_shader-2","content":"void square_with_shader(const Shader &amp; shader, TopRightCorner corner, Radius radius ={}, Rotation rotation ={}); "},{"title":"square_with_shader()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#square_with_shader-3","content":"void square_with_shader(const Shader &amp; shader, BottomLeftCorner corner, Radius radius ={}, Rotation rotation ={}); "},{"title":"square_with_shader()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#square_with_shader-4","content":"void square_with_shader(const Shader &amp; shader, BottomRightCorner corner, Radius radius ={}, Rotation rotation ={}); "},{"title":"rectangle_with_shader()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#rectangle_with_shader-6","content":"void rectangle_with_shader(const Shader &amp; shader, Transform2D transform); "},{"title":"line()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#line","content":"void line(glm::vec2 start, glm::vec2 end); Draws a line between two points. It uses the stroke color, and stroke_weight as its thickness. "},{"title":"Attributes​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#attributes-1","content":""},{"title":"fill​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#fill","content":"Color fill {1.f, 1.f, 1.f, 0.5f};  The color that is used for the interior of the shapes. "},{"title":"use_fill​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#use_fill","content":"bool use_fill = true;  Whether the shapes will have an interior. "},{"title":"stroke​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#stroke","content":"Color stroke {0.f, 0.f, 0.f};  The color that is used for the boundary of the shapes. "},{"title":"stroke_weight​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#stroke_weight","content":"float stroke_weight = 0.01f;  The size of the boundary of the shapes. "},{"title":"use_stroke​","type":1,"pageTitle":"Drawing","url":"/p6-docs/reference/drawing#use_stroke","content":"bool use_stroke = true;  Whether there will be a boundary on the shape.  Updated on 2023 March 02 "},{"title":"Image","type":0,"sectionRef":"#","url":"/p6-docs/reference/image","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"Image","url":"/p6-docs/reference/image#summary","content":""},{"title":"Classes​","type":1,"pageTitle":"Image","url":"/p6-docs/reference/image#classes","content":"\tNameclass\tp6::Image "},{"title":"Functions​","type":1,"pageTitle":"Image","url":"/p6-docs/reference/image#functions","content":"\tNameImage\tload_image(std::filesystem::path file_path) Loads an image from a file. img::Image\tload_image_buffer(std::filesystem::path file_path) For advanced uses only. "},{"title":"Functions​","type":1,"pageTitle":"Image","url":"/p6-docs/reference/image#functions-1","content":""},{"title":"load_image()​","type":1,"pageTitle":"Image","url":"/p6-docs/reference/image#load_image","content":"Image load_image(std::filesystem::path file_path); Loads an image from a file. If the path is relative, it will be relative to the directory containing your executable. Throws a std::runtime_error if the file doesn't exist or isn't a valid image file. "},{"title":"load_image_buffer()​","type":1,"pageTitle":"Image","url":"/p6-docs/reference/image#load_image_buffer","content":"img::Image load_image_buffer(std::filesystem::path file_path); For advanced uses only. Loads an image from a file and returns the buffer of pixels and the size. If the path is relative, it will be relative to the directory containing your executable. Throws a std::runtime_error if the file doesn't exist or isn't a valid image file.  Updated on 2023 March 02 "},{"title":"Math","type":0,"sectionRef":"#","url":"/p6-docs/reference/math","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"Math","url":"/p6-docs/reference/math#summary","content":""},{"title":"Functions​","type":1,"pageTitle":"Math","url":"/p6-docs/reference/math#functions","content":"\tNametemplate &lt;typename T &gt; T\tmap(T x, T from_min, T from_max, T to_min, T to_max) Maps x, which is in the range [from_min, from_max] to the range [to_min, to_max]. glm::vec2\trotated_by(Angle angle, glm::vec2 vector) Returns a new vector equal to vector rotated by angle "},{"title":"Attributes​","type":1,"pageTitle":"Math","url":"/p6-docs/reference/math#attributes","content":"\tNameconstexpr float\tTAU constexpr float\tPI "},{"title":"Functions​","type":1,"pageTitle":"Math","url":"/p6-docs/reference/math#functions-1","content":""},{"title":"map()​","type":1,"pageTitle":"Math","url":"/p6-docs/reference/math#map","content":"T map(T x, T from_min, T from_max, T to_min, T to_max); Maps x, which is in the range [from_min, from_max] to the range [to_min, to_max]. For example if x == from_min then the function returns to_min. If x == (from_min + from_max) / 2 then the function returns (to_min + to_max) / 2. If x is outside of the range [from_min, from_max] the result will be outside of [to_min, to_max], the same linear behaviour still applies. "},{"title":"rotated_by()​","type":1,"pageTitle":"Math","url":"/p6-docs/reference/math#rotated_by","content":"glm::vec2 rotated_by(Angle angle, glm::vec2 vector); Returns a new vector equal to vector rotated by angle "},{"title":"Attributes​","type":1,"pageTitle":"Math","url":"/p6-docs/reference/math#attributes-1","content":""},{"title":"TAU​","type":1,"pageTitle":"Math","url":"/p6-docs/reference/math#tau","content":"static constexpr float TAU = 6.2831853f;  "},{"title":"PI​","type":1,"pageTitle":"Math","url":"/p6-docs/reference/math#pi","content":"static constexpr float PI = TAU / 2.f;   Updated on 2023 March 02 "},{"title":"Input","type":0,"sectionRef":"#","url":"/p6-docs/reference/input","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"Input","url":"/p6-docs/reference/input#summary","content":""},{"title":"Functions​","type":1,"pageTitle":"Input","url":"/p6-docs/reference/input#functions","content":"\tNameglm::vec2\tmouse() const Returns the current mouse position. glm::vec2\tmouse_delta() const Returns the movement of the mouse since last update(). bool\tmouse_is_in_window() const Returns true iff the window is focused and the coordinates returned by mouse() correspond to a position inside the window. bool\tmouse_button_is_pressed(Button button) const Returns true iff the given mouse button is currently pressed. bool\tctrl() const Returns true iff the CTRL key is pressed (or CMD on Mac) bool\tshift() const Returns true iff the SHIFT key is pressed. bool\talt() const Returns true iff the ALT key is pressed. bool\tkey_is_pressed(int key) const Returns true iff the given key is currently pressed. "},{"title":"Functions​","type":1,"pageTitle":"Input","url":"/p6-docs/reference/input#functions-1","content":""},{"title":"mouse()​","type":1,"pageTitle":"Input","url":"/p6-docs/reference/input#mouse","content":"glm::vec2 mouse() const; Returns the current mouse position. "},{"title":"mouse_delta()​","type":1,"pageTitle":"Input","url":"/p6-docs/reference/input#mouse_delta","content":"glm::vec2 mouse_delta() const; Returns the movement of the mouse since last update(). "},{"title":"mouse_is_in_window()​","type":1,"pageTitle":"Input","url":"/p6-docs/reference/input#mouse_is_in_window","content":"bool mouse_is_in_window() const; Returns true iff the window is focused and the coordinates returned by mouse() correspond to a position inside the window. "},{"title":"mouse_button_is_pressed()​","type":1,"pageTitle":"Input","url":"/p6-docs/reference/input#mouse_button_is_pressed","content":"bool mouse_button_is_pressed(Button button) const; Returns true iff the given mouse button is currently pressed. "},{"title":"ctrl()​","type":1,"pageTitle":"Input","url":"/p6-docs/reference/input#ctrl","content":"bool ctrl() const; Returns true iff the CTRL key is pressed (or CMD on Mac) "},{"title":"shift()​","type":1,"pageTitle":"Input","url":"/p6-docs/reference/input#shift","content":"bool shift() const; Returns true iff the SHIFT key is pressed. "},{"title":"alt()​","type":1,"pageTitle":"Input","url":"/p6-docs/reference/input#alt","content":"bool alt() const; Returns true iff the ALT key is pressed. "},{"title":"key_is_pressed()​","type":1,"pageTitle":"Input","url":"/p6-docs/reference/input#key_is_pressed","content":"bool key_is_pressed(int key) const; Returns true iff the given key is currently pressed. key should be a GLFWKEY value. See https://www.glfw.org/docs/3.3/keys.html for the complete list. e.g. ctx.key_is_pressed(GLFW_KEY_Q) /!\\ Please note that these are physical keys that don't depend on the current layout. This means that GLFW_KEY_Q will refer to the first key on your keyboard, no matter if you are using QWERTY or AZERTY.  Updated on 2023 March 02 "},{"title":"Random","type":0,"sectionRef":"#","url":"/p6-docs/reference/random","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#summary","content":""},{"title":"Functions​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#functions","content":"\tNamefloat\tnumber() Returns a random number between 0 and 1. float\tnumber(float max) Returns a random number between 0 and max. float\tnumber(float min, float max) Returns a random number between min and max. int\tinteger(int max) Returns a random integer between 0 (included) and max (excluded). int\tinteger(int min, int max) Returns a random integer between min (included) and max (excluded). size_t\tsize_type(size_t max) Returns a random size_t between 0 (included) and max (excluded). size_t\tsize_type(size_t min, size_t max) Returns a random size_t between min (included) and max (excluded). template &lt;typename T &gt; const T &amp;\tamong(const std::vector&lt; T &gt; &amp; collection) Randomly returns one of the elements of the collection. glm::vec2\tpoint(const [p6::Context](/reference/Types/context) &amp; ctx) Returns a point inside the main canvas of the context. glm::vec2\tpoint(const [p6::Canvas](/reference/Types/canvas) &amp; canvas) Returns a point inside the given canvas. glm::vec2\tpoint() Returns a random point in a square between (-1, -1) and (1, 1). glm::vec2\tpoint(glm::vec2 min, glm::vec2 max) Returns a random point in a rectangle between min and max. glm::vec2\tpoint(float aspect_ratio) Returns a random point in a rectangle between (-aspect_ratio, -1) and (aspect_ratio, 1). glm::vec2\tdirection() Returns a random direction (vector of length 1). Angle\tangle() Returns a random angle. "},{"title":"Functions​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#functions-1","content":""},{"title":"number()​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#number","content":"float number(); Returns a random number between 0 and 1. "},{"title":"number()​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#number-1","content":"float number(float max); Returns a random number between 0 and max. Throws a std::invalid_argument exception if max &lt; 0. "},{"title":"number()​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#number-2","content":"float number(float min, float max); Returns a random number between min and max. Throws a std::invalid_argument exception if min &gt; max. "},{"title":"integer()​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#integer","content":"int integer(int max); Returns a random integer between 0 (included) and max (excluded). Throws a std::invalid_argument exception if max &lt;= 0. "},{"title":"integer()​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#integer-1","content":"int integer(int min, int max); Returns a random integer between min (included) and max (excluded). Throws a std::invalid_argument exception if min &gt;= max. "},{"title":"size_type()​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#size_type","content":"size_t size_type(size_t max); Returns a random size_t between 0 (included) and max (excluded). "},{"title":"size_type()​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#size_type-1","content":"size_t size_type(size_t min, size_t max); Returns a random size_t between min (included) and max (excluded). Throws a std::invalid_argument exception if min &gt;= max. "},{"title":"among()​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#among","content":"const T &amp; among(const std::vector&lt; T &gt; &amp; collection); Randomly returns one of the elements of the collection. Throws a std::invalid_argument exception if the collection is empty. "},{"title":"point()​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#point","content":"glm::vec2 point(const [p6::Context](/reference/Types/context) &amp; ctx); Returns a point inside the main canvas of the context. "},{"title":"point()​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#point-1","content":"glm::vec2 point(const [p6::Canvas](/reference/Types/canvas) &amp; canvas); Returns a point inside the given canvas. "},{"title":"point()​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#point-2","content":"glm::vec2 point(); Returns a random point in a square between (-1, -1) and (1, 1). "},{"title":"point()​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#point-3","content":"glm::vec2 point(glm::vec2 min, glm::vec2 max); Returns a random point in a rectangle between min and max. Throws a std::invalid_argument exception if min.x &gt; max.x || min.y &gt; max.y. "},{"title":"point()​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#point-4","content":"glm::vec2 point(float aspect_ratio); Returns a random point in a rectangle between (-aspect_ratio, -1) and (aspect_ratio, 1). "},{"title":"direction()​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#direction","content":"glm::vec2 direction(); Returns a random direction (vector of length 1). "},{"title":"angle()​","type":1,"pageTitle":"Random","url":"/p6-docs/reference/random#angle","content":"Angle angle(); Returns a random angle.  Updated on 2023 March 02 "},{"title":"Text","type":0,"sectionRef":"#","url":"/p6-docs/reference/text","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"Text","url":"/p6-docs/reference/text#summary","content":""},{"title":"Functions​","type":1,"pageTitle":"Text","url":"/p6-docs/reference/text#functions","content":"\tNamevoid\ttext(const std::u16string &amp; str, Center center, Rotation rotation = {}) void\ttext(const std::u16string &amp; str, TopLeftCorner corner, Rotation rotation = {}) void\ttext(const std::u16string &amp; str, TopRightCorner corner, Rotation rotation = {}) void\ttext(const std::u16string &amp; str, BottomLeftCorner corner, Rotation rotation = {}) void\ttext(const std::u16string &amp; str, BottomRightCorner corner, Rotation rotation = {}) "},{"title":"Attributes​","type":1,"pageTitle":"Text","url":"/p6-docs/reference/text#attributes","content":"\tNamefloat\ttext_size Height of the text. float\ttext_inflating Gives some &quot;boldness&quot; to the text. "},{"title":"Functions​","type":1,"pageTitle":"Text","url":"/p6-docs/reference/text#functions-1","content":""},{"title":"text()​","type":1,"pageTitle":"Text","url":"/p6-docs/reference/text#text-1","content":"void text(const std::u16string &amp; str, Center center, Rotation rotation ={}); "},{"title":"text()​","type":1,"pageTitle":"Text","url":"/p6-docs/reference/text#text-2","content":"void text(const std::u16string &amp; str, TopLeftCorner corner, Rotation rotation ={}); "},{"title":"text()​","type":1,"pageTitle":"Text","url":"/p6-docs/reference/text#text-3","content":"void text(const std::u16string &amp; str, TopRightCorner corner, Rotation rotation ={}); "},{"title":"text()​","type":1,"pageTitle":"Text","url":"/p6-docs/reference/text#text-4","content":"void text(const std::u16string &amp; str, BottomLeftCorner corner, Rotation rotation ={}); "},{"title":"text()​","type":1,"pageTitle":"Text","url":"/p6-docs/reference/text#text-5","content":"void text(const std::u16string &amp; str, BottomRightCorner corner, Rotation rotation ={}); "},{"title":"Attributes​","type":1,"pageTitle":"Text","url":"/p6-docs/reference/text#attributes-1","content":""},{"title":"text_size​","type":1,"pageTitle":"Text","url":"/p6-docs/reference/text#text_size","content":"float text_size = 0.03f;  Height of the text. "},{"title":"text_inflating​","type":1,"pageTitle":"Text","url":"/p6-docs/reference/text#text_inflating","content":"float text_inflating = 0.01f;  Gives some &quot;boldness&quot; to the text.  Updated on 2023 March 02 "},{"title":"Time","type":0,"sectionRef":"#","url":"/p6-docs/reference/time","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"Time","url":"/p6-docs/reference/time#summary","content":""},{"title":"Functions​","type":1,"pageTitle":"Time","url":"/p6-docs/reference/time#functions","content":"\tNamefloat\ttime() const Returns the time in seconds since the creation of the Context. float\tdelta_time() const Returns an estimate of the time that elapses between two update() calls. void\ttime_perceived_as_realtime() Sets the time mode as realtime. void\ttime_perceived_as_constant_delta_time(float framerate) Sets the time mode as constant delta time. void\tframerate_synced_with_monitor() Makes sure that the framerate is adapted to your monitor: it will be 60 fps if you have a 60 Hertz monitor (which is the most common), or 120 fps if you have a 120 Hertz monitor, etc. void\tframerate_as_high_as_possible() Removes any limit on the framerate. update() will be called as fast as possible. void\tframerate_capped_at(float framerate) Keeps the framerate at the given value. "},{"title":"Functions​","type":1,"pageTitle":"Time","url":"/p6-docs/reference/time#functions-1","content":""},{"title":"time()​","type":1,"pageTitle":"Time","url":"/p6-docs/reference/time#time-1","content":"float time() const; Returns the time in seconds since the creation of the Context. "},{"title":"delta_time()​","type":1,"pageTitle":"Time","url":"/p6-docs/reference/time#delta_time","content":"float delta_time() const; Returns an estimate of the time that elapses between two update() calls. "},{"title":"time_perceived_as_realtime()​","type":1,"pageTitle":"Time","url":"/p6-docs/reference/time#time_perceived_as_realtime","content":"void time_perceived_as_realtime(); Sets the time mode as realtime. This means that what is returned by time() and delta_time() corresponds to the actual time that elapsed in the real world. This is ideal when you want to do realtime animation and interactive sketches. "},{"title":"time_perceived_as_constant_delta_time()​","type":1,"pageTitle":"Time","url":"/p6-docs/reference/time#time_perceived_as_constant_delta_time","content":"void time_perceived_as_constant_delta_time(float framerate); Sets the time mode as constant delta time. This means that what is returned by time() and delta_time() corresponds to an ideal world where there is exactly 1/framerate seconds between each updates. This is ideal when you are exporting a video and don't want the long export time to influence your animation. framerate is expressed in frames per second "},{"title":"framerate_synced_with_monitor()​","type":1,"pageTitle":"Time","url":"/p6-docs/reference/time#framerate_synced_with_monitor","content":"void framerate_synced_with_monitor(); Makes sure that the framerate is adapted to your monitor: it will be 60 fps if you have a 60 Hertz monitor (which is the most common), or 120 fps if you have a 120 Hertz monitor, etc. This is the default framerate mode. "},{"title":"framerate_as_high_as_possible()​","type":1,"pageTitle":"Time","url":"/p6-docs/reference/time#framerate_as_high_as_possible","content":"void framerate_as_high_as_possible(); Removes any limit on the framerate. update() will be called as fast as possible. "},{"title":"framerate_capped_at()​","type":1,"pageTitle":"Time","url":"/p6-docs/reference/time#framerate_capped_at","content":"void framerate_capped_at(float framerate); Keeps the framerate at the given value.  Updated on 2023 March 02 "},{"title":"Transform","type":0,"sectionRef":"#","url":"/p6-docs/reference/transform","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"Transform","url":"/p6-docs/reference/transform#summary","content":""},{"title":"Functions​","type":1,"pageTitle":"Transform","url":"/p6-docs/reference/transform#functions","content":"\tNamevoid\ttranslate(glm::vec2 translation) Applies a translation to all the future drawings. To undo this, see [push_transform()](/reference/transform#push_transform) and [pop_transform()](/reference/transform#pop_transform). void\trotate([p6::Angle](/reference/Types/angle) angle) Applies a rotation to all the future drawings. To undo this, see [push_transform()](/reference/transform#push_transform) and [pop_transform()](/reference/transform#pop_transform). void\tscale(glm::vec2 scale_factor) Applies a scale to all the future drawings. To undo this, see [push_transform()](/reference/transform#push_transform) and [pop_transform()](/reference/transform#pop_transform). void\treset_transform() Undoes all the translate / rotate / scale / apply_transform / set_transform. void\tapply_transform(glm::mat3 additional_transform) Applies a custom transform matrix to all the future drawings. To undo this, see [push_transform()](/reference/transform#push_transform) and [pop_transform()](/reference/transform#pop_transform). void\tset_transform(glm::mat3 transform) Sets the current transform matrix. This will override all the previous translate / rotate / scale / apply_transform. To undo this, see [push_transform()](/reference/transform#push_transform) and [pop_transform()](/reference/transform#pop_transform). void\tpush_transform() Saves the current transform state. void\tpop_transform() Restores the transform to the state it had during the last [push_transform()](/reference/transform#push_transform) that has not been popped yet. TransformScopeGuard\ttransform_scope_guard() Will call push_transform() and pop_transform() automatically. glm::mat3\tcurrent_transform() const Returns the current transform matrix that is the combination of all the translate / rotate / scale / apply_transform / set_transform that have been applied. "},{"title":"Functions​","type":1,"pageTitle":"Transform","url":"/p6-docs/reference/transform#functions-1","content":""},{"title":"translate()​","type":1,"pageTitle":"Transform","url":"/p6-docs/reference/transform#translate","content":"void translate(glm::vec2 translation); Applies a translation to all the future drawings. To undo this, see [push_transform()](/reference/transform#push_transform) and [pop_transform()](/reference/transform#pop_transform). "},{"title":"rotate()​","type":1,"pageTitle":"Transform","url":"/p6-docs/reference/transform#rotate","content":"void rotate([p6::Angle](/reference/Types/angle) angle); Applies a rotation to all the future drawings. To undo this, see [push_transform()](/reference/transform#push_transform) and [pop_transform()](/reference/transform#pop_transform). "},{"title":"scale()​","type":1,"pageTitle":"Transform","url":"/p6-docs/reference/transform#scale","content":"void scale(glm::vec2 scale_factor); Applies a scale to all the future drawings. To undo this, see [push_transform()](/reference/transform#push_transform) and [pop_transform()](/reference/transform#pop_transform). "},{"title":"reset_transform()​","type":1,"pageTitle":"Transform","url":"/p6-docs/reference/transform#reset_transform","content":"void reset_transform(); Undoes all the translate / rotate / scale / apply_transform / set_transform. "},{"title":"apply_transform()​","type":1,"pageTitle":"Transform","url":"/p6-docs/reference/transform#apply_transform","content":"void apply_transform(glm::mat3 additional_transform); Applies a custom transform matrix to all the future drawings. To undo this, see [push_transform()](/reference/transform#push_transform) and [pop_transform()](/reference/transform#pop_transform). "},{"title":"set_transform()​","type":1,"pageTitle":"Transform","url":"/p6-docs/reference/transform#set_transform","content":"void set_transform(glm::mat3 transform); Sets the current transform matrix. This will override all the previous translate / rotate / scale / apply_transform. To undo this, see [push_transform()](/reference/transform#push_transform) and [pop_transform()](/reference/transform#pop_transform). "},{"title":"push_transform()​","type":1,"pageTitle":"Transform","url":"/p6-docs/reference/transform#push_transform","content":"void push_transform(); Saves the current transform state. "},{"title":"pop_transform()​","type":1,"pageTitle":"Transform","url":"/p6-docs/reference/transform#pop_transform","content":"void pop_transform(); Restores the transform to the state it had during the last [push_transform()](/reference/transform#push_transform) that has not been popped yet. "},{"title":"transform_scope_guard()​","type":1,"pageTitle":"Transform","url":"/p6-docs/reference/transform#transform_scope_guard","content":"TransformScopeGuard transform_scope_guard(); Will call push_transform() and pop_transform() automatically. Assign the result of this function to a variable and pop_transform() will be called when the variable goes out of scope. push_transform() is called when transform_scope_guard() is called. "},{"title":"current_transform()​","type":1,"pageTitle":"Transform","url":"/p6-docs/reference/transform#current_transform","content":"glm::mat3 current_transform() const; Returns the current transform matrix that is the combination of all the translate / rotate / scale / apply_transform / set_transform that have been applied.  Updated on 2023 March 02 "},{"title":"p6::Angle","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/angle","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Angle","url":"/p6-docs/reference/Types/angle#summary","content":"\tNameconstexpr\tAngle() =default constexpr\tAngle([Radians](/reference/Types/radians) value) constexpr\tAngle(glm::vec2 direction) Constructs the angle that direction makes with the positive x axis. float\tas_turns() const float\tas_radians() const float\tas_degrees() const Radians\tvalue "},{"title":"Details​","type":1,"pageTitle":"p6::Angle","url":"/p6-docs/reference/Types/angle#details","content":""},{"title":"Angle()​","type":1,"pageTitle":"p6::Angle","url":"/p6-docs/reference/Types/angle#angle","content":"constexpr Angle() =default; "},{"title":"Angle()​","type":1,"pageTitle":"p6::Angle","url":"/p6-docs/reference/Types/angle#angle-1","content":"constexpr Angle([Radians](/reference/Types/radians) value); "},{"title":"Angle()​","type":1,"pageTitle":"p6::Angle","url":"/p6-docs/reference/Types/angle#angle-2","content":"constexpr Angle(glm::vec2 direction); Constructs the angle that direction makes with the positive x axis. direction does not need to be normalized. "},{"title":"as_turns()​","type":1,"pageTitle":"p6::Angle","url":"/p6-docs/reference/Types/angle#as_turns","content":"float as_turns() const; "},{"title":"as_radians()​","type":1,"pageTitle":"p6::Angle","url":"/p6-docs/reference/Types/angle#as_radians","content":"float as_radians() const; "},{"title":"as_degrees()​","type":1,"pageTitle":"p6::Angle","url":"/p6-docs/reference/Types/angle#as_degrees","content":"float as_degrees() const; "},{"title":"value​","type":1,"pageTitle":"p6::Angle","url":"/p6-docs/reference/Types/angle#value","content":"Radians value {};   Updated on 2023 March 02 "},{"title":"p6::BottomLeftCorner","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/bottom_left_corner","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::BottomLeftCorner","url":"/p6-docs/reference/Types/bottom_left_corner#summary","content":"\tName\tBottomLeftCorner() =default BottomLeftCorner(float x, float y) BottomLeftCorner(glm::vec2 value) glm::vec2\tvalue "},{"title":"Details​","type":1,"pageTitle":"p6::BottomLeftCorner","url":"/p6-docs/reference/Types/bottom_left_corner#details","content":""},{"title":"BottomLeftCorner()​","type":1,"pageTitle":"p6::BottomLeftCorner","url":"/p6-docs/reference/Types/bottom_left_corner#bottomleftcorner","content":"BottomLeftCorner() =default; "},{"title":"BottomLeftCorner()​","type":1,"pageTitle":"p6::BottomLeftCorner","url":"/p6-docs/reference/Types/bottom_left_corner#bottomleftcorner-1","content":"BottomLeftCorner(float x, float y); "},{"title":"BottomLeftCorner()​","type":1,"pageTitle":"p6::BottomLeftCorner","url":"/p6-docs/reference/Types/bottom_left_corner#bottomleftcorner-2","content":"BottomLeftCorner(glm::vec2 value); "},{"title":"value​","type":1,"pageTitle":"p6::BottomLeftCorner","url":"/p6-docs/reference/Types/bottom_left_corner#value","content":"glm::vec2 value {0.f};   Updated on 2023 March 02 "},{"title":"p6::BottomRightCorner","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/bottom_right_corner","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::BottomRightCorner","url":"/p6-docs/reference/Types/bottom_right_corner#summary","content":"\tName\tBottomRightCorner() =default BottomRightCorner(float x, float y) BottomRightCorner(glm::vec2 value) glm::vec2\tvalue "},{"title":"Details​","type":1,"pageTitle":"p6::BottomRightCorner","url":"/p6-docs/reference/Types/bottom_right_corner#details","content":""},{"title":"BottomRightCorner()​","type":1,"pageTitle":"p6::BottomRightCorner","url":"/p6-docs/reference/Types/bottom_right_corner#bottomrightcorner","content":"BottomRightCorner() =default; "},{"title":"BottomRightCorner()​","type":1,"pageTitle":"p6::BottomRightCorner","url":"/p6-docs/reference/Types/bottom_right_corner#bottomrightcorner-1","content":"BottomRightCorner(float x, float y); "},{"title":"BottomRightCorner()​","type":1,"pageTitle":"p6::BottomRightCorner","url":"/p6-docs/reference/Types/bottom_right_corner#bottomrightcorner-2","content":"BottomRightCorner(glm::vec2 value); "},{"title":"value​","type":1,"pageTitle":"p6::BottomRightCorner","url":"/p6-docs/reference/Types/bottom_right_corner#value","content":"glm::vec2 value {0.f};   Updated on 2023 March 02 "},{"title":"p6::CanvasSizeMode_FixedAspectRatio","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/canvas_size_mode___fixed_aspect_ratio","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::CanvasSizeMode_FixedAspectRatio","url":"/p6-docs/reference/Types/canvas_size_mode___fixed_aspect_ratio#summary","content":"\tNamefloat\taspect_ratio "},{"title":"Details​","type":1,"pageTitle":"p6::CanvasSizeMode_FixedAspectRatio","url":"/p6-docs/reference/Types/canvas_size_mode___fixed_aspect_ratio#details","content":""},{"title":"aspect_ratio​","type":1,"pageTitle":"p6::CanvasSizeMode_FixedAspectRatio","url":"/p6-docs/reference/Types/canvas_size_mode___fixed_aspect_ratio#aspect_ratio","content":"float aspect_ratio;   Updated on 2023 March 02 "},{"title":"p6::Canvas","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/canvas","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Canvas","url":"/p6-docs/reference/Types/canvas#summary","content":"\tName\tCanvas(ImageSize size, glpp::TextureLayout texture_layout = {glpp::InternalFormat::RGBA16, glpp::Channels::RGBA, glpp::TexelDataType::UnsignedByte}) Creates an empty canvas texture_layout is an advanced setting; it controls how the pixels are gonna be stored on the GPU. ImageSize\tsize() const Returns the size in pixels. virtual float\taspect_ratio() const override Returns the aspect ratio (width / height) float\tinverse_aspect_ratio() const Returns the inverse aspect ratio (height / width) virtual const Texture &amp;\ttexture() const override Returns the internal texture, that you can use to do advanced stuff with custom shaders. const glpp::RenderTarget &amp;\trender_target() const Returns the internal render target, that you can use to do advanced stuff. glpp::RenderTarget &amp;\trender_target() Returns the internal render target, that you can use to do advanced stuff. void\tresize(ImageSize size) Resizes the canvas. void\tdestructive_resize(ImageSize size) Resizes the canvas. "},{"title":"Details​","type":1,"pageTitle":"p6::Canvas","url":"/p6-docs/reference/Types/canvas#details","content":""},{"title":"Canvas()​","type":1,"pageTitle":"p6::Canvas","url":"/p6-docs/reference/Types/canvas#canvas","content":"Canvas(ImageSize size, glpp::TextureLayout texture_layout ={glpp::InternalFormat::RGBA16, glpp::Channels::RGBA, glpp::TexelDataType::UnsignedByte}); Creates an empty canvas texture_layout is an advanced setting; it controls how the pixels are gonna be stored on the GPU. "},{"title":"size()​","type":1,"pageTitle":"p6::Canvas","url":"/p6-docs/reference/Types/canvas#size","content":"ImageSize size() const; Returns the size in pixels. "},{"title":"aspect_ratio()​","type":1,"pageTitle":"p6::Canvas","url":"/p6-docs/reference/Types/canvas#aspect_ratio","content":"float aspect_ratio() const override; Returns the aspect ratio (width / height) Reimplements: p6::ImageOrCanvas::aspect_ratio "},{"title":"inverse_aspect_ratio()​","type":1,"pageTitle":"p6::Canvas","url":"/p6-docs/reference/Types/canvas#inverse_aspect_ratio","content":"float inverse_aspect_ratio() const; Returns the inverse aspect ratio (height / width) "},{"title":"texture()​","type":1,"pageTitle":"p6::Canvas","url":"/p6-docs/reference/Types/canvas#texture","content":"const Texture &amp; texture() const override; Returns the internal texture, that you can use to do advanced stuff with custom shaders. Reimplements: p6::ImageOrCanvas::texture "},{"title":"render_target()​","type":1,"pageTitle":"p6::Canvas","url":"/p6-docs/reference/Types/canvas#render_target","content":"const glpp::RenderTarget &amp; render_target() const; Returns the internal render target, that you can use to do advanced stuff. "},{"title":"render_target()​","type":1,"pageTitle":"p6::Canvas","url":"/p6-docs/reference/Types/canvas#render_target-1","content":"glpp::RenderTarget &amp; render_target(); Returns the internal render target, that you can use to do advanced stuff. "},{"title":"resize()​","type":1,"pageTitle":"p6::Canvas","url":"/p6-docs/reference/Types/canvas#resize","content":"void resize(ImageSize size); Resizes the canvas. "},{"title":"destructive_resize()​","type":1,"pageTitle":"p6::Canvas","url":"/p6-docs/reference/Types/canvas#destructive_resize","content":"void destructive_resize(ImageSize size); Resizes the canvas. ⚠️ All of its pixel content is lost. If you don't want that you can use resize() instead.  Updated on 2023 March 02 "},{"title":"p6::CanvasSizeMode_FixedSize","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/canvas_size_mode___fixed_size","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::CanvasSizeMode_FixedSize","url":"/p6-docs/reference/Types/canvas_size_mode___fixed_size#summary","content":"\tNameImageSize\tsize "},{"title":"Details​","type":1,"pageTitle":"p6::CanvasSizeMode_FixedSize","url":"/p6-docs/reference/Types/canvas_size_mode___fixed_size#details","content":""},{"title":"size​","type":1,"pageTitle":"p6::CanvasSizeMode_FixedSize","url":"/p6-docs/reference/Types/canvas_size_mode___fixed_size#size","content":"ImageSize size;   Updated on 2023 March 02 "},{"title":"p6::CanvasSizeMode_RelativeToWindow","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/canvas_size_mode___relative_to_window","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::CanvasSizeMode_RelativeToWindow","url":"/p6-docs/reference/Types/canvas_size_mode___relative_to_window#summary","content":"\tName\tCanvasSizeMode_RelativeToWindow(float scale) CanvasSizeMode_RelativeToWindow(float width_scale, float height_scale) float\twidth_scale float\theight_scale "},{"title":"Details​","type":1,"pageTitle":"p6::CanvasSizeMode_RelativeToWindow","url":"/p6-docs/reference/Types/canvas_size_mode___relative_to_window#details","content":""},{"title":"CanvasSizeMode_RelativeToWindow()​","type":1,"pageTitle":"p6::CanvasSizeMode_RelativeToWindow","url":"/p6-docs/reference/Types/canvas_size_mode___relative_to_window#canvassizemode_relativetowindow","content":"CanvasSizeMode_RelativeToWindow(float scale); "},{"title":"CanvasSizeMode_RelativeToWindow()​","type":1,"pageTitle":"p6::CanvasSizeMode_RelativeToWindow","url":"/p6-docs/reference/Types/canvas_size_mode___relative_to_window#canvassizemode_relativetowindow-1","content":"CanvasSizeMode_RelativeToWindow(float width_scale, float height_scale); "},{"title":"width_scale​","type":1,"pageTitle":"p6::CanvasSizeMode_RelativeToWindow","url":"/p6-docs/reference/Types/canvas_size_mode___relative_to_window#width_scale","content":"float width_scale;  "},{"title":"height_scale​","type":1,"pageTitle":"p6::CanvasSizeMode_RelativeToWindow","url":"/p6-docs/reference/Types/canvas_size_mode___relative_to_window#height_scale","content":"float height_scale;   Updated on 2023 March 02 "},{"title":"p6::CanvasSizeMode_SameAsWindow","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/canvas_size_mode___same_as_window","content":"","keywords":""},{"title":"Details​","type":1,"pageTitle":"p6::CanvasSizeMode_SameAsWindow","url":"/p6-docs/reference/Types/canvas_size_mode___same_as_window#details","content":" Updated on 2023 March 02 "},{"title":"p6::Center","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/center","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Center","url":"/p6-docs/reference/Types/center#summary","content":"\tName\tCenter() =default Center(float x, float y) Center(glm::vec2 value) glm::vec2\tvalue "},{"title":"Details​","type":1,"pageTitle":"p6::Center","url":"/p6-docs/reference/Types/center#details","content":""},{"title":"Center()​","type":1,"pageTitle":"p6::Center","url":"/p6-docs/reference/Types/center#center","content":"Center() =default; "},{"title":"Center()​","type":1,"pageTitle":"p6::Center","url":"/p6-docs/reference/Types/center#center-1","content":"Center(float x, float y); "},{"title":"Center()​","type":1,"pageTitle":"p6::Center","url":"/p6-docs/reference/Types/center#center-2","content":"Center(glm::vec2 value); "},{"title":"value​","type":1,"pageTitle":"p6::Center","url":"/p6-docs/reference/Types/center#value","content":"glm::vec2 value {0.f};   Updated on 2023 March 02 "},{"title":"p6::Color","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/color","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Color","url":"/p6-docs/reference/Types/color#summary","content":"\tNameconstexpr\tColor(float r = 0.f, float g = 0.f, float b = 0.f, float a = 1.f) float\tr() const float\tg() const float\tb() const float\ta() const float &amp;\tr() float &amp;\tg() float &amp;\tb() float &amp;\ta() glm::vec3\tas_premultiplied_vec3() const glm::vec3\tas_straight_vec3() const glm::vec4\tas_premultiplied_vec4() const glm::vec4\tas_straight_vec4() const "},{"title":"Details​","type":1,"pageTitle":"p6::Color","url":"/p6-docs/reference/Types/color#details","content":""},{"title":"Color()​","type":1,"pageTitle":"p6::Color","url":"/p6-docs/reference/Types/color#color","content":"constexpr Color(float r =0.f, float g =0.f, float b =0.f, float a =1.f); "},{"title":"r()​","type":1,"pageTitle":"p6::Color","url":"/p6-docs/reference/Types/color#r","content":"float r() const; "},{"title":"g()​","type":1,"pageTitle":"p6::Color","url":"/p6-docs/reference/Types/color#g","content":"float g() const; "},{"title":"b()​","type":1,"pageTitle":"p6::Color","url":"/p6-docs/reference/Types/color#b","content":"float b() const; "},{"title":"a()​","type":1,"pageTitle":"p6::Color","url":"/p6-docs/reference/Types/color#a","content":"float a() const; "},{"title":"r()​","type":1,"pageTitle":"p6::Color","url":"/p6-docs/reference/Types/color#r-1","content":"float &amp; r(); "},{"title":"g()​","type":1,"pageTitle":"p6::Color","url":"/p6-docs/reference/Types/color#g-1","content":"float &amp; g(); "},{"title":"b()​","type":1,"pageTitle":"p6::Color","url":"/p6-docs/reference/Types/color#b-1","content":"float &amp; b(); "},{"title":"a()​","type":1,"pageTitle":"p6::Color","url":"/p6-docs/reference/Types/color#a-1","content":"float &amp; a(); "},{"title":"as_premultiplied_vec3()​","type":1,"pageTitle":"p6::Color","url":"/p6-docs/reference/Types/color#as_premultiplied_vec3","content":"glm::vec3 as_premultiplied_vec3() const; "},{"title":"as_straight_vec3()​","type":1,"pageTitle":"p6::Color","url":"/p6-docs/reference/Types/color#as_straight_vec3","content":"glm::vec3 as_straight_vec3() const; "},{"title":"as_premultiplied_vec4()​","type":1,"pageTitle":"p6::Color","url":"/p6-docs/reference/Types/color#as_premultiplied_vec4","content":"glm::vec4 as_premultiplied_vec4() const; "},{"title":"as_straight_vec4()​","type":1,"pageTitle":"p6::Color","url":"/p6-docs/reference/Types/color#as_straight_vec4","content":"glm::vec4 as_straight_vec4() const;  Updated on 2023 March 02 "},{"title":"p6::Event_KeyPressed","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/event___key_pressed","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Event_KeyPressed","url":"/p6-docs/reference/Types/event___key_pressed#summary","content":"\tNameKey\tdata "},{"title":"Details​","type":1,"pageTitle":"p6::Event_KeyPressed","url":"/p6-docs/reference/Types/event___key_pressed#details","content":""},{"title":"data​","type":1,"pageTitle":"p6::Event_KeyPressed","url":"/p6-docs/reference/Types/event___key_pressed#data","content":"Key data;   Updated on 2023 March 02 "},{"title":"p6::Event_KeyReleased","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/event___key_released","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Event_KeyReleased","url":"/p6-docs/reference/Types/event___key_released#summary","content":"\tNameKey\tdata "},{"title":"Details​","type":1,"pageTitle":"p6::Event_KeyReleased","url":"/p6-docs/reference/Types/event___key_released#details","content":""},{"title":"data​","type":1,"pageTitle":"p6::Event_KeyReleased","url":"/p6-docs/reference/Types/event___key_released#data","content":"Key data;   Updated on 2023 March 02 "},{"title":"p6::Event_KeyRepeated","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/event___key_repeated","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Event_KeyRepeated","url":"/p6-docs/reference/Types/event___key_repeated#summary","content":"\tNameKey\tdata "},{"title":"Details​","type":1,"pageTitle":"p6::Event_KeyRepeated","url":"/p6-docs/reference/Types/event___key_repeated#details","content":""},{"title":"data​","type":1,"pageTitle":"p6::Event_KeyRepeated","url":"/p6-docs/reference/Types/event___key_repeated#data","content":"Key data;   Updated on 2023 March 02 "},{"title":"p6::Event_MainCanvasResized","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/event___main_canvas_resized","content":"","keywords":""},{"title":"Details​","type":1,"pageTitle":"p6::Event_MainCanvasResized","url":"/p6-docs/reference/Types/event___main_canvas_resized#details","content":" Updated on 2023 March 02 "},{"title":"p6::Event_MouseDragged","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/event___mouse_dragged","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Event_MouseDragged","url":"/p6-docs/reference/Types/event___mouse_dragged#summary","content":"\tNameMouseDrag\tdata "},{"title":"Details​","type":1,"pageTitle":"p6::Event_MouseDragged","url":"/p6-docs/reference/Types/event___mouse_dragged#details","content":""},{"title":"data​","type":1,"pageTitle":"p6::Event_MouseDragged","url":"/p6-docs/reference/Types/event___mouse_dragged#data","content":"MouseDrag data;   Updated on 2023 March 02 "},{"title":"p6::Event_MouseMoved","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/event___mouse_moved","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Event_MouseMoved","url":"/p6-docs/reference/Types/event___mouse_moved#summary","content":"\tNameMouseMove\tdata "},{"title":"Details​","type":1,"pageTitle":"p6::Event_MouseMoved","url":"/p6-docs/reference/Types/event___mouse_moved#details","content":""},{"title":"data​","type":1,"pageTitle":"p6::Event_MouseMoved","url":"/p6-docs/reference/Types/event___mouse_moved#data","content":"MouseMove data;   Updated on 2023 March 02 "},{"title":"p6::Event_MousePressed","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/event___mouse_pressed","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Event_MousePressed","url":"/p6-docs/reference/Types/event___mouse_pressed#summary","content":"\tNameMouseButton\tdata "},{"title":"Details​","type":1,"pageTitle":"p6::Event_MousePressed","url":"/p6-docs/reference/Types/event___mouse_pressed#details","content":""},{"title":"data​","type":1,"pageTitle":"p6::Event_MousePressed","url":"/p6-docs/reference/Types/event___mouse_pressed#data","content":"MouseButton data;   Updated on 2023 March 02 "},{"title":"p6::Event_MouseReleased","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/event___mouse_released","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Event_MouseReleased","url":"/p6-docs/reference/Types/event___mouse_released#summary","content":"\tNameMouseButton\tdata "},{"title":"Details​","type":1,"pageTitle":"p6::Event_MouseReleased","url":"/p6-docs/reference/Types/event___mouse_released#details","content":""},{"title":"data​","type":1,"pageTitle":"p6::Event_MouseReleased","url":"/p6-docs/reference/Types/event___mouse_released#data","content":"MouseButton data;   Updated on 2023 March 02 "},{"title":"p6::Event_MouseScrolled","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/event___mouse_scrolled","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Event_MouseScrolled","url":"/p6-docs/reference/Types/event___mouse_scrolled#summary","content":"\tNameMouseScroll\tdata "},{"title":"Details​","type":1,"pageTitle":"p6::Event_MouseScrolled","url":"/p6-docs/reference/Types/event___mouse_scrolled#details","content":""},{"title":"data​","type":1,"pageTitle":"p6::Event_MouseScrolled","url":"/p6-docs/reference/Types/event___mouse_scrolled#data","content":"MouseScroll data;   Updated on 2023 March 02 "},{"title":"p6::Event_Update","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/event___update","content":"","keywords":""},{"title":"Details​","type":1,"pageTitle":"p6::Event_Update","url":"/p6-docs/reference/Types/event___update#details","content":" Updated on 2023 March 02 "},{"title":"p6::Fit","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/fit","content":"","keywords":""},{"title":"Details​","type":1,"pageTitle":"p6::Fit","url":"/p6-docs/reference/Types/fit#details","content":" Updated on 2023 March 02 "},{"title":"p6::FitX","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/fit_x","content":"","keywords":""},{"title":"Details​","type":1,"pageTitle":"p6::FitX","url":"/p6-docs/reference/Types/fit_x#details","content":" Updated on 2023 March 02 "},{"title":"p6::Context","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/context","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#summary","content":"\tName\tContext(WindowCreationParams window_creation_params = {}) Context([Context](/reference/Types/context) &amp;&amp; ) =default Context &amp;\toperator=([Context](/reference/Types/context) &amp;&amp; ) =default Context(const [Context](/reference/Types/context) &amp; ) =delete Context &amp;\toperator=(const [Context](/reference/Types/context) &amp; ) =delete void\tbackground([Color](/reference/Types/color) color) Sets the color and alpha of each pixel of the canvas. void\tsquare([FullScreen](/reference/Types/full_screen) ) Draws a square. void\tsquare([Center](/reference/Types/center) center = {}, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare([TopLeftCorner](/reference/Types/top_left_corner) corner, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare([TopRightCorner](/reference/Types/top_right_corner) corner, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare([BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare([BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle([FullScreen](/reference/Types/full_screen) = {}) Draws a rectangle. void\trectangle([Center](/reference/Types/center) center, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle([TopLeftCorner](/reference/Types/top_left_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle([TopRightCorner](/reference/Types/top_right_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle([BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle([BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle([Transform2D](/reference/Types/transform2_d) transform) void\tcircle([FullScreen](/reference/Types/full_screen) ) Draws a circle. void\tcircle([Center](/reference/Types/center) center = {}, [Radius](/reference/Types/radius) radius = {}) void\tellipse([FullScreen](/reference/Types/full_screen) = {}) Draws an ellipse. void\tellipse([Center](/reference/Types/center) center, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tellipse([Transform2D](/reference/Types/transform2_d) transform) void\tequilateral_triangle([Center](/reference/Types/center) center, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) Draws an equilateral triangle. [Radius]() is the distance between the [Center](/reference/Types/center) and one of the tips of the triangle. void\ttriangle([Point2D](/reference/Types/point2_d) p1, [Point2D](/reference/Types/point2_d) p2, [Point2D](/reference/Types/point2_d) p3, [Center](/reference/Types/center) center = {}, [Rotation](/reference/Types/angle) rotation = {}) Draws a triangle between the three points, translated by [Center](/reference/Types/center) and rotated by Rotation. void\ttriangle([Point2D](/reference/Types/point2_d) p1, [Point2D](/reference/Types/point2_d) p2, [Point2D](/reference/Types/point2_d) p3, [Transform2D](/reference/Types/transform2_d) transform) Draws a triangle between the three points, and applies the transform to the triangle. void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Fit](/reference/Types/fit) = {}) Draws an image as big as possible on the screen. This will respect the aspect ratio of the image. void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [FitX](/reference/Types/fit_x) ) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [FitY](/reference/Types/fit_y) ) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Center](/reference/Types/center) center, [RadiusX](/reference/Types/radius_x) radiusX = {}, [Rotation](/reference/Types/angle) rotation = {}) Draws an image. This will respect the aspect ratio of the image. void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopLeftCorner](/reference/Types/top_left_corner) corner, [RadiusX](/reference/Types/radius_x) radiusX = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopRightCorner](/reference/Types/top_right_corner) corner, [RadiusX](/reference/Types/radius_x) radiusX = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [RadiusX](/reference/Types/radius_x) radiusX = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [RadiusX](/reference/Types/radius_x) radiusX = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Center](/reference/Types/center) center, [RadiusY](/reference/Types/radius_y) radiusY = {}, [Rotation](/reference/Types/angle) rotation = {}) Draws an image. This will respect the aspect ratio of the image. void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopLeftCorner](/reference/Types/top_left_corner) corner, [RadiusY](/reference/Types/radius_y) radiusY = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopRightCorner](/reference/Types/top_right_corner) corner, [RadiusY](/reference/Types/radius_y) radiusY = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [RadiusY](/reference/Types/radius_y) radiusY = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [RadiusY](/reference/Types/radius_y) radiusY = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [FullScreen](/reference/Types/full_screen) ) Draws an image that takes the entire window. ⚠️ This might distort the image if the window doesn't have the same aspect ratio as the image. void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Center](/reference/Types/center) center, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) Draws an image. ⚠️ This might distort the image if radii doesn't have the same aspect ratio as the image. void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopLeftCorner](/reference/Types/top_left_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopRightCorner](/reference/Types/top_right_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\timage(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Transform2D](/reference/Types/transform2_d) transform) void\trectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [FullScreen](/reference/Types/full_screen) = {}) Draws a rectangle using a custom fragment shader. void\trectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [Center](/reference/Types/center) center, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [TopLeftCorner](/reference/Types/top_left_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [TopRightCorner](/reference/Types/top_right_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radii](/reference/Types/radii) radii = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [Center](/reference/Types/center) center = {}, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [TopLeftCorner](/reference/Types/top_left_corner) corner, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [TopRightCorner](/reference/Types/top_right_corner) corner, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\tsquare_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radius](/reference/Types/radius) radius = {}, [Rotation](/reference/Types/angle) rotation = {}) void\trectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [Transform2D](/reference/Types/transform2_d) transform) void\tline(glm::vec2 start, glm::vec2 end) Draws a line between two points. void\ttext(const std::u16string &amp; str, [Center](/reference/Types/center) center, [Rotation](/reference/Types/angle) rotation = {}) void\ttext(const std::u16string &amp; str, [TopLeftCorner](/reference/Types/top_left_corner) corner, [Rotation](/reference/Types/angle) rotation = {}) void\ttext(const std::u16string &amp; str, [TopRightCorner](/reference/Types/top_right_corner) corner, [Rotation](/reference/Types/angle) rotation = {}) void\ttext(const std::u16string &amp; str, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Rotation](/reference/Types/angle) rotation = {}) void\ttext(const std::u16string &amp; str, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Rotation](/reference/Types/angle) rotation = {}) void\ttranslate(glm::vec2 translation) Applies a translation to all the future drawings. To undo this, see [push_transform()]() and [pop_transform()](). void\trotate([p6::Angle](/reference/Types/angle) angle) Applies a rotation to all the future drawings. To undo this, see [push_transform()]() and [pop_transform()](). void\tscale(glm::vec2 scale_factor) Applies a scale to all the future drawings. To undo this, see [push_transform()]() and [pop_transform()](). void\treset_transform() Undoes all the translate / rotate / scale / apply_transform / set_transform. void\tapply_transform(glm::mat3 additional_transform) Applies a custom transform matrix to all the future drawings. To undo this, see [push_transform()]() and [pop_transform()](). void\tset_transform(glm::mat3 transform) Sets the current transform matrix. This will override all the previous translate / rotate / scale / apply_transform. To undo this, see [push_transform()]() and [pop_transform()](). void\tpush_transform() Saves the current transform state. void\tpop_transform() Restores the transform to the state it had during the last [push_transform()](/reference/transform#push_transform) that has not been popped yet. TransformScopeGuard\ttransform_scope_guard() Will call push_transform() and pop_transform() automatically. glm::mat3\tcurrent_transform() const Returns the current transform matrix that is the combination of all the translate / rotate / scale / apply_transform / set_transform that have been applied. void\trender_to_canvas([Canvas](/reference/Types/canvas) &amp; canvas) Sets a canvas to be the one that all the drawing commands will draw on, until you call render_to_main_canvas. void\trender_to_main_canvas() Reset the Context to render to the main canvas. The main canvas is the one that will be displayed in the window. Canvas &amp;\tmain_canvas() const Canvas &amp;\tmain_canvas() const Canvas &amp;\tcurrent_canvas() const Canvas &amp;\tcurrent_canvas() const float\taspect_ratio() const Returns the aspect ratio (a.k.a. float\tinverse_aspect_ratio() const Returns the inverse aspect ratio (a.k.a. ImageSize\tmain_canvas_size() const Returns the size of the main canvas (width and height). int\tmain_canvas_width() const Returns the width of the main canvas. int\tmain_canvas_height() const Returns the height of the main canvas. ImageSize\tcurrent_canvas_size() const Returns the size of the current canvas (width and height). int\tcurrent_canvas_width() const Returns the width of the current canvas. int\tcurrent_canvas_height() const Returns the height of the current canvas. void\tmain_canvas_mode(CanvasSizeMode mode) Sets how the size of the main canvas will be computed. float\tcanvas_ratio(const [Canvas](/reference/Types/canvas) &amp; canvas) const Returns the ratio that you need to multiply with in order to match the position and size of the canvas when it is fitted in the window. void\tsave_image(std::filesystem::path path) const Saves the content of the window's main canvas as an image file. Color\tread_pixel(glm::vec2 position) const Returns the color of the pixel at the given position in the main canvas. glm::vec2\tmouse() const Returns the current mouse position. glm::vec2\tmouse_delta() const Returns the movement of the mouse since last update(). bool\tmouse_is_in_window() const Returns true iff the window is focused and the coordinates returned by mouse() correspond to a position inside the window. bool\tmouse_button_is_pressed(Button button) const Returns true iff the given mouse button is currently pressed. bool\tctrl() const Returns true iff the CTRL key is pressed (or CMD on Mac) bool\tshift() const Returns true iff the SHIFT key is pressed. bool\talt() const Returns true iff the ALT key is pressed. bool\tkey_is_pressed(int key) const Returns true iff the given key is currently pressed. bool\twindow_is_focused() const Returns true iff the window is currently focused. void\tfocus_window() const Focuses the window, making it pop to the foreground. void\tmaximize_window() Maximizes the window. void\tminimize_window() Minimizes the window. Note that while your window is minimized everything will be frozen and no update, event or anything will happen. void\trestore_window() Restores the window if it is currently maximized. Does nothing otherwise. bool\twindow_is_maximized() const Returns true iff the window is currently maximized. void\tgo_fullscreen() Makes the window fullscreen. void\tescape_fullscreen() Exits the fullscreen mode. void\ttoggle_fullscreen() Goes fullscreen if it wasn't, escapes fullscreen if it was. bool\twindow_is_fullscreen() const Returns true iff the window is currently fullscreen. float\ttime() const Returns the time in seconds since the creation of the Context. float\tdelta_time() const Returns an estimate of the time that elapses between two update() calls. void\ttime_perceived_as_realtime() Sets the time mode as realtime. void\ttime_perceived_as_constant_delta_time(float framerate) Sets the time mode as constant delta time. void\tframerate_synced_with_monitor() Makes sure that the framerate is adapted to your monitor: it will be 60 fps if you have a 60 Hertz monitor (which is the most common), or 120 fps if you have a 120 Hertz monitor, etc. void\tframerate_as_high_as_possible() Removes any limit on the framerate. update() will be called as fast as possible. void\tframerate_capped_at(float framerate) Keeps the framerate at the given value. void\tstart() Starts the update() loop. void\tstop() Stops the update() loop. void\tpause() Pauses the update() loop. void\tresume() Resumes the update() loop if it was paused with pause(). bool\tis_paused() const Returns true iff the update() loop is currently paused. std::function&lt; void()&gt;\tupdate This function is called repeatedly. The framerate is controlled by the framerate_xxx() functions. std::function&lt; void()&gt;\timgui In this function you can call all the ImGui code you want. std::function&lt; void(MouseMove)&gt;\tmouse_moved This function is called whenever the mouse is moved. std::function&lt; void(MouseDrag)&gt;\tmouse_dragged This function is called whenever the mouse is dragged. std::function&lt; void(MouseButton)&gt;\tmouse_pressed This function is called whenever a mouse button is pressed. std::function&lt; void(MouseButton)&gt;\tmouse_released This function is called whenever a mouse button is released. std::function&lt; void(MouseScroll)&gt;\tmouse_scrolled This function is called whenever the mouse wheel is scrolled. std::function&lt; void(Key)&gt;\tkey_pressed This function is called whenever a keyboard key is pressed. std::function&lt; void(Key)&gt;\tkey_released This function is called whenever a keyboard key is released. std::function&lt; void(Key)&gt;\tkey_repeated This function is called repeatedly whenever a keyboard key is held. std::function&lt; void(std::string &amp;&amp;)&gt;\ton_error This function is called whenever an error occurs. std::function&lt; void()&gt;\tmain_canvas_resized This function is called whenever the main canvas is resized. std::function&lt; void(Event)&gt;\ton_event This function is called whenever any event occurs (key pressed, mouse moved, etc.). Color\tfill The color that is used for the interior of the shapes. bool\tuse_fill Whether the shapes will have an interior. Color\tstroke The color that is used for the boundary of the shapes. float\tstroke_weight The size of the boundary of the shapes. bool\tuse_stroke Whether there will be a boundary on the shape. float\ttext_size Height of the text. float\ttext_inflating Gives some &quot;boldness&quot; to the text. "},{"title":"Details​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#details","content":""},{"title":"Context()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#context","content":"Context(WindowCreationParams window_creation_params ={}); "},{"title":"Context()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#context-1","content":"Context([Context](/reference/Types/context) &amp;&amp; ) =default; "},{"title":"operator=()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#operator","content":"[Context](/reference/Types/context) &amp; operator=([Context](/reference/Types/context) &amp;&amp; ) =default; "},{"title":"Context()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#context-2","content":"Context(const [Context](/reference/Types/context) &amp; ) =delete; "},{"title":"operator=()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#operator-1","content":"[Context](/reference/Types/context) &amp; operator=(const [Context](/reference/Types/context) &amp; ) =delete; "},{"title":"background()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#background","content":"void background([Color](/reference/Types/color) color); Sets the color and alpha of each pixel of the canvas. NB: No blending is applied; even if you specify an alpha of 0.5 the old canvas is completely erased. This means that setting an alpha here doesn't matter much. It is only meaningful if you export the canvas as a png, or if you later try to blend the canvas on top of another image. "},{"title":"square()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#square","content":"void square([FullScreen](/reference/Types/full_screen) ); Draws a square. "},{"title":"square()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#square-1","content":"void square([Center](/reference/Types/center) center ={}, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#square-2","content":"void square([TopLeftCorner](/reference/Types/top_left_corner) corner, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#square-3","content":"void square([TopRightCorner](/reference/Types/top_right_corner) corner, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#square-4","content":"void square([BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#square-5","content":"void square([BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#rectangle","content":"void rectangle([FullScreen](/reference/Types/full_screen) ={}); Draws a rectangle. "},{"title":"rectangle()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#rectangle-1","content":"void rectangle([Center](/reference/Types/center) center, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#rectangle-2","content":"void rectangle([TopLeftCorner](/reference/Types/top_left_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#rectangle-3","content":"void rectangle([TopRightCorner](/reference/Types/top_right_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#rectangle-4","content":"void rectangle([BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#rectangle-5","content":"void rectangle([BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#rectangle-6","content":"void rectangle([Transform2D](/reference/Types/transform2_d) transform); "},{"title":"circle()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#circle","content":"void circle([FullScreen](/reference/Types/full_screen) ); Draws a circle. "},{"title":"circle()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#circle-1","content":"void circle([Center](/reference/Types/center) center ={}, [Radius](/reference/Types/radius) radius ={}); "},{"title":"ellipse()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#ellipse","content":"void ellipse([FullScreen](/reference/Types/full_screen) ={}); Draws an ellipse. "},{"title":"ellipse()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#ellipse-1","content":"void ellipse([Center](/reference/Types/center) center, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"ellipse()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#ellipse-2","content":"void ellipse([Transform2D](/reference/Types/transform2_d) transform); "},{"title":"equilateral_triangle()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#equilateral_triangle","content":"void equilateral_triangle([Center](/reference/Types/center) center, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); Draws an equilateral triangle. [Radius]() is the distance between the [Center](/reference/Types/center) and one of the tips of the triangle. "},{"title":"triangle()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#triangle","content":"void triangle([Point2D](/reference/Types/point2_d) p1, [Point2D](/reference/Types/point2_d) p2, [Point2D](/reference/Types/point2_d) p3, [Center](/reference/Types/center) center ={}, [Rotation](/reference/Types/angle) rotation ={}); Draws a triangle between the three points, translated by [Center](/reference/Types/center) and rotated by Rotation. "},{"title":"triangle()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#triangle-1","content":"void triangle([Point2D](/reference/Types/point2_d) p1, [Point2D](/reference/Types/point2_d) p2, [Point2D](/reference/Types/point2_d) p3, [Transform2D](/reference/Types/transform2_d) transform); Draws a triangle between the three points, and applies the transform to the triangle. "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Fit](/reference/Types/fit) ={}); Draws an image as big as possible on the screen. This will respect the aspect ratio of the image. "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-1","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [FitX](/reference/Types/fit_x) ); "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-2","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [FitY](/reference/Types/fit_y) ); "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-3","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Center](/reference/Types/center) center, [RadiusX](/reference/Types/radius_x) radiusX ={}, [Rotation](/reference/Types/angle) rotation ={}); Draws an image. This will respect the aspect ratio of the image. "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-4","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopLeftCorner](/reference/Types/top_left_corner) corner, [RadiusX](/reference/Types/radius_x) radiusX ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-5","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopRightCorner](/reference/Types/top_right_corner) corner, [RadiusX](/reference/Types/radius_x) radiusX ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-6","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [RadiusX](/reference/Types/radius_x) radiusX ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-7","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [RadiusX](/reference/Types/radius_x) radiusX ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-8","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Center](/reference/Types/center) center, [RadiusY](/reference/Types/radius_y) radiusY ={}, [Rotation](/reference/Types/angle) rotation ={}); Draws an image. This will respect the aspect ratio of the image. "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-9","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopLeftCorner](/reference/Types/top_left_corner) corner, [RadiusY](/reference/Types/radius_y) radiusY ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-10","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopRightCorner](/reference/Types/top_right_corner) corner, [RadiusY](/reference/Types/radius_y) radiusY ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-11","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [RadiusY](/reference/Types/radius_y) radiusY ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-12","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [RadiusY](/reference/Types/radius_y) radiusY ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-13","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [FullScreen](/reference/Types/full_screen) ); Draws an image that takes the entire window. ⚠️ This might distort the image if the window doesn't have the same aspect ratio as the image. "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-14","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Center](/reference/Types/center) center, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); Draws an image. ⚠️ This might distort the image if radii doesn't have the same aspect ratio as the image. "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-15","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopLeftCorner](/reference/Types/top_left_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-16","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [TopRightCorner](/reference/Types/top_right_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-17","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-18","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#image-19","content":"void image(const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; img, [Transform2D](/reference/Types/transform2_d) transform); "},{"title":"rectangle_with_shader()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#rectangle_with_shader","content":"void rectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [FullScreen](/reference/Types/full_screen) ={}); Draws a rectangle using a custom fragment shader. "},{"title":"rectangle_with_shader()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#rectangle_with_shader-1","content":"void rectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [Center](/reference/Types/center) center, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle_with_shader()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#rectangle_with_shader-2","content":"void rectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [TopLeftCorner](/reference/Types/top_left_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle_with_shader()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#rectangle_with_shader-3","content":"void rectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [TopRightCorner](/reference/Types/top_right_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle_with_shader()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#rectangle_with_shader-4","content":"void rectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle_with_shader()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#rectangle_with_shader-5","content":"void rectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radii](/reference/Types/radii) radii ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square_with_shader()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#square_with_shader","content":"void square_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [Center](/reference/Types/center) center ={}, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square_with_shader()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#square_with_shader-1","content":"void square_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [TopLeftCorner](/reference/Types/top_left_corner) corner, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square_with_shader()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#square_with_shader-2","content":"void square_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [TopRightCorner](/reference/Types/top_right_corner) corner, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square_with_shader()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#square_with_shader-3","content":"void square_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"square_with_shader()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#square_with_shader-4","content":"void square_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Radius](/reference/Types/radius) radius ={}, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"rectangle_with_shader()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#rectangle_with_shader-6","content":"void rectangle_with_shader(const [Shader](/reference/Types/shader) &amp; shader, [Transform2D](/reference/Types/transform2_d) transform); "},{"title":"line()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#line","content":"void line(glm::vec2 start, glm::vec2 end); Draws a line between two points. It uses the stroke color, and stroke_weight as its thickness. "},{"title":"text()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#text","content":"void text(const std::u16string &amp; str, [Center](/reference/Types/center) center, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"text()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#text-1","content":"void text(const std::u16string &amp; str, [TopLeftCorner](/reference/Types/top_left_corner) corner, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"text()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#text-2","content":"void text(const std::u16string &amp; str, [TopRightCorner](/reference/Types/top_right_corner) corner, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"text()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#text-3","content":"void text(const std::u16string &amp; str, [BottomLeftCorner](/reference/Types/bottom_left_corner) corner, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"text()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#text-4","content":"void text(const std::u16string &amp; str, [BottomRightCorner](/reference/Types/bottom_right_corner) corner, [Rotation](/reference/Types/angle) rotation ={}); "},{"title":"translate()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#translate","content":"void translate(glm::vec2 translation); Applies a translation to all the future drawings. To undo this, see [push_transform()]() and [pop_transform()](). "},{"title":"rotate()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#rotate","content":"void rotate([p6::Angle](/reference/Types/angle) angle); Applies a rotation to all the future drawings. To undo this, see [push_transform()]() and [pop_transform()](). "},{"title":"scale()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#scale","content":"void scale(glm::vec2 scale_factor); Applies a scale to all the future drawings. To undo this, see [push_transform()]() and [pop_transform()](). "},{"title":"reset_transform()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#reset_transform","content":"void reset_transform(); Undoes all the translate / rotate / scale / apply_transform / set_transform. "},{"title":"apply_transform()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#apply_transform","content":"void apply_transform(glm::mat3 additional_transform); Applies a custom transform matrix to all the future drawings. To undo this, see [push_transform()]() and [pop_transform()](). "},{"title":"set_transform()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#set_transform","content":"void set_transform(glm::mat3 transform); Sets the current transform matrix. This will override all the previous translate / rotate / scale / apply_transform. To undo this, see [push_transform()]() and [pop_transform()](). "},{"title":"push_transform()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#push_transform","content":"void push_transform(); Saves the current transform state. "},{"title":"pop_transform()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#pop_transform","content":"void pop_transform(); Restores the transform to the state it had during the last [push_transform()](/reference/transform#push_transform) that has not been popped yet. "},{"title":"transform_scope_guard()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#transform_scope_guard","content":"[TransformScopeGuard](/reference/Types/transform_scope_guard) transform_scope_guard(); Will call push_transform() and pop_transform() automatically. Assign the result of this function to a variable and pop_transform() will be called when the variable goes out of scope. push_transform() is called when transform_scope_guard() is called. "},{"title":"current_transform()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#current_transform","content":"glm::mat3 current_transform() const; Returns the current transform matrix that is the combination of all the translate / rotate / scale / apply_transform / set_transform that have been applied. "},{"title":"render_to_canvas()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#render_to_canvas","content":"void render_to_canvas([Canvas](/reference/Types/canvas) &amp; canvas); Sets a canvas to be the one that all the drawing commands will draw on, until you call render_to_main_canvas. "},{"title":"render_to_main_canvas()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#render_to_main_canvas","content":"void render_to_main_canvas(); Reset the Context to render to the main canvas. The main canvas is the one that will be displayed in the window. "},{"title":"main_canvas()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#main_canvas","content":"[Canvas](/reference/Types/canvas) &amp; main_canvas(); "},{"title":"main_canvas()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#main_canvas-1","content":"const [Canvas](/reference/Types/canvas) &amp; main_canvas() const; "},{"title":"current_canvas()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#current_canvas","content":"[Canvas](/reference/Types/canvas) &amp; current_canvas(); "},{"title":"current_canvas()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#current_canvas-1","content":"const [Canvas](/reference/Types/canvas) &amp; current_canvas() const; "},{"title":"aspect_ratio()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#aspect_ratio","content":"float aspect_ratio() const; Returns the aspect ratio (a.k.a. width / height) of the current canvas. This canvas is the window's main canvas by default, unless you called render_to_canvas() in which case it will be the given canvas. When you call render_to_main_canvas() the current canvas goes back to beeing the window's main canvas. "},{"title":"inverse_aspect_ratio()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#inverse_aspect_ratio","content":"float inverse_aspect_ratio() const; Returns the inverse aspect ratio (a.k.a. height / width) of the current canvas. This canvas is the window's main canvas by default, unless you called render_to_canvas() in which case it will be the given canvas. When you call render_to_main_canvas() the current canvas goes back to beeing the window's main canvas. "},{"title":"main_canvas_size()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#main_canvas_size","content":"ImageSize main_canvas_size() const; Returns the size of the main canvas (width and height). "},{"title":"main_canvas_width()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#main_canvas_width","content":"int main_canvas_width() const; Returns the width of the main canvas. "},{"title":"main_canvas_height()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#main_canvas_height","content":"int main_canvas_height() const; Returns the height of the main canvas. "},{"title":"current_canvas_size()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#current_canvas_size","content":"ImageSize current_canvas_size() const; Returns the size of the current canvas (width and height). "},{"title":"current_canvas_width()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#current_canvas_width","content":"int current_canvas_width() const; Returns the width of the current canvas. "},{"title":"current_canvas_height()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#current_canvas_height","content":"int current_canvas_height() const; Returns the height of the current canvas. "},{"title":"main_canvas_mode()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#main_canvas_mode","content":"void main_canvas_mode(CanvasSizeMode mode); Sets how the size of the main canvas will be computed. The default mode is CanvasSizeMode_SameAsWindow. "},{"title":"canvas_ratio()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#canvas_ratio","content":"float canvas_ratio(const [Canvas](/reference/Types/canvas) &amp; canvas) const; Returns the ratio that you need to multiply with in order to match the position and size of the canvas when it is fitted in the window. "},{"title":"save_image()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#save_image","content":"void save_image(std::filesystem::path path) const; Saves the content of the window's main canvas as an image file. Supported file types are .png and .jpeg/.jpg Simply use the corresponding extension to save in the desired format. If the path already exists, a number will be appended to the name and the previous file won't be overwritten. If the path is relative, it will be relative to the directory containing your executable. If some directories in the path don't exist yet, they will be created automatically. "},{"title":"read_pixel()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#read_pixel","content":"[Color](/reference/Types/color) read_pixel(glm::vec2 position) const; Returns the color of the pixel at the given position in the main canvas. The coordinates are expressed in the usual p6 coordinate system. "},{"title":"mouse()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#mouse","content":"glm::vec2 mouse() const; Returns the current mouse position. "},{"title":"mouse_delta()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#mouse_delta","content":"glm::vec2 mouse_delta() const; Returns the movement of the mouse since last update(). "},{"title":"mouse_is_in_window()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#mouse_is_in_window","content":"bool mouse_is_in_window() const; Returns true iff the window is focused and the coordinates returned by mouse() correspond to a position inside the window. "},{"title":"mouse_button_is_pressed()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#mouse_button_is_pressed","content":"bool mouse_button_is_pressed(Button button) const; Returns true iff the given mouse button is currently pressed. "},{"title":"ctrl()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#ctrl","content":"bool ctrl() const; Returns true iff the CTRL key is pressed (or CMD on Mac) "},{"title":"shift()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#shift","content":"bool shift() const; Returns true iff the SHIFT key is pressed. "},{"title":"alt()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#alt","content":"bool alt() const; Returns true iff the ALT key is pressed. "},{"title":"key_is_pressed()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#key_is_pressed","content":"bool key_is_pressed(int key) const; Returns true iff the given key is currently pressed. key should be a GLFWKEY value. See https://www.glfw.org/docs/3.3/keys.html for the complete list. e.g. ctx.key_is_pressed(GLFW_KEY_Q) /!\\ Please note that these are physical keys that don't depend on the current layout. This means that GLFW_KEY_Q will refer to the first key on your keyboard, no matter if you are using QWERTY or AZERTY. "},{"title":"window_is_focused()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#window_is_focused","content":"bool window_is_focused() const; Returns true iff the window is currently focused. "},{"title":"focus_window()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#focus_window","content":"void focus_window() const; Focuses the window, making it pop to the foreground. "},{"title":"maximize_window()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#maximize_window","content":"void maximize_window(); Maximizes the window. "},{"title":"minimize_window()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#minimize_window","content":"void minimize_window(); Minimizes the window. Note that while your window is minimized everything will be frozen and no update, event or anything will happen. "},{"title":"restore_window()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#restore_window","content":"void restore_window(); Restores the window if it is currently maximized. Does nothing otherwise. "},{"title":"window_is_maximized()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#window_is_maximized","content":"bool window_is_maximized() const; Returns true iff the window is currently maximized. "},{"title":"go_fullscreen()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#go_fullscreen","content":"void go_fullscreen(); Makes the window fullscreen. Does nothing if it was already fullscreen. "},{"title":"escape_fullscreen()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#escape_fullscreen","content":"void escape_fullscreen(); Exits the fullscreen mode. Does nothing if the window wasn't fullscreen. "},{"title":"toggle_fullscreen()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#toggle_fullscreen","content":"void toggle_fullscreen(); Goes fullscreen if it wasn't, escapes fullscreen if it was. "},{"title":"window_is_fullscreen()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#window_is_fullscreen","content":"bool window_is_fullscreen() const; Returns true iff the window is currently fullscreen. "},{"title":"time()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#time","content":"float time() const; Returns the time in seconds since the creation of the Context. "},{"title":"delta_time()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#delta_time","content":"float delta_time() const; Returns an estimate of the time that elapses between two update() calls. "},{"title":"time_perceived_as_realtime()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#time_perceived_as_realtime","content":"void time_perceived_as_realtime(); Sets the time mode as realtime. This means that what is returned by time() and delta_time() corresponds to the actual time that elapsed in the real world. This is ideal when you want to do realtime animation and interactive sketches. "},{"title":"time_perceived_as_constant_delta_time()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#time_perceived_as_constant_delta_time","content":"void time_perceived_as_constant_delta_time(float framerate); Sets the time mode as constant delta time. This means that what is returned by time() and delta_time() corresponds to an ideal world where there is exactly 1/framerate seconds between each updates. This is ideal when you are exporting a video and don't want the long export time to influence your animation. framerate is expressed in frames per second "},{"title":"framerate_synced_with_monitor()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#framerate_synced_with_monitor","content":"void framerate_synced_with_monitor(); Makes sure that the framerate is adapted to your monitor: it will be 60 fps if you have a 60 Hertz monitor (which is the most common), or 120 fps if you have a 120 Hertz monitor, etc. This is the default framerate mode. "},{"title":"framerate_as_high_as_possible()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#framerate_as_high_as_possible","content":"void framerate_as_high_as_possible(); Removes any limit on the framerate. update() will be called as fast as possible. "},{"title":"framerate_capped_at()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#framerate_capped_at","content":"void framerate_capped_at(float framerate); Keeps the framerate at the given value. "},{"title":"start()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#start","content":"void start(); Starts the update() loop. update() will be called repeatedly, until you close the window or call stop(). "},{"title":"stop()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#stop","content":"void stop(); Stops the update() loop. This is the programatic equivalent of a user closing the window. "},{"title":"pause()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#pause","content":"void pause(); Pauses the update() loop. No update() will be called, until you call resume(). User inputs are still processed. "},{"title":"resume()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#resume","content":"void resume(); Resumes the update() loop if it was paused with pause(). It has no effect if the loop was already playing. "},{"title":"is_paused()​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#is_paused","content":"bool is_paused() const; Returns true iff the update() loop is currently paused. "},{"title":"update​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#update","content":"std::function&lt; void()&gt; update = []() { };  This function is called repeatedly. The framerate is controlled by the framerate_xxx() functions. "},{"title":"imgui​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#imgui","content":"std::function&lt; void()&gt; imgui = []() { };  In this function you can call all the ImGui code you want. Note that you can also do it during the [update()](/reference/events#update) function. This [imgui()](/reference/events#imgui) function is just here to help you organize your code if you want to. "},{"title":"mouse_moved​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#mouse_moved","content":"std::function&lt; void(MouseMove)&gt; mouse_moved = [](MouseMove) { };  This function is called whenever the mouse is moved. "},{"title":"mouse_dragged​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#mouse_dragged","content":"std::function&lt; void(MouseDrag)&gt; mouse_dragged = [](MouseDrag) { };  This function is called whenever the mouse is dragged. "},{"title":"mouse_pressed​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#mouse_pressed","content":"std::function&lt; void(MouseButton)&gt; mouse_pressed = [](MouseButton) { };  This function is called whenever a mouse button is pressed. "},{"title":"mouse_released​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#mouse_released","content":"std::function&lt; void(MouseButton)&gt; mouse_released = [](MouseButton) { };  This function is called whenever a mouse button is released. "},{"title":"mouse_scrolled​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#mouse_scrolled","content":"std::function&lt; void(MouseScroll)&gt; mouse_scrolled = [](MouseScroll) { };  This function is called whenever the mouse wheel is scrolled. "},{"title":"key_pressed​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#key_pressed","content":"std::function&lt; void(Key)&gt; key_pressed = [](Key) { };  This function is called whenever a keyboard key is pressed. "},{"title":"key_released​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#key_released","content":"std::function&lt; void(Key)&gt; key_released = [](Key) { };  This function is called whenever a keyboard key is released. "},{"title":"key_repeated​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#key_repeated","content":"std::function&lt; void(Key)&gt; key_repeated = [](Key) { };  This function is called repeatedly whenever a keyboard key is held. (NB: this only starts after holding the key for a little while. The exact behaviour is OS-specific) ⚠️ This is less than ideal to do things like handling the movement of a character. You should rather do, in your update function: if (ctx.key_is_held(GLFW_KEY_W)) { character.move_forward(ctx.delta_time()); }  "},{"title":"on_error​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#on_error","content":"std::function&lt; void(std::string &amp;&amp;)&gt; on_error = [](std::string&amp;&amp; error_message) { std::cerr &lt;&lt; error_message &lt;&lt; '\\n'; throw std::runtime_error{error_message}; };  This function is called whenever an error occurs. "},{"title":"main_canvas_resized​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#main_canvas_resized","content":"std::function&lt; void()&gt; main_canvas_resized = []() { };  This function is called whenever the main canvas is resized. If you call main_canvas_size(), main_canvas_width(), main_canvas_height() or aspect_ratio() inside main_canvas_resized() they will already be referring to the new size. "},{"title":"on_event​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#on_event","content":"std::function&lt; void(Event)&gt; on_event = [](Event const&amp;) { };  This function is called whenever any event occurs (key pressed, mouse moved, etc.). It can be useful to use this function instead of the more specific ones (key_pressed, mouse_moved, etc.) if for example you want to forward several events to a function that will handle them. For example in order to control a camera you might need to forward the key, mouse and update events to it. Instead of having to put the code inside those three event functions, you can just put it in on_event and let the camera handle each event as it so pleases. "},{"title":"fill​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#fill","content":"Color fill {1.f, 1.f, 1.f, 0.5f};  The color that is used for the interior of the shapes. "},{"title":"use_fill​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#use_fill","content":"bool use_fill = true;  Whether the shapes will have an interior. "},{"title":"stroke​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#stroke","content":"Color stroke {0.f, 0.f, 0.f};  The color that is used for the boundary of the shapes. "},{"title":"stroke_weight​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#stroke_weight","content":"float stroke_weight = 0.01f;  The size of the boundary of the shapes. "},{"title":"use_stroke​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#use_stroke","content":"bool use_stroke = true;  Whether there will be a boundary on the shape. "},{"title":"text_size​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#text_size","content":"float text_size = 0.03f;  Height of the text. "},{"title":"text_inflating​","type":1,"pageTitle":"p6::Context","url":"/p6-docs/reference/Types/context#text_inflating","content":"float text_inflating = 0.01f;  Gives some &quot;boldness&quot; to the text.  Updated on 2023 March 02 "},{"title":"p6::FitY","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/fit_y","content":"","keywords":""},{"title":"Details​","type":1,"pageTitle":"p6::FitY","url":"/p6-docs/reference/Types/fit_y#details","content":" Updated on 2023 March 02 "},{"title":"p6::FullScreen","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/full_screen","content":"","keywords":""},{"title":"Details​","type":1,"pageTitle":"p6::FullScreen","url":"/p6-docs/reference/Types/full_screen#details","content":" Updated on 2023 March 02 "},{"title":"p6::Image","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/image","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Image","url":"/p6-docs/reference/Types/image#summary","content":"\tName\tImage(ImageSize size, const uint8_t * data, glpp::TextureLayout texture_layout = {glpp::InternalFormat::RGBA8, glpp::Channels::RGBA, glpp::TexelDataType::UnsignedByte}) Creates an Image filled with data. ImageSize\tsize() const Returns the size in pixels. virtual float\taspect_ratio() const override Returns the aspect ratio (width / height) float\tinverse_aspect_ratio() const Returns the inverse aspect ratio (height / width) virtual const glpp::Texture2D &amp;\ttexture() const override "},{"title":"Details​","type":1,"pageTitle":"p6::Image","url":"/p6-docs/reference/Types/image#details","content":""},{"title":"Image()​","type":1,"pageTitle":"p6::Image","url":"/p6-docs/reference/Types/image#image","content":"Image(ImageSize size, const uint8_t * data, glpp::TextureLayout texture_layout ={glpp::InternalFormat::RGBA8, glpp::Channels::RGBA, glpp::TexelDataType::UnsignedByte}); Creates an Image filled with data. This is for advanded uses; prefer using p6::load_image(). data must be an array of size size.width() * size.height() * 4, with R, G, B and A channels, starting with the bottom left pixel, and going row by row. texture_layout is an advanced setting; it controls how the pixels are gonna be stored on the GPU. "},{"title":"size()​","type":1,"pageTitle":"p6::Image","url":"/p6-docs/reference/Types/image#size","content":"ImageSize size() const; Returns the size in pixels. "},{"title":"aspect_ratio()​","type":1,"pageTitle":"p6::Image","url":"/p6-docs/reference/Types/image#aspect_ratio","content":"float aspect_ratio() const override; Returns the aspect ratio (width / height) Reimplements: p6::ImageOrCanvas::aspect_ratio "},{"title":"inverse_aspect_ratio()​","type":1,"pageTitle":"p6::Image","url":"/p6-docs/reference/Types/image#inverse_aspect_ratio","content":"float inverse_aspect_ratio() const; Returns the inverse aspect ratio (height / width) "},{"title":"texture()​","type":1,"pageTitle":"p6::Image","url":"/p6-docs/reference/Types/image#texture","content":"const glpp::Texture2D &amp; texture() const override; Reimplements: p6::ImageOrCanvas::texture  Updated on 2023 March 02 "},{"title":"p6::ImageOrCanvas","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/image_or_canvas","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::ImageOrCanvas","url":"/p6-docs/reference/Types/image_or_canvas#summary","content":"\tNamevirtual const glpp::Texture2D &amp;\ttexture() const =0 virtual float\taspect_ratio() const =0 "},{"title":"Details​","type":1,"pageTitle":"p6::ImageOrCanvas","url":"/p6-docs/reference/Types/image_or_canvas#details","content":""},{"title":"texture()​","type":1,"pageTitle":"p6::ImageOrCanvas","url":"/p6-docs/reference/Types/image_or_canvas#texture","content":"const glpp::Texture2D &amp; texture() const =0; Reimplemented by: p6::Canvas::texture, p6::Image::texture "},{"title":"aspect_ratio()​","type":1,"pageTitle":"p6::ImageOrCanvas","url":"/p6-docs/reference/Types/image_or_canvas#aspect_ratio","content":"float aspect_ratio() const =0; Reimplemented by: p6::Canvas::aspect_ratio, p6::Image::aspect_ratio  Updated on 2023 March 02 "},{"title":"p6::MouseButton","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/mouse_button","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::MouseButton","url":"/p6-docs/reference/Types/mouse_button#summary","content":"\tNameglm::vec2\tposition Button\tbutton "},{"title":"Details​","type":1,"pageTitle":"p6::MouseButton","url":"/p6-docs/reference/Types/mouse_button#details","content":""},{"title":"position​","type":1,"pageTitle":"p6::MouseButton","url":"/p6-docs/reference/Types/mouse_button#position","content":"glm::vec2 position;  "},{"title":"button​","type":1,"pageTitle":"p6::MouseButton","url":"/p6-docs/reference/Types/mouse_button#button","content":"Button button;   Updated on 2023 March 02 "},{"title":"p6::Key","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/key","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Key","url":"/p6-docs/reference/Types/key#summary","content":"\tNamestd::string\tlogical The character that was pressed. int\tphysical The key at a given position on the keyboard. It is independent of the keyboard layout (e.g. GLFW_KEY_Q will correspond to the first key on the first row of your keyboard, no matter if you are using azerty instead of qwerty) "},{"title":"Details​","type":1,"pageTitle":"p6::Key","url":"/p6-docs/reference/Types/key#details","content":""},{"title":"logical​","type":1,"pageTitle":"p6::Key","url":"/p6-docs/reference/Types/key#logical","content":"std::string logical;  The character that was pressed. This depends on the keyboard layout (qwerty vs azerty). If the key pressed was not a character (for example ENTER, SHIFT etc.) then this is an empty string. "},{"title":"physical​","type":1,"pageTitle":"p6::Key","url":"/p6-docs/reference/Types/key#physical","content":"int physical;  The key at a given position on the keyboard. It is independent of the keyboard layout (e.g. GLFW_KEY_Q will correspond to the first key on the first row of your keyboard, no matter if you are using azerty instead of qwerty)  Updated on 2023 March 02 "},{"title":"p6::MouseDrag","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/mouse_drag","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::MouseDrag","url":"/p6-docs/reference/Types/mouse_drag#summary","content":"\tNameglm::vec2\tposition glm::vec2\tdelta glm::vec2\tstart_position "},{"title":"Details​","type":1,"pageTitle":"p6::MouseDrag","url":"/p6-docs/reference/Types/mouse_drag#details","content":""},{"title":"position​","type":1,"pageTitle":"p6::MouseDrag","url":"/p6-docs/reference/Types/mouse_drag#position","content":"glm::vec2 position;  "},{"title":"delta​","type":1,"pageTitle":"p6::MouseDrag","url":"/p6-docs/reference/Types/mouse_drag#delta","content":"glm::vec2 delta;  "},{"title":"start_position​","type":1,"pageTitle":"p6::MouseDrag","url":"/p6-docs/reference/Types/mouse_drag#start_position","content":"glm::vec2 start_position;   Updated on 2023 March 02 "},{"title":"p6::MouseMove","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/mouse_move","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::MouseMove","url":"/p6-docs/reference/Types/mouse_move#summary","content":"\tNameglm::vec2\tposition glm::vec2\tdelta "},{"title":"Details​","type":1,"pageTitle":"p6::MouseMove","url":"/p6-docs/reference/Types/mouse_move#details","content":""},{"title":"position​","type":1,"pageTitle":"p6::MouseMove","url":"/p6-docs/reference/Types/mouse_move#position","content":"glm::vec2 position;  "},{"title":"delta​","type":1,"pageTitle":"p6::MouseMove","url":"/p6-docs/reference/Types/mouse_move#delta","content":"glm::vec2 delta;   Updated on 2023 March 02 "},{"title":"p6::MouseScroll","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/mouse_scroll","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::MouseScroll","url":"/p6-docs/reference/Types/mouse_scroll#summary","content":"\tNamefloat\tdx float\tdy "},{"title":"Details​","type":1,"pageTitle":"p6::MouseScroll","url":"/p6-docs/reference/Types/mouse_scroll#details","content":""},{"title":"dx​","type":1,"pageTitle":"p6::MouseScroll","url":"/p6-docs/reference/Types/mouse_scroll#dx","content":"float dx;  "},{"title":"dy​","type":1,"pageTitle":"p6::MouseScroll","url":"/p6-docs/reference/Types/mouse_scroll#dy","content":"float dy;   Updated on 2023 March 02 "},{"title":"p6::Radians","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/radians","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Radians","url":"/p6-docs/reference/Types/radians#summary","content":"\tNameconstexpr\tRadians() =default constexpr\tRadians(float value) float\tvalue "},{"title":"Details​","type":1,"pageTitle":"p6::Radians","url":"/p6-docs/reference/Types/radians#details","content":""},{"title":"Radians()​","type":1,"pageTitle":"p6::Radians","url":"/p6-docs/reference/Types/radians#radians","content":"constexpr Radians() =default; "},{"title":"Radians()​","type":1,"pageTitle":"p6::Radians","url":"/p6-docs/reference/Types/radians#radians-1","content":"constexpr Radians(float value); "},{"title":"value​","type":1,"pageTitle":"p6::Radians","url":"/p6-docs/reference/Types/radians#value","content":"float value {0.f};   Updated on 2023 March 02 "},{"title":"p6::Point2D","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/point2_d","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Point2D","url":"/p6-docs/reference/Types/point2_d#summary","content":"\tName\tPoint2D(float x, float y) Point2D(glm::vec2 value) glm::vec2\tvalue "},{"title":"Details​","type":1,"pageTitle":"p6::Point2D","url":"/p6-docs/reference/Types/point2_d#details","content":""},{"title":"Point2D()​","type":1,"pageTitle":"p6::Point2D","url":"/p6-docs/reference/Types/point2_d#point2d","content":"Point2D(float x, float y); "},{"title":"Point2D()​","type":1,"pageTitle":"p6::Point2D","url":"/p6-docs/reference/Types/point2_d#point2d-1","content":"Point2D(glm::vec2 value); "},{"title":"value​","type":1,"pageTitle":"p6::Point2D","url":"/p6-docs/reference/Types/point2_d#value","content":"glm::vec2 value;   Updated on 2023 March 02 "},{"title":"p6::Radius","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/radius","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Radius","url":"/p6-docs/reference/Types/radius#summary","content":"\tName\tRadius() =default Radius(float value) float\tvalue "},{"title":"Details​","type":1,"pageTitle":"p6::Radius","url":"/p6-docs/reference/Types/radius#details","content":""},{"title":"Radius()​","type":1,"pageTitle":"p6::Radius","url":"/p6-docs/reference/Types/radius#radius","content":"Radius() =default; "},{"title":"Radius()​","type":1,"pageTitle":"p6::Radius","url":"/p6-docs/reference/Types/radius#radius-1","content":"Radius(float value); "},{"title":"value​","type":1,"pageTitle":"p6::Radius","url":"/p6-docs/reference/Types/radius#value","content":"float value {1.f};   Updated on 2023 March 02 "},{"title":"p6::Radii","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/radii","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Radii","url":"/p6-docs/reference/Types/radii#summary","content":"\tName\tRadii() =default Radii(float x, float y) Radii(glm::vec2 v) glm::vec2\tvalue "},{"title":"Details​","type":1,"pageTitle":"p6::Radii","url":"/p6-docs/reference/Types/radii#details","content":""},{"title":"Radii()​","type":1,"pageTitle":"p6::Radii","url":"/p6-docs/reference/Types/radii#radii","content":"Radii() =default; "},{"title":"Radii()​","type":1,"pageTitle":"p6::Radii","url":"/p6-docs/reference/Types/radii#radii-1","content":"Radii(float x, float y); "},{"title":"Radii()​","type":1,"pageTitle":"p6::Radii","url":"/p6-docs/reference/Types/radii#radii-2","content":"Radii(glm::vec2 v); "},{"title":"value​","type":1,"pageTitle":"p6::Radii","url":"/p6-docs/reference/Types/radii#value","content":"glm::vec2 value {1.f};   Updated on 2023 March 02 "},{"title":"p6::RadiusX","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/radius_x","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::RadiusX","url":"/p6-docs/reference/Types/radius_x#summary","content":"\tName\tRadiusX() =default RadiusX(float value) float\tvalue "},{"title":"Details​","type":1,"pageTitle":"p6::RadiusX","url":"/p6-docs/reference/Types/radius_x#details","content":""},{"title":"RadiusX()​","type":1,"pageTitle":"p6::RadiusX","url":"/p6-docs/reference/Types/radius_x#radiusx","content":"RadiusX() =default; "},{"title":"RadiusX()​","type":1,"pageTitle":"p6::RadiusX","url":"/p6-docs/reference/Types/radius_x#radiusx-1","content":"RadiusX(float value); "},{"title":"value​","type":1,"pageTitle":"p6::RadiusX","url":"/p6-docs/reference/Types/radius_x#value","content":"float value {1.f};   Updated on 2023 March 02 "},{"title":"p6::RadiusY","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/radius_y","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::RadiusY","url":"/p6-docs/reference/Types/radius_y#summary","content":"\tName\tRadiusY() =default RadiusY(float value) float\tvalue "},{"title":"Details​","type":1,"pageTitle":"p6::RadiusY","url":"/p6-docs/reference/Types/radius_y#details","content":""},{"title":"RadiusY()​","type":1,"pageTitle":"p6::RadiusY","url":"/p6-docs/reference/Types/radius_y#radiusy","content":"RadiusY() =default; "},{"title":"RadiusY()​","type":1,"pageTitle":"p6::RadiusY","url":"/p6-docs/reference/Types/radius_y#radiusy-1","content":"RadiusY(float value); "},{"title":"value​","type":1,"pageTitle":"p6::RadiusY","url":"/p6-docs/reference/Types/radius_y#value","content":"float value {1.f};   Updated on 2023 March 02 "},{"title":"p6::TopLeftCorner","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/top_left_corner","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::TopLeftCorner","url":"/p6-docs/reference/Types/top_left_corner#summary","content":"\tName\tTopLeftCorner() =default TopLeftCorner(float x, float y) TopLeftCorner(glm::vec2 value) glm::vec2\tvalue "},{"title":"Details​","type":1,"pageTitle":"p6::TopLeftCorner","url":"/p6-docs/reference/Types/top_left_corner#details","content":""},{"title":"TopLeftCorner()​","type":1,"pageTitle":"p6::TopLeftCorner","url":"/p6-docs/reference/Types/top_left_corner#topleftcorner","content":"TopLeftCorner() =default; "},{"title":"TopLeftCorner()​","type":1,"pageTitle":"p6::TopLeftCorner","url":"/p6-docs/reference/Types/top_left_corner#topleftcorner-1","content":"TopLeftCorner(float x, float y); "},{"title":"TopLeftCorner()​","type":1,"pageTitle":"p6::TopLeftCorner","url":"/p6-docs/reference/Types/top_left_corner#topleftcorner-2","content":"TopLeftCorner(glm::vec2 value); "},{"title":"value​","type":1,"pageTitle":"p6::TopLeftCorner","url":"/p6-docs/reference/Types/top_left_corner#value","content":"glm::vec2 value {0.f};   Updated on 2023 March 02 "},{"title":"p6::Shader","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/shader","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#summary","content":"\tName\tShader(std::string_view fragment_source_code) Throws std::runtime_error if there is an error while compiling the shader source code. Shader(std::string_view vertex_source_code, std::string_view fragment_source_code) Throws std::runtime_error if there is an error while compiling the shader source code. void\tset(std::string_view uniform_name, int value) const void\tset(std::string_view uniform_name, unsigned int value) const void\tset(std::string_view uniform_name, bool value) const void\tset(std::string_view uniform_name, float value) const void\tset(std::string_view uniform_name, const glm::vec2 &amp; value) const void\tset(std::string_view uniform_name, const glm::vec3 &amp; value) const void\tset(std::string_view uniform_name, const glm::vec4 &amp; value) const void\tset(std::string_view uniform_name, const glm::mat2 &amp; value) const void\tset(std::string_view uniform_name, const glm::mat3 &amp; value) const void\tset(std::string_view uniform_name, const glm::mat4 &amp; value) const void\tset(std::string_view uniform_name, const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; image) const ⚠️ You can have at most 8 images set at once. This is a limitation of the GPUs. void\tuse() const Sets this as the current shader that will be used for rendering. GLuint\tid() const Returns the OpenGL id of the program. void\tcheck_for_errors_before_rendering() const You can call this just before a draw call (e.g. glDrawArrays) to check if your shader is set up properly (all textures have been set, etc.) "},{"title":"Details​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#details","content":""},{"title":"Shader()​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#shader","content":"Shader(std::string_view fragment_source_code); Throws std::runtime_error if there is an error while compiling the shader source code. "},{"title":"Shader()​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#shader-1","content":"Shader(std::string_view vertex_source_code, std::string_view fragment_source_code); Throws std::runtime_error if there is an error while compiling the shader source code. "},{"title":"set()​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#set","content":"void set(std::string_view uniform_name, int value) const; "},{"title":"set()​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#set-1","content":"void set(std::string_view uniform_name, unsigned int value) const; "},{"title":"set()​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#set-2","content":"void set(std::string_view uniform_name, bool value) const; "},{"title":"set()​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#set-3","content":"void set(std::string_view uniform_name, float value) const; "},{"title":"set()​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#set-4","content":"void set(std::string_view uniform_name, const glm::vec2 &amp; value) const; "},{"title":"set()​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#set-5","content":"void set(std::string_view uniform_name, const glm::vec3 &amp; value) const; "},{"title":"set()​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#set-6","content":"void set(std::string_view uniform_name, const glm::vec4 &amp; value) const; "},{"title":"set()​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#set-7","content":"void set(std::string_view uniform_name, const glm::mat2 &amp; value) const; "},{"title":"set()​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#set-8","content":"void set(std::string_view uniform_name, const glm::mat3 &amp; value) const; "},{"title":"set()​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#set-9","content":"void set(std::string_view uniform_name, const glm::mat4 &amp; value) const; "},{"title":"set()​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#set-10","content":"void set(std::string_view uniform_name, const [ImageOrCanvas](/reference/Types/image_or_canvas) &amp; image) const; ⚠️ You can have at most 8 images set at once. This is a limitation of the GPUs. "},{"title":"use()​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#use","content":"void use() const; Sets this as the current shader that will be used for rendering. "},{"title":"id()​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#id","content":"GLuint id() const; Returns the OpenGL id of the program. This is for advanced uses only. "},{"title":"check_for_errors_before_rendering()​","type":1,"pageTitle":"p6::Shader","url":"/p6-docs/reference/Types/shader#check_for_errors_before_rendering","content":"void check_for_errors_before_rendering() const; You can call this just before a draw call (e.g. glDrawArrays) to check if your shader is set up properly (all textures have been set, etc.)  Updated on 2023 March 02 "},{"title":"p6::TopRightCorner","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/top_right_corner","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::TopRightCorner","url":"/p6-docs/reference/Types/top_right_corner#summary","content":"\tName\tTopRightCorner() =default TopRightCorner(float x, float y) TopRightCorner(glm::vec2 value) glm::vec2\tvalue "},{"title":"Details​","type":1,"pageTitle":"p6::TopRightCorner","url":"/p6-docs/reference/Types/top_right_corner#details","content":""},{"title":"TopRightCorner()​","type":1,"pageTitle":"p6::TopRightCorner","url":"/p6-docs/reference/Types/top_right_corner#toprightcorner","content":"TopRightCorner() =default; "},{"title":"TopRightCorner()​","type":1,"pageTitle":"p6::TopRightCorner","url":"/p6-docs/reference/Types/top_right_corner#toprightcorner-1","content":"TopRightCorner(float x, float y); "},{"title":"TopRightCorner()​","type":1,"pageTitle":"p6::TopRightCorner","url":"/p6-docs/reference/Types/top_right_corner#toprightcorner-2","content":"TopRightCorner(glm::vec2 value); "},{"title":"value​","type":1,"pageTitle":"p6::TopRightCorner","url":"/p6-docs/reference/Types/top_right_corner#value","content":"glm::vec2 value {0.f};   Updated on 2023 March 02 "},{"title":"p6::TransformScopeGuard","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/transform_scope_guard","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::TransformScopeGuard","url":"/p6-docs/reference/Types/transform_scope_guard#summary","content":"\tName\tTransformScopeGuard([Context](/reference/Types/context) &amp; ctx) ~TransformScopeGuard() "},{"title":"Details​","type":1,"pageTitle":"p6::TransformScopeGuard","url":"/p6-docs/reference/Types/transform_scope_guard#details","content":""},{"title":"TransformScopeGuard()​","type":1,"pageTitle":"p6::TransformScopeGuard","url":"/p6-docs/reference/Types/transform_scope_guard#transformscopeguard","content":"TransformScopeGuard([Context](/reference/Types/context) &amp; ctx); "},{"title":"~TransformScopeGuard()​","type":1,"pageTitle":"p6::TransformScopeGuard","url":"/p6-docs/reference/Types/transform_scope_guard#transformscopeguard-1","content":"~TransformScopeGuard();  Updated on 2023 March 02 "},{"title":"p6::Transform2D","type":0,"sectionRef":"#","url":"/p6-docs/reference/Types/transform2_d","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"p6::Transform2D","url":"/p6-docs/reference/Types/transform2_d#summary","content":"\tNameglm::vec2\tposition glm::vec2\tscale Rotation\trotation "},{"title":"Details​","type":1,"pageTitle":"p6::Transform2D","url":"/p6-docs/reference/Types/transform2_d#details","content":""},{"title":"position​","type":1,"pageTitle":"p6::Transform2D","url":"/p6-docs/reference/Types/transform2_d#position","content":"glm::vec2 position {0.f};  "},{"title":"scale​","type":1,"pageTitle":"p6::Transform2D","url":"/p6-docs/reference/Types/transform2_d#scale","content":"glm::vec2 scale {1.f};  "},{"title":"rotation​","type":1,"pageTitle":"p6::Transform2D","url":"/p6-docs/reference/Types/transform2_d#rotation","content":"Rotation rotation {0.0_radians};   Updated on 2023 March 02 "},{"title":"Update Flow","type":0,"sectionRef":"#","url":"/p6-docs/reference/update-flow","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"Update Flow","url":"/p6-docs/reference/update-flow#summary","content":""},{"title":"Functions​","type":1,"pageTitle":"Update Flow","url":"/p6-docs/reference/update-flow#functions","content":"\tNamevoid\tstart() Starts the update() loop. void\tstop() Stops the update() loop. void\tpause() Pauses the update() loop. void\tresume() Resumes the update() loop if it was paused with pause(). bool\tis_paused() const Returns true iff the update() loop is currently paused. "},{"title":"Functions​","type":1,"pageTitle":"Update Flow","url":"/p6-docs/reference/update-flow#functions-1","content":""},{"title":"start()​","type":1,"pageTitle":"Update Flow","url":"/p6-docs/reference/update-flow#start","content":"void start(); Starts the update() loop. update() will be called repeatedly, until you close the window or call stop(). "},{"title":"stop()​","type":1,"pageTitle":"Update Flow","url":"/p6-docs/reference/update-flow#stop","content":"void stop(); Stops the update() loop. This is the programatic equivalent of a user closing the window. "},{"title":"pause()​","type":1,"pageTitle":"Update Flow","url":"/p6-docs/reference/update-flow#pause","content":"void pause(); Pauses the update() loop. No update() will be called, until you call resume(). User inputs are still processed. "},{"title":"resume()​","type":1,"pageTitle":"Update Flow","url":"/p6-docs/reference/update-flow#resume","content":"void resume(); Resumes the update() loop if it was paused with pause(). It has no effect if the loop was already playing. "},{"title":"is_paused()​","type":1,"pageTitle":"Update Flow","url":"/p6-docs/reference/update-flow#is_paused","content":"bool is_paused() const; Returns true iff the update() loop is currently paused.  Updated on 2023 March 02 "},{"title":"Window","type":0,"sectionRef":"#","url":"/p6-docs/reference/window","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"Window","url":"/p6-docs/reference/window#summary","content":""},{"title":"Functions​","type":1,"pageTitle":"Window","url":"/p6-docs/reference/window#functions","content":"\tNamebool\twindow_is_focused() const Returns true iff the window is currently focused. void\tfocus_window() const Focuses the window, making it pop to the foreground. void\tmaximize_window() Maximizes the window. void\tminimize_window() Minimizes the window. Note that while your window is minimized everything will be frozen and no update, event or anything will happen. void\trestore_window() Restores the window if it is currently maximized. Does nothing otherwise. bool\twindow_is_maximized() const Returns true iff the window is currently maximized. void\tgo_fullscreen() Makes the window fullscreen. void\tescape_fullscreen() Exits the fullscreen mode. void\ttoggle_fullscreen() Goes fullscreen if it wasn't, escapes fullscreen if it was. bool\twindow_is_fullscreen() const Returns true iff the window is currently fullscreen. "},{"title":"Functions​","type":1,"pageTitle":"Window","url":"/p6-docs/reference/window#functions-1","content":""},{"title":"window_is_focused()​","type":1,"pageTitle":"Window","url":"/p6-docs/reference/window#window_is_focused","content":"bool window_is_focused() const; Returns true iff the window is currently focused. "},{"title":"focus_window()​","type":1,"pageTitle":"Window","url":"/p6-docs/reference/window#focus_window","content":"void focus_window() const; Focuses the window, making it pop to the foreground. "},{"title":"maximize_window()​","type":1,"pageTitle":"Window","url":"/p6-docs/reference/window#maximize_window","content":"void maximize_window(); Maximizes the window. "},{"title":"minimize_window()​","type":1,"pageTitle":"Window","url":"/p6-docs/reference/window#minimize_window","content":"void minimize_window(); Minimizes the window. Note that while your window is minimized everything will be frozen and no update, event or anything will happen. "},{"title":"restore_window()​","type":1,"pageTitle":"Window","url":"/p6-docs/reference/window#restore_window","content":"void restore_window(); Restores the window if it is currently maximized. Does nothing otherwise. "},{"title":"window_is_maximized()​","type":1,"pageTitle":"Window","url":"/p6-docs/reference/window#window_is_maximized","content":"bool window_is_maximized() const; Returns true iff the window is currently maximized. "},{"title":"go_fullscreen()​","type":1,"pageTitle":"Window","url":"/p6-docs/reference/window#go_fullscreen","content":"void go_fullscreen(); Makes the window fullscreen. Does nothing if it was already fullscreen. "},{"title":"escape_fullscreen()​","type":1,"pageTitle":"Window","url":"/p6-docs/reference/window#escape_fullscreen","content":"void escape_fullscreen(); Exits the fullscreen mode. Does nothing if the window wasn't fullscreen. "},{"title":"toggle_fullscreen()​","type":1,"pageTitle":"Window","url":"/p6-docs/reference/window#toggle_fullscreen","content":"void toggle_fullscreen(); Goes fullscreen if it wasn't, escapes fullscreen if it was. "},{"title":"window_is_fullscreen()​","type":1,"pageTitle":"Window","url":"/p6-docs/reference/window#window_is_fullscreen","content":"bool window_is_fullscreen() const; Returns true iff the window is currently fullscreen.  Updated on 2023 March 02 "},{"title":"angles","type":0,"sectionRef":"#","url":"/p6-docs/tutorials/angles","content":"angles const p6::Angle angle = 0.5_turn; const p6::Angle angle2 = 180_degrees; const p6::Angle angle3 = 3.14_radians; ","keywords":""},{"title":"Creating a project","type":0,"sectionRef":"#","url":"/p6-docs/tutorials","content":"","keywords":""},{"title":"Structure​","type":1,"pageTitle":"Creating a project","url":"/p6-docs/tutorials#structure","content":"Here is the minimal project structure that you need to have:  "},{"title":"CMakeLists.txt​","type":1,"pageTitle":"Creating a project","url":"/p6-docs/tutorials#cmakeliststxt","content":"CMakeLists.txt cmake_minimum_required(VERSION 3.20) project(my-p6-project) add_executable(${PROJECT_NAME} main.cpp) target_compile_features(${PROJECT_NAME} PRIVATE cxx_std_17) # ---Add p6--- add_subdirectory(p6) target_link_libraries(${PROJECT_NAME} p6::p6)  "},{"title":"main.cpp​","type":1,"pageTitle":"Creating a project","url":"/p6-docs/tutorials#maincpp","content":"main.cpp #include &lt;p6/p6.h&gt; int main() { auto ctx = p6::Context{{1280, 720, &quot;My p6 project&quot;}}; // Create a context with a window ctx.start(); // Start the p6 application }  "},{"title":"p6​","type":1,"pageTitle":"Creating a project","url":"/p6-docs/tutorials#p6","content":"To get the p6 folder, open a terminal at the root of your project and run: git clone --recursive https://github.com/JulesFouchy/p6  Or, if you have already setup a git repository for your project, you can add p6 as a submodule instead: git submodule add https://github.com/JulesFouchy/p6 git submodule update --init --recursive  (To learn about Git submodules, check out this lesson). "},{"title":"Conclusion​","type":1,"pageTitle":"Creating a project","url":"/p6-docs/tutorials#conclusion","content":"If everything went well you should be able to run your project and see this window:  Congrats 🎉 You can now start using p6 to build amazing artworks, interactive experiences and games! "},{"title":"Custom Shaders","type":0,"sectionRef":"#","url":"/p6-docs/tutorials/custom-shaders","content":"","keywords":""},{"title":"Load and Draw a shader​","type":1,"pageTitle":"Custom Shaders","url":"/p6-docs/tutorials/custom-shaders#load-and-draw-a-shader","content":"Important For this example to work you must have a res folder at the root of your project. And you must declare your res folder in CMake: p6_copy_folder(${PROJECT_NAME} res) Here is an example of a CMakeLists.txt. #include &lt;p6/p6.h&gt; int main() { auto ctx = p6::Context{}; const p6::Shader my_shader = p6::load_shader(&quot;res/my_shader.frag&quot;); ctx.update = [&amp;]() { ctx.background({}); ctx.rectangle_with_shader(my_shader, p6::FullScreen{}); }; ctx.start(); }  res/my_shader.frag #version 330 out vec4 _frag_color; in vec2 _uniform_uv; in vec2 _raw_uv; in vec2 _canvas_uv; uniform float _aspect_ratio; uniform float _inverse_aspect_ratio; uniform vec2 _size; uniform float _window_aspect_ratio; uniform float _window_inverse_aspect_ratio; void main() { vec2 uv = _uniform_uv; _frag_color = vec4(vec3(smoothstep(0.301, 0.3, length(uv))), 1.); // Draw a white disk }  "},{"title":"Available information​","type":1,"pageTitle":"Custom Shaders","url":"/p6-docs/tutorials/custom-shaders#available-information","content":""},{"title":"UV​","type":1,"pageTitle":"Custom Shaders","url":"/p6-docs/tutorials/custom-shaders#uv","content":"You have different coordinate systems available to you: _uniform_uv is what you should use most of the time. It is centered around (0, 0) and the y-axis goes from -1 to 1. The x-axis will adapt to the aspect ratio of the rectangle (goes from -_aspect_ratio to +_aspect_ratio)._raw_uv goes from 0 to 1 on both axes, no matter the aspect ratio of the rectangle. (0, 0) is in the bottom-left corner._canvas_uv is like _uniform_uv but the axes go from -rectangle_radii to +rectangle_radii. You will probably never have a use case for this one. It is used internally to draw strokes with an absolute size instead of them beeing proportional to the size of the rectangle. "},{"title":"Shape of the rectangle​","type":1,"pageTitle":"Custom Shaders","url":"/p6-docs/tutorials/custom-shaders#shape-of-the-rectangle","content":"_aspect_ratio: Aspect ratio of the rectangle (width / height)._inverse_aspect_ratio: Inverse aspect ratio of the rectangle (height / width)._size: Size of the rectangle. "},{"title":"Window​","type":1,"pageTitle":"Custom Shaders","url":"/p6-docs/tutorials/custom-shaders#window","content":"_window_aspect_ratio: Aspect ratio of the window (width / height)._window_inverse_aspect_ratio: Inverse aspect ratio of the window (height / width). "},{"title":"Sending parameters to shaders​","type":1,"pageTitle":"Custom Shaders","url":"/p6-docs/tutorials/custom-shaders#sending-parameters-to-shaders","content":"Parameters for shaders are called uniforms. You declare them in your shader like so: res/my_shader.frag #version 330 uniform float my_parameter; uniform vec3 another_parameter; // . . . void main() { _frag_color = vec4(another_parameter, 1.); // Use another_parameter like any other variable }  And you send them to your shader with set(): ctx.update = [&amp;]() { my_shader.set(&quot;my_parameter&quot;, 3.14f); my_shader.set(&quot;another_parameter&quot;, glm::vec3{0.1f, 0.4f, ctx.time()}); // . . . };  tip To send a Canvas or an Image, declare it in the shader as uniform sampler2D _my_image;. And to read from it use texture2D(_my_image, _raw_uv). Check out a full example: p6 code and shader. "},{"title":"Canvases","type":0,"sectionRef":"#","url":"/p6-docs/tutorials/canvases","content":"","keywords":""},{"title":"Changing the aspect ratio or size of the main canvas​","type":1,"pageTitle":"Canvases","url":"/p6-docs/tutorials/canvases#changing-the-aspect-ratio-or-size-of-the-main-canvas","content":"The drawing area of p6, known as the main canvas, doesn't have to take up the whole window, nor does it have to be limited to the current resolution of the window. You can control how its size behaves with ctx.main_canvas_mode(...). "},{"title":"SameAsWindow​","type":1,"pageTitle":"Canvases","url":"/p6-docs/tutorials/canvases#sameaswindow","content":"This is the default mode. The main canvas will have the same size as the window. It is great when you don't care about the aspect ratio or the number of pixels. ctx.main_canvas_mode(p6::CanvasSizeMode_SameAsWindow{});  "},{"title":"FixedAspectRatio​","type":1,"pageTitle":"Canvases","url":"/p6-docs/tutorials/canvases#fixedaspectratio","content":"The main canvas will have the given aspect ratio, and a size just big enough to perfectly fit into the window. It is great when you want your artwork to have a specific aspect ratio, like a 16/9 or a square canvas for example, but you don't care about the exact number of pixels because you are not saving it as an image but instead viewing it live as a running program that needs to adapt to whatever the size of the window is. ctx.main_canvas_mode(p6::CanvasSizeMode_FixedAspectRatio{16.f / 9.f});  "},{"title":"FixedSize​","type":1,"pageTitle":"Canvases","url":"/p6-docs/tutorials/canvases#fixedsize","content":"The main canvas will have the given size in pixels, independently of what the size of the window is. It is great when you want your artwork to have a specific size because you are gonna save it as an image and want to control its resolution. Note that you will still see the main canvas fit in the window because it is scaled down for display. But fear not, all the drawings are done at the size you requested. If you save the main canvas as an image (using ctx.save_image()) it will have the desired size. ctx.main_canvas_mode(p6::CanvasSizeMode_FixedSize{{3840, 2160}});  "},{"title":"RelativeToWindow​","type":1,"pageTitle":"Canvases","url":"/p6-docs/tutorials/canvases#relativetowindow","content":"The main canvas will have a size that is a multiple of the window's size. It can be useful if you want to reduce aliasing or noise by rendering at a bigger resolution. ctx.main_canvas_mode(p6::CanvasSizeMode_RelativeToWindow{2.f, 2.f});  "},{"title":"Drawing on a custom Canvas​","type":1,"pageTitle":"Canvases","url":"/p6-docs/tutorials/canvases#drawing-on-a-custom-canvas","content":"You are not constrained to the main canvas. You can also create your own canvases and draw on them. It can allow you to achieve some advanced and pretty cool effects.  All drawings between the calls to ctx.render_to_canvas(canvas) and ctx.render_to_main_canvas() will apply to your custom canvas instead of the main canvas: #include &lt;p6/p6.h&gt; int main() { auto ctx = p6::Context{}; auto canvas = p6::Canvas{ctx.main_canvas_size()}; // Create an empty canvas with the same size as the window ctx.main_canvas_resized = [&amp;]() { canvas.resize(ctx.main_canvas_size()); // Make sure that the canvas still has the same size as the window even after it resizes }; ctx.update = [&amp;]() { ctx.background({}); // Clear the window ctx.image(canvas); // Show the canvas if (ctx.shift()) // Do some permanent rendering on the canvas { ctx.render_to_canvas(canvas); ctx.circle(p6::Center{ctx.mouse() * ctx.canvas_ratio(canvas)}, // circle() applies to the custom canvas, not to the window's main canvas p6::Radius{0.3f}); ctx.render_to_main_canvas(); } ctx.circle(p6::Center{ctx.mouse()}, // Do some temporary rendering on the main canvas p6::Radius{0.3f / ctx.canvas_ratio(canvas)}); }; ctx.start(); }  For a more detailed example, check this one out. "},{"title":"Displaying a custom canvas​","type":1,"pageTitle":"Canvases","url":"/p6-docs/tutorials/canvases#displaying-a-custom-canvas","content":"Since custom canvases are not displayed in the window automatically, you need to draw them on the main canvas using ctx.image(): ctx.image(canvas); // The canvas will fill the window as best it can, while still preserving its aspect ratio  tip To convert coordinates and sizes from the window to a custom canvas fitted in that window, you can multiply or divide by ctx.canvas_ratio(canvas). This can help you make it feel like your custom canvas is really part of the window. (NB: it will only have an effect if your window is higher than it is wide. In the typical case of an horizontal window, canvas_ratio() is not required and everything should work naturally without you having to think about it). You can also specify the size and position of the canvas: ctx.image(canvas, p6::Center{}, p6::RadiusY{0.2f}); // Give it a height of 0.4 The width will be deduced based on the aspect_ratio of the canvas  Since a canvas has an aspect ratio that we want to try and preserve it is recommended to use either p6::RadiusX, p6::RadiusY, p6::FitX or p6::FitY to describe the size of the canvas. If you are ok with getting a distorted image then you can use p6::Radii to specify both the width and the height, or p6::FullScreen. "},{"title":"Dear ImGui","type":0,"sectionRef":"#","url":"/p6-docs/tutorials/dear-imgui","content":"","keywords":""},{"title":"Using Dear ImGui​","type":1,"pageTitle":"Dear ImGui","url":"/p6-docs/tutorials/dear-imgui#using-dear-imgui","content":"You simply have to render all your ImGui windows inside the ctx.update() function: #include &lt;p6/p6.h&gt; int main() { auto ctx = p6::Context{{1280, 720, &quot;Dear ImGui&quot;}}; auto square_radius = 0.5f; std::string text = &quot;Hello&quot;; ctx.update = [&amp;]() { // Show a simple window ImGui::Begin(&quot;Test&quot;); ImGui::SliderFloat(&quot;Square size&quot;, &amp;square_radius, 0.f, 1.f); ImGui::InputText(&quot;Text&quot;, &amp;text); ImGui::End(); // Show the official ImGui demo window // It is very useful to discover all the widgets available in ImGui ImGui::ShowDemoWindow(); ctx.background({1, 1, 0, 1}); ctx.square(p6::Center{}, p6::Radius{square_radius}); }; ctx.start(); }  Note that if you want your code to be a bit more structured, you can also put your ImGui code in the ctx.imgui() function: #include &lt;p6/p6.h&gt; int main() { auto ctx = p6::Context{{1280, 720, &quot;Dear ImGui&quot;}}; auto square_radius = 0.5f; std::string text = &quot;Hello&quot;; ctx.imgui = [&amp;]() { // Show a simple window ImGui::Begin(&quot;Test&quot;); ImGui::SliderFloat(&quot;Square size&quot;, &amp;square_radius, 0.f, 1.f); ImGui::InputText(&quot;Text&quot;, &amp;text); ImGui::End(); // Show the official ImGui demo window // It is very useful to discover all the widgets available in ImGui ImGui::ShowDemoWindow(); }; ctx.update = [&amp;]() { ctx.background({1, 1, 0, 1}); ctx.square(p6::Center{}, p6::Radius{square_radius}); }; ctx.start(); }  "},{"title":"Learning Dear ImGui​","type":1,"pageTitle":"Dear ImGui","url":"/p6-docs/tutorials/dear-imgui#learning-dear-imgui","content":"Here is Dear ImGui's GitHub tip Dear ImGui doesn't have an official documentation, but you can look at their demo window to see all the available widgets. To open it simply call ImGui::ShowDemoWindow(); inside ctx.imgui. And if you want to see the associated code, open Tools-&gt;Metrics/Debugger and then choose the Item Picker: it will allow you to click on any widget and have your IDE take you to the code that created it. (NB: you might have to go up in the callstack a little bit). "},{"title":"Drawing","type":0,"sectionRef":"#","url":"/p6-docs/tutorials/drawing","content":"","keywords":""},{"title":"background()​","type":1,"pageTitle":"Drawing","url":"/p6-docs/tutorials/drawing#background","content":"background() clears the whole canvas with one solid color. It is very useful if you want to do animations and don't want the drawings of the previous frames to remain on your canvas. On the other hand not using background() can give you very cool effects. ctx.update = [&amp;]() { ctx.background({0.2f, 0.1f, 0.3f}); // Comment out this line for an interesting effect ctx.circle(p6::Center{ctx.mouse()}, p6::Radius{0.3f}); };  And if you want your drawings to slowly fade away, draw a partially transparent rectangle instead of using background(): ctx.update = [&amp;]() { // Clear the background with a fading effect ctx.use_stroke = false; ctx.fill = {0.2f, 0.1f, 0.3f, 0.1f}; ctx.rectangle(p6::FullScreen{}); // Draw something ctx.fill = {1.f, 0.7f, 0.2f}; ctx.circle(p6::Center{ctx.mouse()}, p6::Radius{0.3f}); };  "},{"title":"Shapes​","type":1,"pageTitle":"Drawing","url":"/p6-docs/tutorials/drawing#shapes","content":"circle(), ellipse(), square(), rectangle() and triangle() have many overloads. Go to the reference to learn all about them. #include &lt;p6/p6.h&gt; int main() { auto ctx = p6::Context{}; p6::Angle rotation = 0.011_turn; ctx.mouse_scrolled = [&amp;](p6::MouseScroll e) { rotation += e.dy * 0.025_turn; }; ctx.update = [&amp;]() { ctx.background({}); ctx.stroke = {1, 1, 1, 1}; // White square positioned by Center ctx.square(p6::Center{ctx.mouse()}, p6::Radius{0.3f}, p6::Rotation{rotation}); // Red square positioned by Top Left Corner ctx.fill = {1, 0, 0, 0.5}; ctx.square(p6::TopLeftCorner{ctx.mouse()}, p6::Radius{0.3f}, p6::Rotation{rotation}); // Green square positioned by Top Right Corner ctx.fill = {0, 1, 0, 0.5}; ctx.square(p6::TopRightCorner{ctx.mouse()}, p6::Radius{0.3f}, p6::Rotation{rotation}); // Blue square positioned by Bottom Left Corner ctx.fill = {0, 0, 1, 0.5}; ctx.square(p6::BottomLeftCorner{ctx.mouse()}, p6::Radius{0.3f}, p6::Rotation{rotation}); // Cyan square positioned by Bottom Right Corner ctx.fill = {0, 1, 1, 0.5}; ctx.square(p6::BottomRightCorner{ctx.mouse()}, p6::Radius{0.3f}, p6::Rotation{rotation}); }; ctx.start(); }  "},{"title":"Colors​","type":1,"pageTitle":"Drawing","url":"/p6-docs/tutorials/drawing#colors","content":"Colors are expressed as RGBA, with each value going from 0.0 to 1.0: p6::Color color{1.f, 0.7f, 0.2f}; // A nice orange. // If you don't specify the fourth value (alpha, the opacity) it will be defaulted to 1.0  Shapes have two colors: the fill and the stroke. The fill controls the &quot;main&quot; color of the shapeThe stroke adds a second color on the edges of the shape. The size of that edge is controlled by stroke_weight. Both the fill and the stroke can be disabled with ctx.use_fill = false; and ctx.use_stroke = false;. #include &lt;p6/p6.h&gt; int main() { auto ctx = p6::Context{}; ctx.fill = {1, 1, 1}; // White ctx.stroke = {0, 0, 0}; // Black ctx.stroke_weight = 0.1f; ctx.background({0, 1, 1}); // Cyan ctx.use_fill = true; ctx.use_stroke = true; ctx.circle(p6::Center{-0.5f, 0.5f}, p6::Radius{0.5f}); ctx.use_fill = false; ctx.use_stroke = true; ctx.circle(p6::Center{0.5f, 0.5f}, p6::Radius{0.5f}); ctx.use_fill = true; ctx.use_stroke = false; ctx.circle(p6::Center{-0.5f, -0.5f}, p6::Radius{0.5f}); ctx.start(); }  "},{"title":"Line​","type":1,"pageTitle":"Drawing","url":"/p6-docs/tutorials/drawing#line","content":"ctx.line() is a bit of a special shape: it has only one color which is the stroke color, and its thickness is controlled by stroke_weight: #include &lt;p6/p6.h&gt; int main() { auto ctx = p6::Context{}; ctx.update = [&amp;]() { ctx.background({}); ctx.stroke = p6::Color{1.f, 1.f, 1.f, 0.75f}; ctx.stroke_weight = 0.1f; ctx.line(glm::vec2{0.f}, ctx.mouse()); }; ctx.start(); }   "},{"title":"Mouse and Keyboard","type":0,"sectionRef":"#","url":"/p6-docs/tutorials/events","content":"","keywords":""},{"title":"Events​","type":1,"pageTitle":"Mouse and Keyboard","url":"/p6-docs/tutorials/events#events","content":"update() is only one of the several functions you can define on the Context. There are also a few available that allow you to react to all the mouse and keyboard events: mouse_pressed, mouse_moved, key_released, and more! int main() { auto ctx = p6::Context{}; ctx.update = [&amp;]() { ctx.background({}); }; ctx.mouse_pressed = [](p6::MouseButton button) { std::cout &lt;&lt; button.position.x &lt;&lt; &quot; &quot; &lt;&lt; button.position.y &lt;&lt; &quot;\\n&quot; &lt;&lt; (button.button == p6::Button::Left ? &quot;Left&quot; : button.button == p6::Button::Right ? &quot;Right&quot; : &quot;Middle&quot;) &lt;&lt; &quot;\\n&quot;; }; ctx.start(); }  You can find the complete list in the Reference. "},{"title":"Queries​","type":1,"pageTitle":"Mouse and Keyboard","url":"/p6-docs/tutorials/events#queries","content":"You can also directly query at any moment to know if a given key or mouse button is pressed: if (ctx.key_is_pressed(GLFW_KEY_Q)) // ...  if (ctx.mouse_button_is_pressed(p6::Button::Left)) // ...  "},{"title":"Random","type":0,"sectionRef":"#","url":"/p6-docs/tutorials/random","content":"Random p6 comes with quite a few random functions. For example, to pick a random number between 0 and 1, use p6::random::number(); and to pick a random number between 3 and 7 use p6::random::number(3.f, 7.f);. You can also pick random points and random directions. To see the complete list, see the Reference.","keywords":""},{"title":"Images","type":0,"sectionRef":"#","url":"/p6-docs/tutorials/images","content":"","keywords":""},{"title":"Loading an image​","type":1,"pageTitle":"Images","url":"/p6-docs/tutorials/images#loading-an-image","content":"You can load any image (png, jpeg, etc.) with load_image(): const p6::Image image = p6::load_image(&quot;img/my_file.png&quot;);  Important In order for this to work you must have an img folder at the root of your project, with a my_file.png in it. AND you must declare your img folder in CMake: p6_copy_folder(${PROJECT_NAME} img). For a complete example of this, check out this example. "},{"title":"Displaying an image​","type":1,"pageTitle":"Images","url":"/p6-docs/tutorials/images#displaying-an-image","content":"You can draw an image with the image() function: const auto image = p6::load_image(&quot;img/my_file.png&quot;); ctx.image(image, p6::Center{}, p6::RadiusY{0.2f}); // Give it a height of 0.4 The width will be deduced based on the aspect_ratio of the image  Since an image has an aspect ratio that we want to try and preserve it is recommended to use either p6::RadiusX, p6::RadiusY, p6::FitX or p6::FitY to describe the size of the image. If you are ok with getting a distorted image then you can use p6::Radii to specify both the width and the height, or p6::FullScreen. "},{"title":"Read Pixel","type":0,"sectionRef":"#","url":"/p6-docs/tutorials/read-pixel","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Read Pixel","url":"/p6-docs/tutorials/read-pixel#brief","content":"You can ask for the color of a pixel with ctx.read_pixel(position). "},{"title":"Example​","type":1,"pageTitle":"Read Pixel","url":"/p6-docs/tutorials/read-pixel#example","content":"#include &lt;p6/p6.h&gt; int main() { auto ctx = p6::Context{}; ctx.update = [&amp;]() { ctx.background(p6::Color{1, 0, 0}); }; ctx.mouse_pressed = [&amp;](p6::MouseButton button) { const p6::Color color = ctx.read_pixel(button.position); assert(color == p6::Color{1, 0, 0}); }; ctx.start(); }  "},{"title":"Nota Bene​","type":1,"pageTitle":"Read Pixel","url":"/p6-docs/tutorials/read-pixel#nota-bene","content":"This function is meant to be used to read one single pixel from time to time, for example in mouse_pressed() or mouse_moved(). If you want to loop and read the color of all the pixels in the window, using read_pixel() will be pretty slow. A much better alternative (but arguably more complex to setup) would be to use a shader. "},{"title":"Saving Images","type":0,"sectionRef":"#","url":"/p6-docs/tutorials/saving-images","content":"Saving Images To save an image, simply call save_image(): Save the content of the window ctx.save_image(&quot;my_path/my_image.png&quot;); Save the content of any Canvas you created p6::save_image(my_custom_canvas, &quot;my_path/my_image.png&quot;); Check out a full example here. We can save either as .png or .jpeg. tip If the path already exists, a number will be appended to the name and the previous file won't be overwritten. If the path is relative, it will be relative to the directory containing your executable. If some directories in the path don't exist yet, they will be created automatically.","keywords":""},{"title":"Text","type":0,"sectionRef":"#","url":"/p6-docs/tutorials/text","content":"","keywords":""},{"title":"Rendering text​","type":1,"pageTitle":"Text","url":"/p6-docs/tutorials/text#rendering-text","content":"You can use the ctx.text() function. The color of the text is controlled by ctx.fill. The size of the text is controlled by ctx.text_size. #include &lt;p6/p6.h&gt; int main() { auto ctx = p6::Context{}; ctx.update = [&amp;]() { ctx.background(p6::NamedColor::Black); ctx.fill = p6::NamedColor::Red; ctx.text_size = 0.04f; ctx.text(u&quot;Some unicode text: éç&quot;, p6::Center{}); }; ctx.start(); }  info We support unicode characters (a.k.a. every character you could possibly ever want), but the default C++ strings only support ASCII. This is why text() takes a std::u16string, that you can create by adding the u prefix to your strings: u&quot;Some unicode text: éç&quot;. "},{"title":"The Context","type":0,"sectionRef":"#","url":"/p6-docs/tutorials/the-context","content":"The Context The Context is the center of your p6 application. It is responsible for the window you see on screen, and all the drawing and interaction happens through the Context. tip You can read the reference to discover everything that is available in the Context.","keywords":""},{"title":"The coordinate system","type":0,"sectionRef":"#","url":"/p6-docs/tutorials/the-coordinate-system","content":"","keywords":""},{"title":"Framebuffer​","type":1,"pageTitle":"The coordinate system","url":"/p6-docs/tutorials/the-coordinate-system#framebuffer","content":"If you need to you can access the size of the window's framebuffer through the ctx.framebuffer_size(), ctx.framebuffer_width() and ctx.framebuffer_height() functions. But I would not recommend to do so because in most cases you will be better off using relative coordinates. These functions are mainly here to allow you to create an Image that has the same size as the window's framebuffer, but this is an advanced use case. NB: the framebuffer is the image that you see in your window. It does not necessarily have the same size as the window itself since retina displays exist (see glfw's documentation). This is why we always talk about the size of the framebuffer instead of the size of the window. "},{"title":"Time and Framerate","type":0,"sectionRef":"#","url":"/p6-docs/tutorials/time-and-framerate","content":"","keywords":""},{"title":"Querying time information​","type":1,"pageTitle":"Time and Framerate","url":"/p6-docs/tutorials/time-and-framerate#querying-time-information","content":""},{"title":"time()​","type":1,"pageTitle":"Time and Framerate","url":"/p6-docs/tutorials/time-and-framerate#time","content":"ctx.time() returns the time in seconds since the creation of the Context. It is useful for example if you want your drawing to be a direct function of time: ctx.circle(p6::Center{sin(ctx.time(),0.f)});  "},{"title":"delta_time()​","type":1,"pageTitle":"Time and Framerate","url":"/p6-docs/tutorials/time-and-framerate#delta_time","content":"ctx.delta_time() returns the time in seconds that elapsed since the last update() call. It is useful for example if you want to do incremental movements frame by frame: taking delta_time() into account will make sure that your animation is independent of the framerate and will be perceived the same even if your computer starts lagging a little bit, or if you change the framerate mode. You really want to try and not depend on the framerate, for the framerate is an implementation detail and you would rather want to work at a conceptual level, with an animation that is continuous and only depends on the actual amount of time that elapses. This will also simplify your life when you will try to export your animation as a video. For more details, see this article: Understanding Time.deltaTime. float x = 0.f; ctx.update = [&amp;]() { x += 0.001f; // Bad, if the framerate doubles x will change twice as fast. x += 0.06f * ctx.delta_time(); // Good, we express our speed in units per second and changing the framerate won't change the animation speed. }  "},{"title":"Framerate​","type":1,"pageTitle":"Time and Framerate","url":"/p6-docs/tutorials/time-and-framerate#framerate","content":"The framerate mode controls the speed at which update() will be called, a.k.a. the amount of physical time that elapses between two updates. NB: all of these modes will try to satisfy your request but if your update() function takes too long to run we might not be able to call it as often as you would like. "},{"title":"Synced with monitor​","type":1,"pageTitle":"Time and Framerate","url":"/p6-docs/tutorials/time-and-framerate#synced-with-monitor","content":"ctx.framerate_synced_with_monitor();  This is the default mode. It makes sure that the framerate will be adapted to your monitor (which is 60 Hertz in most cases). This is known as vsync or vertical synchronization. This will ask less unnecessary work to your computer because it is pointless to render more frames than your monitor can display anyways. It also prevents visual artifacts like screen tearing. "},{"title":"As high as possible​","type":1,"pageTitle":"Time and Framerate","url":"/p6-docs/tutorials/time-and-framerate#as-high-as-possible","content":"ctx.framerate_as_high_as_possible();  This will remove any constraint on your framerate and call update() as fast as physically possible for your computer. This can be useful sometimes if you want to loop as fast as possible to see the end result of an animation. Please note that an alternative solution would be to keep framerate_synced_with_monitor() and call your animation in your own loop: MyParticleSystem particles{}; ctx.update = [&amp;]() { for (int _ = 0; _ &lt; 100; ++_) { // Do 100 particle updates in each ctx.update() to speed up the simulation particles.update(); } };  "},{"title":"Capped at​","type":1,"pageTitle":"Time and Framerate","url":"/p6-docs/tutorials/time-and-framerate#capped-at","content":"ctx.framerate_capped_at(5); // 5 fps  Allows you to decide what the framerate should be. This can be useful for example if you want to slow down your animation to see each frame better. "},{"title":"Time perceived as​","type":1,"pageTitle":"Time and Framerate","url":"/p6-docs/tutorials/time-and-framerate#time-perceived-as","content":"Controls what is returned by ctx.time() and ctx.delta_time(). "},{"title":"Realtime​","type":1,"pageTitle":"Time and Framerate","url":"/p6-docs/tutorials/time-and-framerate#realtime","content":"ctx.time_perceived_as_realtime();  ctx.time() and ctx.delta_time() will correspond to the actual amount of time that elapses in the real world. This is the default mode and it is ideal for realtime rendering. "},{"title":"Constant delta time​","type":1,"pageTitle":"Time and Framerate","url":"/p6-docs/tutorials/time-and-framerate#constant-delta-time","content":"ctx.time_perceived_as_constant_delta_time(30.f); // I want to export a 30 fps video  ctx.time() and ctx.delta_time() will pretend that time elapses at exactly the framerate you asked. This is ideal for offline rendering because it won't be affected by the time it actually takes to run your update() function. "},{"title":"Pause and resume​","type":1,"pageTitle":"Time and Framerate","url":"/p6-docs/tutorials/time-and-framerate#pause-and-resume","content":"Note that using pause() will not only prevent update() from beeing called, but also freeze the time (even if you use realtime mode). For example if time() was 10.f when you called pause(), and if you wait 5 seconds before calling resume(), time will still be 10.f after that and delta_time() will not be 5 seconds, it will be approximately 1/60 (if your framerate is set to 60 fps). "},{"title":"Transform","type":0,"sectionRef":"#","url":"/p6-docs/tutorials/transform","content":"","keywords":""},{"title":"Basics​","type":1,"pageTitle":"Transform","url":"/p6-docs/tutorials/transform#basics","content":"Transforms allow you to move all your drawings at once. You can use ctx.translate(...), ctx.rotate(...) and ctx.scale(...). #include &lt;p6/p6.h&gt; int main() { auto ctx = p6::Context{{1280, 720, &quot;Transform&quot;}}; ctx.update = [&amp;]() { const auto transform_sg = ctx.transform_scope_guard(); // Makes sure that, when `transform_sg` will go out of scope, // the transform will be reset to the state it had when `transform_sg` was created. ctx.translate({0.5f, 0.f}); ctx.rotate(0.1_turn); ctx.scale({0.85f}); // This square and this circle will both be translated by {0.5f, 0.f}, rotated by 0.1 turn and scaled by 0.85 ctx.square(p6::Center{0.f, 0.f}, p6::Radius{0.3f}); ctx.circle(p6::Center{0.f, 0.f}, p6::Radius{0.3f}); }; ctx.start(); }  "},{"title":"Restoring the previous transform​","type":1,"pageTitle":"Transform","url":"/p6-docs/tutorials/transform#restoring-the-previous-transform","content":""},{"title":"push_transform() / pop_transform()​","type":1,"pageTitle":"Transform","url":"/p6-docs/tutorials/transform#push_transform--pop_transform","content":"push_transform() saves the current transform on a stack, and pop_transform() goes back one step into the stack of transforms saved by push_transform(). ctx.push_transform(); // Push 1 ctx.translate({0.5f, 0.f}); ctx.push_transform(); // Push 2 ctx.rotate(0.1_turn); ctx.pop_transform(); // Goes back to the Push 2, i.e. undoes the `rotate()` ctx.pop_transform(); // Goes back to the Push 1, i.e. undoes the `translate()`  "},{"title":"transform_scope_guard()​","type":1,"pageTitle":"Transform","url":"/p6-docs/tutorials/transform#transform_scope_guard","content":"transform_scope_guard() calls push_transform() and creates a variable that will call pop_transform() when it goes out of scope. This is a means of automatically calling the pop that logically follows the push. It is the recommended way to manage your transforms. { const auto sg1 = ctx.transform_scope_guard(); // Scope Guard 1 ctx.translate({0.5f, 0.f}); { const auto sg2 = ctx.transform_scope_guard(); // Scope Guard 2 ctx.rotate(0.1_turn); } // `sg2` is destroyed here so we go back to the state of Scope Guard 2, i.e. we undo the `rotate()` } // `sg1` is destroyed here so we go back to the state of Scope Guard 1, i.e. we undo the `translate()`  "},{"title":"reset_transform()​","type":1,"pageTitle":"Transform","url":"/p6-docs/tutorials/transform#reset_transform","content":"reset_transform() undoes all the transforms that have ever been applied. "},{"title":"Advanced​","type":1,"pageTitle":"Transform","url":"/p6-docs/tutorials/transform#advanced","content":"You also have access to ctx.apply_transform(...), ctx.set_transform(...) and ctx.current_transform() if you want to manipulate the transform matrix directly. "},{"title":"More examples​","type":1,"pageTitle":"Transform","url":"/p6-docs/tutorials/transform#more-examples","content":"See here. "}]